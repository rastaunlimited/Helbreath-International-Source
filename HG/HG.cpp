// Game.cpp: implementation of the CGame class.
//
//////////////////////////////////////////////////////////////////////

#include "HG.h"
#include "ui\Winmain.h"
#include "char\movement.h"
#include "char\combat.h"

extern char g_cTxt[512];
extern char g_msg[50];
extern char	G_cData50000[50000];

extern HWND	G_hWnd;

extern class CMap	**	g_mapList;
extern class CClient ** g_clientList;
extern class CNpc **	g_npcList;
extern class CNpc **   g_npcConfigList;
extern class CMagic ** g_magicConfigList;

extern int * g_skillSSNpoint;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGame::CGame(HWND hWnd) : m_hWnd(hWnd)
{
	int i, x;

	GSID = -1;
	m_bIsGameServerRegistered = FALSE;
	ReceivedAllConfig		= FALSE;
	m_bIsGameStarted = FALSE;
	m_bIsItemAvailable      = FALSE;
	m_bIsBuildItemAvailable = FALSE;
	m_bIsNpcAvailable       = FALSE;
	m_bIsMagicAvailable     = FALSE;
	m_bIsSkillAvailable     = FALSE;
	m_bIsQuestAvailable     = FALSE;
	m_bIsPotionAvailable   = FALSE;

	ZeroMemory(m_cServerName, sizeof(m_cServerName));

	m_sForceRecallTime = 0 ;

	g_clientList = m_pClientList;
	for (i = 0; i < MAXCLIENTS; i++)
		m_pClientList[i] = NULL;

	g_mapList = m_pMapList;
	for (i = 0; i < MAXMAPS; i++)
		m_pMapList[i] = NULL;

	for (i = 0; i < MAXITEMTYPES; i++)
		m_pItemConfigList[i] = NULL;

	g_npcConfigList = m_npcConfigList;
	for (i = 0; i < MAXNPCTYPES; i++)
		m_npcConfigList[i] = NULL;

	g_npcList = m_pNpcList;
	for (i = 0; i < MAXNPCS; i++)
		m_pNpcList[i] = NULL;

	for (i = 0; i < MSGQUENESIZE; i++)
		m_pMsgQuene[i] = NULL;

	g_magicConfigList = m_pMagicConfigList;
	for (i = 0; i < MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = NULL;

	for (i = 0; i < MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = NULL;

	for (i = 0; i < MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = NULL;

	for (i = 0; i < MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = NULL;

	for (i = 0; i < MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = NULL;

	for (i = 0; i < MAXNOTIFYMSGS; i++)
		m_pNoticeMsgList[i] = NULL;

	for (i = 0; i < MAXFISHS; i++)
		m_pFish[i] = NULL;

	for (i = 0; i < MAXMINERALS; i++)
		m_pMineral[i] = NULL;

	for (i = 0; i < MAXPOTIONTYPES; i++)
		m_pPotionConfigList[i] = NULL;

	for (i = 0; i < MAXCRAFTING; i++)
		m_pCraftingConfigList[i] = NULL; 

	for (i = 0; i < MAXSUBLOGSOCK; i++) {
		m_pSubLogSock[i] = NULL;
		m_bIsSubLogSockAvailable[i] = FALSE;
		m_bIsSocketConnected[i] = FALSE;
	}

	for (i = 0; i < MAXBUILDITEMS; i++) 
		m_pBuildItemList[i] = NULL;

	for (i = 0; i < MAXDUPITEMID; i++)
		m_pDupItemIDList[i] = NULL;

	for (i = 0; i < MAXPARTYNUM; i++) 
	{
		for (x = 0; x < MAXPARTYMEMBERS; x++) {
			m_stPartyInfo[i].iTotalMembers = 0;
			m_stPartyInfo[i].iIndex[x] = 0;
		}
	}

	for ( i = 0; i < MAXGROUNDITEMS; i++ )
	{
		m_stGroundNpcItem[i].bEmpty = TRUE;
		m_stGroundNpcItem[i].cMapIndex = 0;
		m_stGroundNpcItem[i].dropTime = 0;
		m_stGroundNpcItem[i].item = NULL;
		m_stGroundNpcItem[i].sx = m_stGroundNpcItem[i].sy = 0;
	}

		m_iQueneHead = 0;
		m_iQueneTail = 0;

		m_iTotalClients = 0;
		m_iMaxClients   = 0;
		m_iTotalMaps    = 0;

		m_iTotalGameServerClients    = 0;
		m_iTotalGameServerMaxClients = 0;

		m_bIsServerShutdowned = FALSE;
		m_cShutDownCode = 0;

		m_iMiddlelandMapIndex = -1;
		m_iAresdenOccupyTiles = 0;
		m_iElvineOccupyTiles  = 0;

		m_iCurMsgs = 0;
		m_iMaxMsgs = 0;

		for(int i=0; i < MAXSIDES; i++)
		{
			m_stCityStatus[i].iCrimes = 0;
			m_stCityStatus[i].iFunds  = 0;
			m_stCityStatus[i].iWins   = 0;
		}
		m_sSlateSuccessRate		= 0;
		m_iPrimaryDropRate		= 0;
		m_iSecondaryDropRate	= 0;
		m_iEnemyKillAdjust      = 1; 
		m_sRaidTimeMonday		= 0; 
		m_sRaidTimeTuesday      = 0; 
		m_sRaidTimeWednesday	= 0; 
		m_sRaidTimeThursday     = 0; 
		m_sRaidTimeFriday		= 0; 
		m_sRaidTimeSaturday     = 0; 
		m_sRaidTimeSunday		= 0;
		m_sCharPointLimit		= 0;
		m_sExpModifier		= 0;
		m_sCharSkillLimit		= 0;

		m_iAutoRebootingCount = 0;

		m_pGold = NULL ;

		// 2002-09-09 #1
		m_bReceivedItemList = false;
}

CGame::~CGame()
{

}

bool CGame::bAccept(class XSocket * pXSock)
{
	register int i;
	class XSocket * pTmpSock;
	char  cTxt[80];
	bool valid = FALSE;
	int iTotalip;

	pTmpSock = new class XSocket(m_hWnd, CLIENTSOCKETBLOCKLIMIT);

	if ((m_bIsItemAvailable == FALSE)     || (m_bIsNpcAvailable == FALSE)       || 
		(m_bIsMagicAvailable == FALSE)    || (m_bIsSkillAvailable == FALSE)     || 
		(m_bIsPotionAvailable == FALSE)  || (m_bOnExitProcess == TRUE)         || 
		(m_bIsQuestAvailable == FALSE)    || (m_bIsBuildItemAvailable == FALSE) ||
		(m_bIsGameStarted == FALSE)
		) 
		goto CLOSE_ANYWAY;

	for (i = 1; i < MAXCLIENTS; i++)
		if (m_pClientList[i] == NULL) {
			
			pTmpSock->bInitBufferSize(MSGBUFFERSIZE);
			pXSock->bAccept(pTmpSock, WM_ONCLIENTSOCKETEVENT + i); 

			ZeroMemory(cTxt, sizeof(cTxt));
			pTmpSock->iGetPeerAddress(cTxt);



			for(std::list<ConfirmedIP>::iterator it = confirmedIPs.begin(); it != confirmedIPs.end(); ++it)
				if(strcmp(it->ip, cTxt) == 0){
					valid = TRUE;
					confirmedIPs.erase(it);
					break;
				}
		
			/*if(!valid) 
			{
				wsprintf(g_cTxt,"(!!) Non-permitted client: %s", cTxt);
				PutLogList(g_cTxt);
				delete pTmpSock;
				return FALSE;
			}*/

			m_pClientList[i] = new class CClient(m_hWnd, i);
			m_pClientList[i]->m_pXSock = pTmpSock;


			ZeroMemory(m_pClientList[i]->m_cIPaddress, sizeof(m_pClientList[i]->m_cIPaddress));
			m_pClientList[i]->m_pXSock->iGetPeerAddress(m_pClientList[i]->m_cIPaddress);
			for (int x = 1; x < MAXCLIENTS; x++)
				if(m_pClientList[x] != NULL) {
					if(strcmp(m_pClientList[x]->m_cIPaddress, m_pClientList[i]->m_cIPaddress) == 0) iTotalip++;
				}
				if(iTotalip > 2) {
					delete m_pClientList[i];
					m_pClientList[i] = NULL;
					return FALSE;
				}

			bAddClientShortCut(i);

			m_pClientList[i]->m_dwSPTime = m_pClientList[i]->m_dwMPTime = 
				m_pClientList[i]->m_dwHPTime = m_pClientList[i]->m_dwAutoSaveTime = 
				m_pClientList[i]->m_dwTime = m_pClientList[i]->m_dwHungerTime = m_pClientList[i]->m_dwExpStockTime = 
				m_pClientList[i]->m_dwRecentAttackTime = m_pClientList[i]->m_dwAutoExpTime = timeGetTime();
			
			ZeroMemory(m_pClientList[i]->m_cIPaddress, sizeof(m_pClientList[i]->m_cIPaddress));
			strcpy(m_pClientList[i]->m_cIPaddress, cTxt);

			wsprintf(g_cTxt,"<%d> New client: %s", i, m_pClientList[i]->m_cIPaddress);
			PutLogList(g_cTxt);

			m_iTotalClients++;

			if (m_iTotalClients > m_iMaxClients) {

				m_iMaxClients = m_iTotalClients;
				//wsprintf(cTxt, "Maximum Players: %d", m_iMaxClients);
				//PutLogFileList(cTxt);
			}

			return TRUE;
		}

CLOSE_ANYWAY:;
	pXSock->bAccept(pTmpSock, NULL); 
	delete pTmpSock;

	return FALSE;
}


void CGame::OnClientSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
	UINT iTmp;
	register int iClientH, iRet;
	DWORD dwTime = timeGetTime();


	iTmp = WM_ONCLIENTSOCKETEVENT;
	iClientH = message - iTmp;

	if (m_pClientList[iClientH] == NULL) return;

	iRet = m_pClientList[iClientH]->m_pXSock->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case XSOCKEVENT_READCOMPLETE:
		OnClientRead(iClientH);
		m_pClientList[iClientH]->m_dwTime = timeGetTime();
		break;

	case XSOCKEVENT_BLOCK:
		PutLogList("Socket BLOCKED!");
		break;

	case XSOCKEVENT_CONFIRMCODENOTMATCH:
		wsprintf(g_cTxt,"<%d> Confirmcode notmatch!", iClientH);
		PutLogList(g_cTxt);
		DeleteClient(iClientH, FALSE, TRUE);
		break;

	case XSOCKEVENT_MSGSIZETOOLARGE:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		wsprintf(g_cTxt,"<%d> Client Disconnected! (%s)", iClientH, m_pClientList[iClientH]->m_cIPaddress);
		PutLogList(g_cTxt); 
		if ((dwTime - m_pClientList[iClientH]->m_dwLogoutHackCheck) < 1000) {
			wsprintf(g_cTxt, "Logout Hack: (%s) Player: (%s) - disconnected within 10 seconds of most recent damage. Hack? Lag?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutLogFileList(g_cTxt);
		}

		DeleteClient(iClientH, TRUE, TRUE);
		break;
	}													    
}


bool CGame::bInit()		   
{
	char * cp;
	DWORD * dwp;
	WORD * wp;
	int  i;
	SYSTEMTIME SysTime;
	DWORD dwTime = timeGetTime();

	//m_Misc.Temp();

	PutLogList("(*) INITIALIZING GAME SERVER...");
	//

	for (i = 0; i < MAXCLIENTS+1; i++)
		m_iClientShortCut[i] = 0;

	for (i = 0; i < MAXSUBLOGSOCK; i++)
		if (m_pSubLogSock[i] != NULL) delete m_pSubLogSock[i];

	for (i = 0; i < MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) delete m_pClientList[i];

	// Remember erazed clients
	for (i = 0; i < MAXCLIENTS; i++) {
		m_stOldClientList[i].iClientH = 0;
		ZeroMemory(m_stOldClientList[i].m_cCharName, sizeof(m_stOldClientList[i].m_cCharName));
		ZeroMemory(m_stOldClientList[i].m_cAccountName, sizeof(m_stOldClientList[i].m_cAccountName));
		ZeroMemory(m_stOldClientList[i].m_cAccountPassword, sizeof(m_stOldClientList[i].m_cAccountPassword));
		m_stOldClientList[i].m_dwDeleteTime = 0;

	}
	for (i = 0; i < MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) delete m_pNpcList[i];

	for (i = 0; i < MAXMAPS; i++)
		if (m_pMapList[i] != NULL) delete m_pMapList[i];

	for (i = 0; i < MAXITEMTYPES; i++)
		if (m_pItemConfigList[i] != NULL) delete m_pItemConfigList[i];

	for (i = 0; i < MAXNPCTYPES; i++)
		if (m_npcConfigList[i] != NULL) delete m_npcConfigList[i];

	for (i = 0; i < MAXMAGICTYPE; i++)
		if (m_pMagicConfigList[i] != NULL) delete m_pMagicConfigList[i];

	for (i = 0; i < MAXSKILLTYPE; i++)
		if (m_pSkillConfigList[i] != NULL) delete m_pSkillConfigList[i];

	for (i = 0; i < MAXQUESTTYPE; i++)
		if (m_pQuestConfigList[i] != NULL) delete m_pQuestConfigList[i];

	for (i = 0; i < MAXDYNAMICOBJECTS; i++)
		if (m_pDynamicObjectList[i] != NULL) delete m_pDynamicObjectList[i];

	for (i = 0; i < MAXDELAYEVENTS; i++)
		if (m_pDelayEventList[i] != NULL) delete m_pDelayEventList[i];

	for (i = 0; i < MAXNOTIFYMSGS; i++)
		if (m_pNoticeMsgList[i] != NULL) delete m_pNoticeMsgList[i];

	for (i = 0; i < MAXFISHS; i++)
		if (m_pFish[i] != NULL) delete m_pFish[i];

	for (i = 0; i < MAXMINERALS; i++)
		if (m_pMineral[i] != NULL) delete m_pMineral[i];

	for (i = 0; i < MAXPOTIONTYPES; i++)
		if (m_pPotionConfigList[i] != NULL) delete m_pPotionConfigList[i];
	//
	for (i = 0; i < MAXCRAFTING; i++)
		if (m_pCraftingConfigList[i] != NULL) delete m_pCraftingConfigList[i]; 

	for (i = 0; i < MAXBUILDITEMS; i++) 
		if (m_pBuildItemList[i] != NULL) delete m_pBuildItemList[i];

	for (i = 0; i < MAXNPCTYPES; i++)
		m_iNpcConstructionPoint[i] = NULL;

	for (i = 0; i < MAXSCHEDULE; i++) {
		m_schedules[i].iDay = -1;
		m_schedules[i].iHour = -1;
		m_schedules[i].iMinute = -1;
		m_schedules[i].evStatus = ES_ENDED;
		m_schedules[i].evType = ET_NONE;
	}

	m_iNpcConstructionPoint[1]  = 100; // MS
	m_iNpcConstructionPoint[2]  = 100; // MS
	m_iNpcConstructionPoint[3]  = 100; // MS
	m_iNpcConstructionPoint[4]  = 100; // MS
	m_iNpcConstructionPoint[5]  = 100; // MS
	m_iNpcConstructionPoint[6]  = 100; // MS

	m_iNpcConstructionPoint[43] = 1000; // LWB
	m_iNpcConstructionPoint[44] = 2000; // GHK
	m_iNpcConstructionPoint[45] = 3000; // GHKABS
	m_iNpcConstructionPoint[46] = 2000; // TK
	m_iNpcConstructionPoint[47] = 3000; // BG

	m_iNpcConstructionPoint[51] = 1500; // Catapult
	//

	m_bIsGameStarted = FALSE;

	m_bIsItemAvailable      = FALSE;
	m_bIsBuildItemAvailable = FALSE;
	m_bIsNpcAvailable       = FALSE;
	m_bIsMagicAvailable     = FALSE;
	m_bIsSkillAvailable     = FALSE;
	m_bIsQuestAvailable     = FALSE;
	m_bIsPotionAvailable   = FALSE;
	ReceivedAllConfig		= FALSE;

	ZeroMemory(m_cServerName, sizeof(m_cServerName));

	for (i = 0; i < MAXCLIENTS; i++)
		m_pClientList[i] = NULL;

	for (i = 0; i < MAXMAPS; i++)
		m_pMapList[i] = NULL;

	for (i = 0; i < MAXITEMTYPES; i++)
		m_pItemConfigList[i] = NULL;

	for (i = 0; i < MAXNPCTYPES; i++)
		m_npcConfigList[i] = NULL;

	for (i = 0; i < MAXNPCS; i++)
		m_pNpcList[i] = NULL;

	for (i = 0; i < MSGQUENESIZE; i++)
		m_pMsgQuene[i] = NULL;

	for (i = 0; i < MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = NULL;

	for (i = 0; i < MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = NULL;

	for (i = 0; i < MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = NULL;

	for (i = 0; i < MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = NULL;

	for (i = 0; i < MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = NULL;

	for (i = 0; i < MAXNOTIFYMSGS; i++)
		m_pNoticeMsgList[i] = NULL;

	for (i = 0; i < MAXFISHS; i++)
		m_pFish[i] = NULL;

	for (i = 0; i < MAXMINERALS; i++)
		m_pMineral[i] = NULL;

	for (i = 0; i < MAXPOTIONTYPES; i++)
		m_pPotionConfigList[i] = NULL;

	for (i = 0; i < MAXCRAFTING; i++)
		m_pCraftingConfigList[i] = NULL; 

	for (i = 0; i < MAXSUBLOGSOCK; i++) {
		m_pSubLogSock[i] = NULL;
		m_bIsSubLogSockAvailable[i] = FALSE;
	}

	for (i = 0; i < MAXBUILDITEMS; i++) 
		m_pBuildItemList[i] = NULL;

	for (i = 0; i < MAXCRUSADESTRUCTURES; i++) {
		ZeroMemory(m_stCrusadeStructures[i].cMapName, sizeof(m_stCrusadeStructures[i].cMapName));
		m_stCrusadeStructures[i].cType = NULL;
		m_stCrusadeStructures[i].dX    = NULL;
		m_stCrusadeStructures[i].dY    = NULL;
	}


	for (i = 0; i < MAXTELEPORTLIST; i++)
		m_pTeleportConfigList[i] = NULL;

	for (i = 0; i < MAXGUILDS; i++)
		m_pGuildTeleportLoc[i].m_iV1 = NULL;

	for (i = 0; i < MAXCRUSADESTRUCTURES; i++) {
		m_stMiddleCrusadeStructureInfo[i].cType = NULL;
		m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
		m_stMiddleCrusadeStructureInfo[i].sX = NULL;
		m_stMiddleCrusadeStructureInfo[i].sY = NULL;
	}
	m_iTotalMiddleCrusadeStructures = 0;

	m_pNoticementData = NULL;

	m_iQueneHead = 0;
	m_iQueneTail = 0;

	m_iTotalClients = 0;
	m_iMaxClients   = 0;
	m_iTotalMaps    = 0;

	m_iTotalGameServerClients    = 0;
	m_iTotalGameServerMaxClients = 0;

	m_bIsServerShutdowned = FALSE;
	m_cShutDownCode = 0;

	m_iMiddlelandMapIndex = -1;
	m_iAresdenMapIndex    = -1;
	m_iElvineMapIndex     = -1;
	m_iIstriaMapIndex     = -1;
	m_iAstoriaMapIndex    = -1;
	m_iBtFieldMapIndex			= -1;
	m_iRampartMapIndex			= -1;
	m_iGodHMapIndex				= -1;

	ShuffleAstoriaBasePos();
	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles  = 0;

	m_eventsIni = new CIni("..\\configs\\stats.ini", "events");

	for(int i=0; i < ET_MAX; i++)
	{
		sstream eventType;
		eventType << i;
		m_eventWinner[i] = (Side)m_eventsIni->ReadInteger(eventType.str().c_str(), NEUTRAL);
	}

	m_iSubLogSockInitIndex   = 0;

	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;

	for(int i=0; i < MAXSIDES; i++)
	{
		m_stCityStatus[i].iCrimes = 0;
		m_stCityStatus[i].iFunds  = 0;
		m_stCityStatus[i].iWins   = 0;

		m_iCollectedMana[i] = 0;
		m_mana[i] = 0;
	}

	m_iStrategicStatus = 0;

	m_dwSpecialEventTime = m_dwWhetherTime = m_dwGameTime1 = 
		m_dwGameTime2 = m_dwGameTime3 = m_dwGameTime4 = m_dwGameTime5 = m_dwGameTime6 = m_dwFishTime = dwTime;

	m_bIsSpecialEventTime = FALSE;

	GetLocalTime(&SysTime);

	m_dwCanFightzoneReserveTime =  dwTime -  ((SysTime.wHour%2)*60*60 + SysTime.wMinute*60) *1000 ;


	for(i =0; i < MAXFIGHTZONE; i++) 
		m_iFightZoneReserve[i] = 0 ;


	m_iFightzoneNoForceRecall = 0;

	ZeroMemory(m_websiteScriptAddr, sizeof(m_websiteScriptAddr));
	ZeroMemory(m_websiteAddr,sizeof(m_websiteAddr));
	m_websitePort = 0;

	for (i = 1; i < 900; i++) {
		m_iLevelExpTable[i] = iGetLevelExp(i);
			//testcode
			wsprintf(g_cTxt, "Level:%d --- Exp:%d", i, m_iLevelExpTable[i]);
			PutLogFileList(g_cTxt);
	}

	m_iLimitedUserExp = m_iLevelExpTable[LEVELLIMIT+1]; 
	m_iLevelExp51     = m_iLevelExpTable[51];

	m_iClientConnectionCheckTime = 8000;		// default client gap is 8000 or 8000+1000 
	m_iClientConnectionCheckTimeRound = 8000;	// default client gap is 8000 or 8000+1000 
	m_iClientConnectionCheckMaxNumber = 33;		// x+2000/300
	
	// m_iGameServerMode = 0;

	if (bReadProgramConfigFile("GServer.cfg") == FALSE) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! config file contents error!");
		return FALSE;
	}
	if (bReadSettingsConfigFile("Settings.cfg") == FALSE) {;
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Settings.cfg file contents error!");
		return FALSE;
	}
	srand( (unsigned)time( NULL ) );   

	m_bF1pressed = m_bF4pressed = m_bF12pressed = FALSE;

	m_bOnExitProcess = FALSE;


	g_skillSSNpoint = m_iSkillSSNpoint;
	for (i = 0; i <= 100; i++) {
		m_iSkillSSNpoint[i] = _iCalcSkillSSNpoint(i);
	}


	GetLocalTime(&SysTime);
	if (SysTime.wMinute >= NIGHTTIME) 
		m_cDayOrNight = 2;
	else m_cDayOrNight = 1;


	bReadNotifyMsgListFile("notice.txt");
	m_dwNoticeTime = m_startTime = dwTime;
	m_onlineCntAdd = 1;

	m_iCurSubLogSockIndex    = 0;
	m_iSubLogSockFailCount   = 0;
	m_iSubLogSockActiveCount = 0;

	m_pNoticementData      = NULL;
	m_dwNoticementDataSize = 0;

	m_dwMapSectorInfoTime = dwTime;
	m_iMapSectorInfoUpdateCount = 0;

	m_bIsCrusadeMode = FALSE;
	//GSID = (WORD) dice(1,65535);
	m_bIsApocalypseMode = FALSE;
	m_bIsApocalypseGateOpen	= FALSE; 

	m_iHeldenianType				= 0;
	m_iLastHeldenianType			= 0;
	m_bHeldenianMode				= FALSE;
	m_dwHeldenianGUID				= NULL;
	m_iHeldenianType1Winner			= -1;
	m_iHeldenianType2Winner			= -1;
	m_iHeldenianAresdenLeftTower	= 0;
	m_iHeldenianElvineLeftTower		= 0;
	m_iHeldenianAresdenFlags		= 0;
	m_iHeldenianElvineFlags			= 0;
	m_iHeldenianAresdenDead			= 0;
	m_iHeldenianElvineDead			= 0;
	m_iHeldenianAresdenKill			= 0;
	m_iHeldenianElvineKill			= 0;

	ZeroMemory(m_cGateServerStockMsg, sizeof(m_cGateServerStockMsg));
	cp = (char *)m_cGateServerStockMsg;
	dwp = (DWORD *)cp;
	*dwp = MSGID_SERVERSTOCKMSG;
	cp += 4;
	wp = (WORD *)cp;
	*wp = MSGTYPE_CONFIRM;
	cp += 2;

	m_iIndexGSS = 6;
	m_dwCrusadeGUID = NULL;
	m_iCrusadeWinnerSide = NULL;
	m_schedulesCnt = 0;
	m_iFinalShutdownCount = 0;

	return TRUE;
}

void CGame::OnClientRead(int iClientH)
{
	char  * pData, cKey;
	DWORD  dwMsgSize;

	if (m_pClientList[iClientH] == NULL) return;

	pData = m_pClientList[iClientH]->m_pXSock->pGetRcvDataPointer(&dwMsgSize, &cKey); 

	if (bPutMsgQuene(MSGFROM_CLIENT, pData, dwMsgSize, iClientH, cKey) == FALSE) {
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}
}


void CGame::DisplayInfo(HDC hdc)
{
	char cTxt[80];
	int  i, iLine;
	//GOBACK
	SelectObject(hdc, GetStockObject(ANSI_VAR_FONT));
	SetTextColor(hdc, clBlack);
	wsprintf(cTxt, "Server-Name: %s", m_cServerName);
	TextOut(hdc, 610, 5, cTxt, strlen(cTxt));
	ZeroMemory(cTxt, sizeof(cTxt));
	wsprintf(cTxt, "Max.Level: %d", m_sMaxPlayerLevel);
	TextOut(hdc, 610, 19, cTxt, strlen(cTxt));
	ZeroMemory(cTxt, sizeof(cTxt));
	wsprintf(cTxt, "P: %d/%d - %d/%d + %d", m_iTotalClients, m_iMaxClients, m_iTotalGameServerClients, m_iTotalGameServerMaxClients, m_onlineCntAdd);
	TextOut(hdc, 610, 33, cTxt, strlen(cTxt));
	ZeroMemory(cTxt, sizeof(cTxt));
	wsprintf(cTxt, "Crusade: %d:%d", m_dwCrusadeGUID, (int)m_bIsCrusadeMode);
	TextOut(hdc, 610, 47, cTxt, strlen(cTxt));
	if(m_astoria.get())
	{
		wsprintf(cTxt, "Astoria: %s", eventName[m_astoria->GetEventType()]);
		TextOut(hdc, 610, 61, cTxt, strlen(cTxt));
	}
	ZeroMemory(cTxt, sizeof(cTxt));
	wsprintf(cTxt, "Heldenian: %d:%d", m_dwHeldenianGUID, (int)m_iHeldenianType);
	TextOut(hdc, 610, 75, cTxt, strlen(cTxt));
	ZeroMemory(cTxt, sizeof(cTxt));
	wsprintf(cTxt, "SLSock: %d:%d", m_iSubLogSockActiveCount, m_iSubLogSockFailCount);
	TextOut(hdc, 610, 90, cTxt, strlen(cTxt));
	ZeroMemory(cTxt, sizeof(cTxt));
	wsprintf(cTxt, "Auto-reboot count: %d", m_iAutoRebootingCount);
	TextOut(hdc, 610, 105, cTxt, strlen(cTxt));
	TextOut(hdc, 602, 111, "________________________________", 32);
	TextOut(hdc, 615, 125, "[MAP]         [OBJECTS]", 23);

	iLine = 0;
	for (i = 0; i < MAXMAPS; i++)
		if (m_pMapList[i] != NULL) {

			ZeroMemory(g_cTxt, sizeof(g_cTxt));
			wsprintf(g_cTxt, "- %s           [%d]", m_pMapList[i]->m_cName, m_pMapList[i]->m_iTotalActiveObject);
			TextOut(hdc, 610, 164 + iLine*14, g_cTxt, strlen(g_cTxt));
			iLine++;
		}
}


void CGame::ClientMotionHandler(int iClientH, char * pData)
{
	DWORD * dwp, dwClientTime; 
	WORD * wp, wCommand, wTargetObjectID;
	short * sp, sX, sY, dX, dY, wType, magicType;
	char  * cp, cDir;
	int   iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsObserverMode) return;

	wp = (WORD *)(pData + INDEX2_MSGTYPE);
	wCommand = *wp;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	cDir = *cp;
	cp++;

	dwp = (DWORD *)cp;
	dwClientTime = *dwp;
	cp += 4;

	if (wCommand == OBJECTMAGIC) {
		sp = (short *)cp;
		magicType = *sp;
		cp += 2;
	} else if (wCommand == OBJECTATTACK || wCommand == OBJECTATTACKMOVE){
		sp = (short *)cp;
		dX = *sp;
		cp += 2;

		sp = (short *)cp;
		dY = *sp;
		cp += 2;

		sp = (short *)cp;
		wType = *sp;
		cp += 2;

		wp = (WORD *)cp;
		wTargetObjectID = *wp;
		cp += 2;
	}
	
	switch (wCommand) {
	case OBJECTSTOP:
		iRet = iClientMotion_Stop_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			SendEventToNearClient_TypeA((short) iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTSTOP, NULL, NULL, NULL);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	case OBJECTRUN:
	case OBJECTMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, (wCommand == OBJECTRUN));
		if (iRet == 1) {
			m_pClientList[iClientH]->m_rejectedMoves = 0;
			SendEventToNearClient_TypeA((short)iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, wCommand, NULL, NULL, NULL);
		}		
		else if (iRet == 2) {
			m_pClientList[iClientH]->m_rejectedMoves++;
			if(m_pClientList[iClientH]->m_rejectedMoves >= 5){
				m_pClientList[iClientH]->m_rejectedMoves = 0;
				SendObjectMotionRejectMsg(iClientH);
			}
		}

		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) m_pClientList[iClientH]->KilledHandler(NULL, NULL, 1); 

		bCheckClientMoveFrequency(iClientH, dwClientTime);
		break;

	case OBJECTDAMAGEMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, FALSE);
		if (iRet == 1) {
			SendEventToNearClient_TypeA((short)iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTDAMAGEMOVE, (short)m_pClientList[iClientH]->m_iLastDamage, NULL, NULL);
		} 
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) m_pClientList[iClientH]->KilledHandler(NULL, NULL, 1); 
		break;

	case OBJECTATTACKMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, FALSE);
		if ((iRet == 1) && (m_pClientList[iClientH] != NULL)) {
			SendEventToNearClient_TypeA((short)iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTATTACKMOVE, NULL, NULL, NULL);

			wType = 1;
			iClientMotion_Attack_Handler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, wType, cDir, wTargetObjectID, FALSE, TRUE); 
		}
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) m_pClientList[iClientH]->KilledHandler(NULL, NULL, 1); 

		bCheckClientAttackFrequency(iClientH, dwClientTime);
		break;

	case OBJECTATTACK:
		_CheckAttackType(iClientH, &wType);
		iRet = iClientMotion_Attack_Handler(iClientH, sX, sY, dX, dY, wType, cDir, wTargetObjectID); 
		if (iRet == 1) {
			if (wType >= 20) {
				m_pClientList[iClientH]->m_iSuperAttackLeft--;

				if (m_pClientList[iClientH]->m_iSuperAttackLeft < 0) m_pClientList[iClientH]->m_iSuperAttackLeft = 0;
			}

			SendEventToNearClient_TypeA((short)iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTATTACK, dX, dY, wType);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);

		bCheckClientAttackFrequency(iClientH, dwClientTime);
		break;

	case OBJECTGETITEM:
		iRet = iClientMotion_GetItem_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			SendEventToNearClient_TypeA((short)iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTGETITEM, NULL, NULL, NULL);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	case OBJECTMAGIC:
		iRet = iClientMotion_Magic_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			SendEventToNearClient_TypeA((short)iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTMAGIC, magicType,(short) 10, NULL);
			m_pClientList[iClientH]->m_hasPrecasted = true;
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	default:
		break;
	}
}

int CGame::iClientMotion_Move_Handler(int iClientH, short sX, short sY, char cDir, bool bIsRun)
{
	char  * cp, cData[3000];
	class CTile * pTile;
	DWORD * dwp, dwTime;
	WORD  * wp, wObjectID;
	short * sp, dX, dY, sDOtype;
	int   * ip, iRet, iSize, i, iTemp, iDamage;
	bool  bRet;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;


	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	dwTime = timeGetTime();
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;

#ifndef NO_MSGSPEEDCHECK
	if (bIsRun == FALSE) {
		m_pClientList[iClientH]->m_iMoveMsgRecvCount++;

		if (m_pClientList[iClientH]->m_iMoveMsgRecvCount >= 7) {
			if (m_pClientList[iClientH]->m_dwMoveLAT != 0) {

				if ((dwTime - m_pClientList[iClientH]->m_dwMoveLAT) < (72*8*7 -3000)) {
					DeleteClient(iClientH, TRUE, TRUE);
					return 0;
				}
			}
			m_pClientList[iClientH]->m_dwMoveLAT = dwTime;
			m_pClientList[iClientH]->m_iMoveMsgRecvCount = 0;
		}
	}
	else {
		m_pClientList[iClientH]->m_iRunMsgRecvCount++;

		if (m_pClientList[iClientH]->m_iRunMsgRecvCount >= 7) {
			if (m_pClientList[iClientH]->m_dwRunLAT != 0) {

				if ((dwTime - m_pClientList[iClientH]->m_dwRunLAT) < (43*8*7 -1500)) {
					DeleteClient(iClientH, TRUE, TRUE);
					return 0;
				}
			}
			m_pClientList[iClientH]->m_dwRunLAT	= dwTime;
			m_pClientList[iClientH]->m_iRunMsgRecvCount = 0;
		}
	}
#endif


	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->IncPlayerActivity(m_pClientList[iClientH]);
	}

	ClearSkillUsingStatus(iClientH);

	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;

	switch (cDir) {
	case 1:	dY--; break;
	case 2:	dX++; dY--;	break;
	case 3:	dX++; break;
	case 4:	dX++; dY++;	break;
	case 5:	dY++; break;
	case 6:	dX--; dY++;	break;
	case 7:	dX--; break;
	case 8:	dX--; dY--;	break;
	}

	class CItem * pTopItem = NULL; // 2.172

	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(dX, dY, &sDOtype, pTopItem); 

	if (m_pClientList[iClientH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0)
		bRet = FALSE;

	if (bRet == TRUE) {

		if (m_pClientList[iClientH]->m_iQuest != NULL) _bCheckIsQuestCompleted(iClientH);

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(/*1,*/ iClientH, OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);

		m_pClientList[iClientH]->m_sX   = dX;
		m_pClientList[iClientH]->m_sY   = dY;
		m_pClientList[iClientH]->m_cDir = cDir;

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner((short)iClientH,
			OWNERTYPE_PLAYER,
			dX, dY);

		if(m_pClientList[iClientH]->m_iPartyID != NULL){
			m_pClientList[iClientH]->m_partyCoordSteps++;
			if(m_pClientList[iClientH]->m_partyCoordSteps >= 4){
				m_pClientList[iClientH]->m_partyCoordSteps = 0;
				iTemp = m_pClientList[iClientH]->m_iPartyID;
				for (i = 0; i < MAXPARTYMEMBERS; i++)
					if(m_stPartyInfo[iTemp].iIndex[i] != 0 && m_stPartyInfo[iTemp].iIndex[i] != iClientH
						&& m_pClientList[m_stPartyInfo[iTemp].iIndex[i]]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)
						SendNotifyMsg(iClientH, m_stPartyInfo[iTemp].iIndex[i], NOTIFY_PARTY_COORDS, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, NULL, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iHP, m_pClientList[iClientH]->m_iMP, m_pClientList[iClientH]->GetMaxHP(), m_pClientList[iClientH]->GetMaxMP());
			}
		}

		if (m_astoria.get() && m_astoria->GetRelicHolder() == m_pClientList[iClientH]) {
			m_astoria->m_relicHolderSteps++;
			if (m_astoria->m_relicHolderSteps > 4){
				m_astoria->m_relicHolderSteps = 0;
				UpdateRelicPos();
			}
		}

		if (sDOtype == DYNAMICOBJECT_SPIKE) {
			if ((m_pClientList[iClientH]->m_bIsNeutral == TRUE) && ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) == 0)) {

			}
			else {
				iDamage = dice(2,4);

				if (!m_pClientList[iClientH]->IsInvincible()){
					m_pClientList[iClientH]->m_iHP -= iDamage;
					m_pClientList[iClientH]->m_lastDamageTime = dwTime;
				}
			}
		}

		/*

		short sRemainItemSprite, sRemainItemSpriteFrame;
		char cRemainItemColor;

		switch (pTopItem->m_sIDnum) {
		case 540: 
		if (m_pClientList[iClientH]->m_side == 2) {

		if ((m_pClientList[iClientH]->m_sItemEquipmentStatus[EQUIPPOS_LEGGINGS] != -1) && 
		(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_sItemEquipmentStatus[EQUIPPOS_LEGGINGS]] != NULL) && 
		(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_sItemEquipmentStatus[EQUIPPOS_LEGGINGS]]->m_sItemEffectType == ITEMEFFECTTYPE_DEFENSE_ANTIMINE)) {

		}
		else {


		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
		m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, (61+100), m_pClientList[iClientH]->m_sType);
		}


		pTopItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);

		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
		m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
		sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor);
		delete pTopItem;
		}
		break;
		case 541: 			if (m_pClientList[iClientH]->m_side == 1) {

		if ((m_pClientList[iClientH]->m_sItemEquipmentStatus[EQUIPPOS_LEGGINGS] != -1) && 
		(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_sItemEquipmentStatus[EQUIPPOS_LEGGINGS]] != NULL) && 
		(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_sItemEquipmentStatus[EQUIPPOS_LEGGINGS]]->m_sItemEffectType == ITEMEFFECTTYPE_DEFENSE_ANTIMINE)) {

		}
		else {


		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
		m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, (61+100), m_pClientList[iClientH]->m_sType);
		}


		pTopItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);

		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
		m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
		sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor);
		delete pTopItem;
		}
		break;
		}
		//
		*/

		if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 0;

		dwp  = (DWORD *)(cData + INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + INDEX2_MSGTYPE);
		*wp  = OBJECTMOVE_CONFIRM;

		cp = (char *)(cData + INDEX2_MSGTYPE+2);

		sp  = (short *)cp;
		*sp = (short)(dX - 10); 
		cp += 2;

		sp  = (short *)cp;
		*sp = (short)(dY - 7); 
		cp += 2;

		*cp = cDir;
		cp++;

		if (bIsRun == TRUE) {
			if (m_pClientList[iClientH]->m_iSP > 0) {
				*cp = 0; // 1
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStamina == 0) {
					m_pClientList[iClientH]->m_iSP--;
					*cp = 1;
				}
			}
			else {
				*cp = 0; // 1
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStamina == 0) {
					m_pClientList[iClientH]->m_iSP--;
					*cp = 1;
				}
				if (m_pClientList[iClientH]->m_iSP < -10) {


					m_pClientList[iClientH]->m_iSP = 0;
					DeleteClient(iClientH, TRUE, TRUE);
					return 0;
				}
			}
		}
		else *cp = 0;
		cp++;

		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iHP;
		cp += 4;

		iSize = iComposeMoveMapData((short)(dX - 10), (short)(dY - 7), iClientH, cDir, cp);

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, iSize + 12 + 4);
		switch (iRet) {
		case XSOCKEVENT_QUENEFULL:
		case XSOCKEVENT_SOCKETERROR:
		case XSOCKEVENT_CRITICALERROR:
		case XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
	}
	else {
		m_pClientList[iClientH]->m_bIsMoveBlocked = TRUE; 
		dwp  = (DWORD *)(cData + INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + INDEX2_MSGTYPE);
		*wp  = OBJECTMOVE_REJECT;

		wObjectID = (WORD) iClientH;

		cp = (char *)(cData + INDEX2_MSGTYPE + 2);

		wp  = (WORD *)cp;
		*wp = wObjectID;			// ObjectID
		cp += 2;
		sp  = (short *)cp;
		sX  = m_pClientList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;
		sp  = (short *)cp;
		sY  = m_pClientList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sType;
		cp += 2;
		*cp = m_pClientList[wObjectID]->m_cDir;
		cp++;
		memcpy(cp, m_pClientList[wObjectID]->m_cCharName, 10);
		cp += 10;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr1;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr2;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr3;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr4;
		cp += 2;
		ip  = (int *)cp; 
		*ip = m_pClientList[wObjectID]->m_iApprColor;
		cp+= 4;

		ip  = (int *)cp;

		*ip = m_pClientList[wObjectID]->m_iStatus;
		cp += 4;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 42); 

		switch (iRet) {
		case XSOCKEVENT_QUENEFULL:
		case XSOCKEVENT_SOCKETERROR:
		case XSOCKEVENT_CRITICALERROR:
		case XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
	
		Unit * owner = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(dX, dY);
		if(owner){
			if(owner->IsPlayer())
				RequestFullObjectData(iClientH, NULL, owner->m_handle);
			else
				RequestFullObjectData(iClientH, NULL, owner->m_handle+10000);
		}

		return 0;
	}

	return 1;
}


void CGame::RequestInitPlayerHandler(int iClientH, char * pData, char cKey)
{
	register int i;
	char * cp, cCharName[11], cAccountName[11], cAccountPassword[11], cTxt[120];
	bool bIsObserverMode;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) return;


	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));

	ZeroMemory(m_pClientList[iClientH]->m_cCharName, sizeof(m_pClientList[iClientH]->m_cCharName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountName, sizeof(m_pClientList[iClientH]->m_cAccountName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountPassword, sizeof(m_pClientList[iClientH]->m_cAccountPassword));

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	ZeroMemory(cTxt, sizeof(cTxt)); 
	memcpy(cTxt, cCharName, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cCharName, sizeof(cCharName));
	memcpy(cCharName, cTxt, 10);

	//testcode
	if (strlen(cTxt) == 0) PutLogList("RIPH - cTxt: Char NULL!");

	memcpy(cAccountName, cp, 10);
	cp += 10;

	ZeroMemory(cTxt, sizeof(cTxt)); 
	memcpy(cTxt, cAccountName, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cAccountName, sizeof(cAccountName));
	memcpy(cAccountName, cTxt, 10);

	memcpy(cAccountPassword, cp, 10);
	cp += 10;

	ZeroMemory(cTxt, sizeof(cTxt)); 
	memcpy(cTxt, cAccountPassword, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	memcpy(cAccountPassword, cTxt, 10);

	bIsObserverMode = (*cp) ? TRUE : FALSE;
	cp++;


	for (i = 1; i < MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cAccountName, cAccountName, 10) == 0)) {

			if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) {

				wsprintf(g_cTxt, "<%d> Duplicate account player! Deleted with data save : CharName(%s) AccntName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cIPaddress);
				PutLogList(g_cTxt);
				//PutLogFileList(g_cTxt);
				DeleteClient(i, TRUE, TRUE, FALSE);
			}
			else {

				memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
				memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
				memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);


				DeleteClient(iClientH, FALSE, FALSE, FALSE);
				return;
			}
		}


	for (i = 1; i < MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {

			if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) {
				wsprintf(g_cTxt, "<%d> Duplicate player! Deleted with data save : CharName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cIPaddress);
				PutLogList(g_cTxt);
				//PutLogFileList(g_cTxt);
				DeleteClient(i, TRUE, TRUE, FALSE);
			}
			else {

				memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
				memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
				memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);


				DeleteClient(iClientH, FALSE, FALSE);
				return;
			}
		}


	memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);

	m_pClientList[iClientH]->m_bIsObserverMode = bIsObserverMode;


	bSendMsgToLS(MSGID_REQUEST_PLAYERDATA, iClientH);
}

void CGame::PlayerMapEntry(int iClientH, bool setRecallTime)
{
	short * sp;
	DWORD * dwp;
	WORD  * wp;
	char  * cp, cQuestRemain;
	int   * ip, iMapSide, iTmpMapSide, iSize, iRet, i;
	SYSTEMTIME SysTime;

	CClient * player = m_pClientList[iClientH];

	if (player == NULL) return;

	iSetSide(iClientH);
	char * pBuffer = new char [MSGBUFFERSIZE+1];
	ZeroMemory(pBuffer, MSGBUFFERSIZE+1);

	dwp  = (DWORD *)(pBuffer + INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITDATA;
	wp   = (WORD *)(pBuffer + INDEX2_MSGTYPE);
	*wp  = MSGTYPE_CONFIRM;

	cp = (char *)(pBuffer + INDEX2_MSGTYPE + 2);

	if (player->m_bIsObserverMode == FALSE)
		bGetEmptyPosition(&player->m_sX, &player->m_sY, player->m_cMapIndex);
	else GetMapInitialPoint(player->m_cMapIndex, &player->m_sX, &player->m_sY);

	// ObjectID
	wp  = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	sp  = (short *)cp;
	*sp = player->m_sX - 14 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = player->m_sY - 12 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = player->m_sType;
	cp += 2;

	sp  = (short *)cp;
	*sp = player->m_sAppr1;
	cp += 2;

	sp  = (short *)cp;
	*sp = player->m_sAppr2;
	cp += 2;

	sp  = (short *)cp;
	*sp = player->m_sAppr3;
	cp += 2;

	sp  = (short *)cp;
	*sp = player->m_sAppr4;
	cp += 2;

	ip  = (int *)cp; 
	*ip = player->m_iApprColor;
	cp += 4;

	if(m_pClientList[iClientH]->m_iPKCount > 0)
		m_pClientList[iClientH]->SetStatusFlag(STATUS_PK, TRUE);

	ip  = (int *)cp;
	*ip = player->m_iStatus;
	cp += 4;

	memcpy(cp, player->m_cMapName, 10);
	cp += 10;

	memcpy(cp, m_pMapList[player->m_cMapIndex]->m_cLocationName, 10);
	cp += 10;

	if (m_pMapList[player->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		*cp = 1;
	else *cp = m_cDayOrNight;
	cp++;

	if (m_pMapList[player->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		*cp = NULL;
	else *cp = m_pMapList[player->m_cMapIndex]->m_cWhetherStatus;
	cp++;

	ip = (int *)cp;
	*ip = player->m_iContribution;
	cp += 4;

	if (player->m_bIsObserverMode == FALSE) {
		m_pMapList[player->m_cMapIndex]->SetOwner((short)iClientH, 
			OWNERTYPE_PLAYER, 
			player->m_sX, 
			player->m_sY);
	}

	*cp = (char)player->m_bIsObserverMode;
	cp++;

	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_reputation;
	cp += 4;

	ip = (int *)cp;
	*ip = player->m_iHP;
	cp += 4;

	if(player->m_bIsOnShop &&	m_iCrusadeWinnerSide == player->m_side) //Shop price adjustment
		*cp = -10;
	else
		*cp = 0;

	cp++;

	iSize = iComposeInitMapData(player->m_sX - 10, player->m_sY - 7, iClientH, cp );

	iRet = player->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 +1 +4 +4+3); 
	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete[] pBuffer;
		return;
	}

	if(pBuffer != NULL) delete[] pBuffer;

	if(m_astoria.get() && strcmp(player->m_cMapName, "astoria") == 0)
	{
		const Casualties * stats = m_astoria->GetStats();
		SendNotifyMsg(NULL, player->m_handle, NOTIFY_CASUALTIES, 
			stats[ARESDEN].deaths, stats[ELVINE].deaths, stats[ISTRIA].deaths, NULL, 
			stats[ARESDEN].kills, stats[ELVINE].kills, stats[ISTRIA].kills);

		UpdateRelicPos(iClientH);
	}

	if (m_bHeldenianMode)
		UpdateHeldenianStatus();

	SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_LOG, MSGTYPE_CONFIRM, NULL, NULL, NULL);

	if(setRecallTime)
	{
		iSetSide(iClientH);
		player->m_bIsWarLocation = FALSE;
		player->m_iTimeLeft_ForceRecall = 0;

		if(player->IsNeutral())
		{
			if(m_bIsCrusadeMode && !player->IsGM() && 
				((strcmp(m_pMapList[player->m_cMapIndex]->m_cName, sideMap[ARESDEN]) == 0) || 
				 (strcmp(m_pMapList[player->m_cMapIndex]->m_cName, sideMap[ELVINE]) == 0) 	|| 
				 (strcmp(m_pMapList[player->m_cMapIndex]->m_cName, sideMap[ISTRIA]) == 0)))
			{
				player->m_dwWarBeginTime = timeGetTime();
				player->m_bIsWarLocation = TRUE;
				player->m_iTimeLeft_ForceRecall = 1; 
			}
		}
		else if (player->IsInFoeMap() && !player->IsGM()) 
		{
			player->m_dwWarBeginTime = timeGetTime();
			player->m_bIsWarLocation = TRUE;

			SetForceRecallTime(iClientH) ;
		}

		if (player->m_iTimeLeft_ForceRecall > 0) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_FORCERECALLTIME, player->m_iTimeLeft_ForceRecall, NULL, NULL, NULL);
		}
	}

	iMapSide = iGetMapLocationSide(m_pMapList[player->m_cMapIndex]->m_cName);

	if (iMapSide >= 11) iTmpMapSide = iMapSide - 10 ;
	else iTmpMapSide = iMapSide ;

	player->m_bIsInBuilding = FALSE ;

	if ((player->m_side != iTmpMapSide) && (iMapSide != 0) ) {
		if ( (iMapSide <= 10) && !player->IsGM() && !player->IsNeutral() )
		{
			player->m_dwWarBeginTime = timeGetTime();
			player->m_bIsWarLocation = TRUE;
			player->m_iTimeLeft_ForceRecall = 1 ; 
			player->m_bIsInBuilding = TRUE ;
		}
	}
#ifndef GUILDWARMODE
	else if ((m_pMapList[player->m_cMapIndex]->m_bIsFightZone == TRUE) &&
		(m_iFightzoneNoForceRecall == 0) && !player->IsGM()) {

			player->m_dwWarBeginTime = timeGetTime();
			player->m_bIsWarLocation = TRUE;

		GetLocalTime(&SysTime);
			player->m_iTimeLeft_ForceRecall = 2*20*60 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 2*20;  
	}
#endif 
	else if (player->IsInJail() && !player->IsGM()) {
		player->m_bIsWarLocation = TRUE;
		player->m_dwWarBeginTime = timeGetTime();

		if (player->m_iTimeLeft_ForceRecall == 0) {
			player->m_iTimeLeft_ForceRecall = 20*5 ; 
		} else if (player->m_iTimeLeft_ForceRecall > 20*5) {
			player->m_iTimeLeft_ForceRecall = 20*5 ;
		}
	}

	_CheckQuestEnvironment(iClientH);

	if (m_astoria.get() && player->m_cMapIndex == m_iAstoriaMapIndex) {
		UpdateRelicPos(iClientH);
	}

	if (player->m_iSpecialAbilityTime == 0) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);
	}

	if (m_bHeldenianMode)
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_HELDENIANSTART,  NULL , NULL, NULL, NULL);
		SendNotifyMsg(NULL, iClientH, NOTIFY_HELDENIANTELEPORT,  NULL , NULL, NULL, NULL);
	}

	if (m_bIsCrusadeMode == TRUE) {
		if (player->m_dwCrusadeGUID == 0) {
			player->m_iCrusadeDuty = 0;
			player->m_iConstructionPoint = 0;
			player->m_dwCrusadeGUID = m_dwCrusadeGUID;
		}
		else if (player->m_dwCrusadeGUID != m_dwCrusadeGUID) {
			player->m_iCrusadeDuty       = 0;
			player->m_iConstructionPoint = 0;
			player->m_iWarContribution   = 0;
			player->m_dwCrusadeGUID = m_dwCrusadeGUID;
			SendNotifyMsg(NULL, iClientH, NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);
		}
		SendNotifyMsg(NULL, iClientH, NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, player->m_iCrusadeDuty, NULL, NULL);
	}
	else {
		if (player->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			player->m_iCrusadeDuty = 0;
			player->m_iConstructionPoint = 0;
		}
		else if ((player->m_dwCrusadeGUID != NULL) && (player->m_dwCrusadeGUID != m_dwCrusadeGUID)) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);
			player->m_iWarContribution   = 0;
			player->m_dwCrusadeGUID = 0;
		}
	}

	if (m_pMapList[player->m_cMapIndex]->m_bIsFightZone) { //Send all map restrictions
		if (m_pMapList[player->m_cMapIndex]->m_isPartyDisabled && !player->IsGM()) RequestDismissPartyHandler(iClientH);
		if (m_pMapList[player->m_cMapIndex]->m_isShieldDisabled)
			SendNotifyMsg(NULL, iClientH, NOTIFY_EVENTSHIELD, true, NULL, NULL, NULL, NULL);
		if (m_pMapList[player->m_cMapIndex]->m_isArmorDisabled){
			if (!m_pClientList[iClientH]->IsGM() && !m_pClientList[iClientH]->IsDead()){
				if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_HEAD ] != -1){
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, EQUIPPOS_HEAD, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_HEAD ], NULL, NULL);
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_HEAD ], FALSE);
				}
				if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_BODY ] != -1) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, EQUIPPOS_BODY, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_BODY ], NULL, NULL);
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_BODY ], FALSE);
				}
				if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_ARMS ] != -1) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, EQUIPPOS_ARMS, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_ARMS ], NULL, NULL);
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_ARMS ], FALSE);
				}
				if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_LEGGINGS ] != -1) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, EQUIPPOS_LEGGINGS, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_LEGGINGS ], NULL, NULL);
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_LEGGINGS ], FALSE);
				}
				if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_PANTS ] != -1) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, EQUIPPOS_PANTS, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_PANTS ], NULL, NULL);
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_PANTS ], FALSE);
				}
				SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTNULLACTION, NULL, NULL, NULL);
			}

			SendNotifyMsg(NULL, iClientH, NOTIFY_EVENTARMOR, true, NULL, NULL, NULL, NULL);
		}
		if (m_pMapList[player->m_cMapIndex]->m_isPermIllusionOn){
			if (!player->IsGM()){
				for (i = 1; i < MAXCLIENTS; i++)
					if(m_pClientList[i] != NULL && m_pClientList[i]->IsGM() && m_pClientList[i]->m_cMapIndex == player->m_cMapIndex) break;

				if (i != MAXCLIENTS){
					SendNotifyMsg(NULL, iClientH, NOTIFY_MAGICEFFECTON, MAGICTYPE_CONFUSE, 3, i, NULL);
					player->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ] = 3;
					player->SetStatusFlag(STATUS_ILLUSION, TRUE);
				}
			}
			SendNotifyMsg(NULL, iClientH, NOTIFY_EVENTILLUSION, TRUE, NULL, NULL, NULL, NULL);
		}

		if (m_pMapList[player->m_cMapIndex]->m_isChatDisabled)
			SendNotifyMsg(NULL, iClientH, NOTIFY_EVENTCHAT, m_pMapList[player->m_cMapIndex]->m_isChatDisabled, NULL, NULL, NULL, NULL);

		for (i = 0; i < MAXMAGICTYPE; i++)
			if (m_pMapList[player->m_cMapIndex]->m_magicLimited[i])
				SendNotifyMsg(NULL, iClientH, NOTIFY_EVENTSPELL, true, i, NULL, NULL, NULL);

		wsprintf(g_cTxt, "Char(%s)-Enter(%s) Observer(%d)", player->m_cCharName, player->m_cMapName, player->m_bIsObserverMode);
			PutLogFileList(g_cTxt, EVENT_LOGFILE);
	}

	if (player->m_iPartyID != NULL){
		for (i = 0; i < MAXPARTYMEMBERS; i++){
			int partyMember = m_stPartyInfo[player->m_iPartyID].iIndex[i];
			if (partyMember != 0 && partyMember != iClientH){
				if (m_pClientList[partyMember]->m_cMapIndex == player->m_cMapIndex){
					SendNotifyMsg(partyMember, iClientH, NOTIFY_PARTY_COORDS, m_pClientList[partyMember]->m_sX, m_pClientList[partyMember]->m_sY, NULL, m_pClientList[partyMember]->m_cCharName, m_pClientList[partyMember]->m_iHP, m_pClientList[partyMember]->m_iMP, m_pClientList[partyMember]->GetMaxHP(), m_pClientList[partyMember]->GetMaxMP());
					SendNotifyMsg(iClientH, partyMember, NOTIFY_PARTY_COORDS, player->m_sX, player->m_sY, NULL, player->m_cCharName, player->m_iHP, player->m_iMP, player->GetMaxHP(), player->GetMaxMP());
				}else{
					SendNotifyMsg(iClientH, partyMember, NOTIFY_PARTY_COORDS, 0, 0, NULL, player->m_cCharName, player->m_iHP, player->m_iMP, player->GetMaxHP(), player->GetMaxMP());
				}
			} 
		}
	}

	SendNotifyMsg(NULL, iClientH, NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
	SendNotifyMsg(NULL, iClientH, NOTIFY_DOWNSKILLINDEXSET, player->m_iDownSkillIndex, NULL, NULL, NULL);
	SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMPOSLIST, NULL, NULL, NULL, NULL);

	SendNotifyMsg(NULL, iClientH, NOTIFY_CONSTRUCTIONPOINT, player->m_iConstructionPoint, player->m_iWarContribution, 1, NULL);
	SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, player->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);

	player->m_nextRecallPoint = 0;
	if (player->m_iQuest) {
		cQuestRemain = (m_pQuestConfigList[player->m_iQuest]->m_iMaxCount - player->m_iCurQuestCount);
		SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTCOUNTER, cQuestRemain, NULL, NULL, NULL);
		_bCheckIsQuestCompleted(iClientH);
	}
}

int CGame::iComposeInitMapData(short sX, short sY, int iClientH, char * pData)
{
	int ix, iy, iSize, iTileExists;
	CTile * pTileSrc;

	if (m_pClientList[iClientH] == NULL) return 0;

	short total = 0;

	iSize = 2;
	iTileExists = 0;
	pTileSrc = (CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + 
		(sX) + (sY)*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

	for (iy = 0; iy < 16; iy++)
	{
		for (ix = 0; ix < 21; ix++) 
		{
			if(WriteTileData(pData + iSize, iSize, iClientH, pTileSrc, ix, iy))
				total++;
		}
	}
	*((short *)pData) = total;
	return iSize;
}

void CGame::DeleteClient(int iClientH, bool bSave, bool bNotify, bool bCountLogout, bool bForceCloseConn)
{
	int i, iExH;
	char * cp, cData[120], cTmpMap[30];
	DWORD * dwp;
	WORD * wp;		 
	DWORD dwTime = timeGetTime();
	bool previouslyDCd = FALSE;

	CClient * player = m_pClientList[iClientH];

	if (!player) return;

	if (player->m_bIsInitComplete == TRUE) {
		if (memcmp(player->m_cMapName, "fight", 5) == 0) {
			wsprintf(g_cTxt, "Char(%s)-Exit(%s)", player->m_cCharName, player->m_cMapName);
			PutLogFileList(g_cTxt,EVENT_LOGFILE);
		}

		if (player->m_isExchangeMode == TRUE) {
			iExH = player->m_exchangeH;
			_ClearExchangeStatus(iExH);
			_ClearExchangeStatus(iClientH);
		}


		if ((player->m_iAllocatedFish != NULL) && (m_pFish[player->m_iAllocatedFish] != NULL)) 
			m_pFish[player->m_iAllocatedFish]->m_sEngagingCount--;

		if (bNotify == TRUE)
			SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_LOG, MSGTYPE_REJECT, NULL, NULL, NULL);

		RemoveFromTarget(iClientH, OWNERTYPE_PLAYER);


		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iWhisperPlayerIndex	== iClientH)) {
				m_pClientList[i]->m_iWhisperPlayerIndex = -1;
				SendNotifyMsg(NULL, i, NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, player->m_cCharName);
			}

			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			*cp = GSM_DISCONNECT;
			cp++;
			memcpy(cp, player->m_cCharName, 10);
			cp += 10;
			bStockMsgToGateServer(cData, 11);
			SendStockMsgToGateServer();

			m_pMapList[player->m_cMapIndex]->ClearOwner(/*2,*/ iClientH, OWNERTYPE_PLAYER,
				player->m_sX, 
				player->m_sY);


			RemoveFromDelayEventList(iClientH, OWNERTYPE_PLAYER, NULL);
	}

	int index = player->HasItem(ITEM_RELIC);
	if(index != ITEM_NONE)
	{
		DropItemHandler(player->m_handle, index, 1, player->m_pItemList[index]->m_cName, FALSE);
	}

	if(bSave && !player->m_bIsOnServerChange) {
		if(player->m_bIsKilled) {
			player->m_sX = -1;
			player->m_sY = -1;

			strcpy(cTmpMap,player->m_cMapName) ;

			ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));

			if (player->IsNeutral()) {
				strcpy(player->m_cMapName, sideMap[NEUTRAL]);
			}
			else {
				if (m_bIsCrusadeMode) {
					if (player->m_iDeadPenaltyTime > 0) {
						ZeroMemory(player->m_cLockedMapName, sizeof(player->m_cLockedMapName));
						strcpy(player->m_cLockedMapName, sideMap[ player->m_side ] );
						player->m_iLockedMapTime = 60*5;
						player->m_iDeadPenaltyTime = 60*10; 
					}
					else {
						player->m_iDeadPenaltyTime = 60*10; 
					}
				}

				switch(player->m_side)
				{
				case ARESDEN:
					if (strcmp(cTmpMap, sideMap[ELVINE]) == 0){
						strcpy(player->m_cLockedMapName, sideMapJail[ELVINE]);
						player->m_iLockedMapTime = 60*3; 
						strcpy(player->m_cMapName, sideMapJail[ELVINE]);
					}else if (strcmp(cTmpMap, sideMap[ISTRIA]) == 0){
						strcpy(player->m_cLockedMapName, sideMapJail[ISTRIA]);
						player->m_iLockedMapTime = 60*3; 
						strcpy(player->m_cMapName, sideMapJail[ISTRIA]);
					}else if (player->m_iLevel > 80)
						strcpy(player->m_cMapName, sideMapRes[ARESDEN]);
					else 
						strcpy(player->m_cMapName, sideMapFarm[ARESDEN]);
					break;
				case ELVINE:
					if (strcmp(cTmpMap, sideMap[ARESDEN]) == 0){
						strcpy(player->m_cLockedMapName, sideMapJail[ARESDEN]);
						player->m_iLockedMapTime = 60*3; 
						strcpy(player->m_cMapName, sideMapJail[ARESDEN]);
					}else if (strcmp(cTmpMap, sideMap[ISTRIA]) == 0){
						strcpy(player->m_cLockedMapName, sideMapJail[ISTRIA]);
						player->m_iLockedMapTime = 60*3; 
						strcpy(player->m_cMapName, sideMapJail[ISTRIA]);
					}else if (player->m_iLevel > 80)
						strcpy(player->m_cMapName, sideMapRes[ELVINE]);
					else 
						strcpy(player->m_cMapName, sideMapFarm[ELVINE]);
					break;
				case ISTRIA:
					if (strcmp(cTmpMap, sideMap[ARESDEN]) == 0){
						strcpy(player->m_cLockedMapName, sideMapJail[ARESDEN]);
						player->m_iLockedMapTime = 60*3; 
						strcpy(player->m_cMapName, sideMapJail[ARESDEN]);
					}else if (strcmp(cTmpMap, sideMap[ELVINE]) == 0){
						strcpy(player->m_cLockedMapName, sideMapJail[ELVINE]);
						player->m_iLockedMapTime = 60*3; 
						strcpy(player->m_cMapName, sideMapJail[ELVINE]);
					}else if (player->m_iLevel > 80)
						strcpy(player->m_cMapName, sideMapRes[ISTRIA]);
					else 
						strcpy(player->m_cMapName, sideMapFarm[ISTRIA]);
					break;
				}
			}
		}
		else if(bForceCloseConn) {

			ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));
			memcpy(player->m_cMapName, "bisle", 5);
			player->m_sX = -1;
			player->m_sY = -1;


			ZeroMemory(player->m_cLockedMapName, sizeof(player->m_cLockedMapName));
			strcpy(player->m_cLockedMapName, "bisle");

			player->m_iLockedMapTime = 10*60;
		}


		if(player->m_bIsObserverMode ||
			memcmp(player->m_cMapName, "astoria", 7) == 0 ) 
		{
			ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));
			strcpy(player->m_cMapName, sideMap[ player->m_side ]);

			player->m_sX = -1;
			player->m_sY = -1;
		}

		if(player->m_cMapIndex >= 0 && m_pMapList[player->m_cMapIndex]->m_bIsFightZone &&
			!player->IsGM())
		{
			for(std::list<RecentDisconnect>::iterator it = m_recentDCs.begin(); it != m_recentDCs.end(); it++)
				if(strcmp(it->playerName, player->m_cCharName) == 0)
				{	
					if(it->dcCount >= 3){
						m_recentDCs.erase(it);

						ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));
						strcpy(player->m_cMapName, sideMap[ player->m_side ]);
						player->m_sX = -1;
						player->m_sY = -1;
					}
					else{
						it->dcCount++;
						for (i = 0; i < 3; i++)
							if (it->disconnectTimes[i] == 0){
								it->disconnectTimes[i] = timeGetTime();
								break;
							}
					}
					previouslyDCd = TRUE;
					break;
				}

			if(!previouslyDCd){
				m_recentDCs.push_back(RecentDisconnect(player->m_cCharName, timeGetTime()));
			}
		}

		if(player->m_bIsInitComplete) {
			if(player->m_iPartyID != NULL) {
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;
				dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;
				wp = (WORD*)cp;
				*wp = 4; 				
				cp += 2;
				wp = (WORD *)cp;
				*wp = iClientH;
				cp += 2;
				memcpy(cp, player->m_cCharName, 10);
				cp += 10;
				wp = (WORD *)cp;
				*wp = player->m_iPartyID;
				cp += 2;
				bSendMsgToLS(MSGID_PARTYOPERATION, iClientH, FALSE, cData);
			}
			// Gate server is suposed to ask gservers to removed this client from party, in all party members
			// Ask to save player data and local tempory save if error
			//if (
				bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout);
				//LocalSavePlayerData(iClientH);
		}else bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout); //Don't save if not InitComplete
	}else // No SAVE or not onServerChange
	{	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == FALSE) // => bSave == FALSE ....
		{	// Real LogOUT:
			// Strange case! Real logout and don't save players character !?!?!
	    	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) 
			
			if (player->m_iPartyID != NULL) {
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;
				dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;
				wp = (WORD*)cp;
				*wp = 4; 				
				cp += 2;
				wp = (WORD *)cp;
				*wp = iClientH;
				cp += 2;
				memcpy(cp, player->m_cCharName, 10);
				cp += 10;
				wp = (WORD *)cp;
				*wp = player->m_iPartyID;
				cp += 2;
				bSendMsgToLS(MSGID_PARTYOPERATION, iClientH, FALSE, cData);
			}
			//m_pClientList[iClientH]->m_cdwDecoTime = dwTime; 
			bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout);
		}else //bSave == TRUE, IsOnServerChange == TRUE
		// Not a real Logout, only changes SERVER
		{	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) 		
			if (m_pClientList[iClientH]->m_iPartyID != NULL) 
			{	
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;
				dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;
				wp = (WORD*)cp;
				*wp = 7; 				
				cp += 2;
				wp = (WORD *)cp;
				*wp = NULL; 
				cp += 2;
				memcpy(cp, player->m_cCharName, 10);
				cp += 10;
				wp = (WORD *)cp;
				*wp = player->m_iPartyID;
				cp += 2;
				bSendMsgToLS(MSGID_PARTYOPERATION, iClientH, FALSE, cData);
			}

			bSendMsgToLS(MSGID_REQUEST_SETACCOUNTWAITSTATUS, iClientH, FALSE); 
		}
	}

	if (player->m_iPartyID != NULL) {
		for (i = 0; i < MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[player->m_iPartyID].iIndex[i] == iClientH) {
				m_stPartyInfo[player->m_iPartyID].iIndex[i] = 0;
				m_stPartyInfo[player->m_iPartyID].iTotalMembers--;
				break;
			}

		for (i = 0; i < MAXPARTYMEMBERS-1; i++)
			if ((m_stPartyInfo[player->m_iPartyID].iIndex[i] == 0) && (m_stPartyInfo[player->m_iPartyID].iIndex[i+1] != 0)) {
				m_stPartyInfo[player->m_iPartyID].iIndex[i]   = m_stPartyInfo[player->m_iPartyID].iIndex[i+1];
				m_stPartyInfo[player->m_iPartyID].iIndex[i+1] = 0;
			}
	}

	// Remember erased clients
	for (i = 0; i < MAXCLIENTS; i++) 
	{	if ((m_stOldClientList[i].iClientH == 0)||((m_stOldClientList[i].m_dwDeleteTime + 60*1000) < dwTime ))
		{	m_stOldClientList[i].iClientH = iClientH;
			m_stOldClientList[i].m_dwDeleteTime = dwTime;
			ZeroMemory(m_stOldClientList[i].m_cCharName,        sizeof(m_stOldClientList[i].m_cCharName));
			ZeroMemory(m_stOldClientList[i].m_cAccountName,     sizeof(m_stOldClientList[i].m_cAccountName));
			ZeroMemory(m_stOldClientList[i].m_cAccountPassword, sizeof(m_stOldClientList[i].m_cAccountPassword));
			strcpy(m_stOldClientList[i].m_cCharName,           m_pClientList[iClientH]->m_cCharName);
			strcpy(m_stOldClientList[i].m_cAccountName,        m_pClientList[iClientH]->m_cAccountName);
			strcpy(m_stOldClientList[i].m_cAccountPassword,    m_pClientList[iClientH]->m_cAccountPassword);
			break;
	}	}

	if (player->m_bIsManager != TRUE)
		m_iTotalClients--;

	delete player;
	m_pClientList[iClientH] = NULL;

	RemoveClientShortCut(iClientH);
}


void CGame::SendEventToNearClient_TypeA(short sOwnerH, char cOwnerType, DWORD dwMsgID, WORD wMsgType, short sV1, short sV2, short sV3)
{
	int * ip, i, iRet, iShortCutIndex, iStatus, * ipStatus, iDumm, dataLength;
	char  * cp, cKey, data[200];
	DWORD * dwp;
	WORD  * wp;
	short * sp;
	bool    bOwnerSend;
	CClient * pClient;

	ZeroMemory(data, sizeof(data));
	ipStatus = (int *)&iDumm;
	cKey = (char)(rand() % 255) +1; 

	dwp = (DWORD *)(data + INDEX4_MSGID);
	*dwp = dwMsgID;
	wp	= (WORD *)(data + INDEX2_MSGTYPE);
	*wp  = wMsgType;

	cp  = (char *)(data + INDEX2_MSGTYPE + 2);

	if (cOwnerType == OWNERTYPE_PLAYER) {
		pClient = m_pClientList[sOwnerH];
		if (pClient == NULL) return;

		switch (wMsgType) {
		case OBJECTNULLACTION:
		case OBJECTDAMAGE:
		case OBJECTDYING:
			bOwnerSend = TRUE;
			break;
		default:
			bOwnerSend = FALSE;
			break;
		}

		switch (wMsgType) 
		{
		case OBJECTMAGIC:
		case OBJECTDAMAGE:
		case OBJECTDAMAGEMOVE:
		case OBJECTDYING:
			dataLength = 11;

			wp  = (WORD *)cp;
			*wp = sOwnerH + 30000;
			cp += 2;
			*cp = pClient->m_cDir;
			cp++;
			*cp = (unsigned char)sV1;
			cp++;
			*cp = (unsigned char)sV2;
			cp++;

			if(wMsgType == OBJECTDYING){
				dataLength = 15;

				sp  = (short *)cp;
				*sp = pClient->m_sX;
				cp += 2;
				sp  = (short *)cp;
				*sp = pClient->m_sY;
				cp += 2;
			}
			break;

		case OBJECTATTACK:
		case OBJECTATTACKMOVE:
			dataLength = 13;

			wp  = (WORD *)cp;
			*wp = sOwnerH + 30000;
			cp += 2;
			*cp = pClient->m_cDir;
			cp++;
			*cp = sV1 - pClient->m_sX;
			cp++;
			*cp = sV2 - pClient->m_sY;
			cp++;
			sp  = (short *)cp;
			*sp = sV3;
			cp += 2;
			break;

		case MSGTYPE_CONFIRM:
		case MSGTYPE_REJECT:
		case OBJECTNULLACTION:
		default:
			dataLength = 43;

			wp  = (WORD *)cp;
			*wp = sOwnerH;
			cp += 2;
			sp  = (short *)cp;
			*sp = pClient->m_sX;
			cp += 2;
			sp  = (short *)cp;
			*sp = pClient->m_sY;
			cp += 2;
			sp  = (short *)cp;
			*sp = pClient->m_sType;
			cp += 2;
			*cp = pClient->m_cDir;
			cp++;
			memcpy(cp, pClient->m_cCharName, 10);
			cp += 10;
			sp  = (short *)cp;
			*sp = pClient->m_sAppr1;
			cp += 2;
			sp  = (short *)cp;
			*sp = pClient->m_sAppr2;
			cp += 2;
			sp  = (short *)cp;
			*sp = pClient->m_sAppr3;
			cp += 2;
			sp  = (short *)cp;
			*sp = pClient->m_sAppr4;
			cp += 2;
			ip = (int *)cp;
			*ip = pClient->m_iApprColor;
			cp += 4;

			ip  = (int *)cp;
			ipStatus = ip;
			iStatus = *ip = pClient->m_iStatus;
			cp += 4;

			if (wMsgType != OBJECTNULLACTION || pClient->m_bIsKilled == FALSE) {
				*cp = 0; 
			}
			else *cp = 1;
			cp++;
			break;
		}

		iShortCutIndex = 0;

		CClient * ipClient;
		while(i = m_iClientShortCut[iShortCutIndex++])
		{
			if ((ipClient = m_pClientList[i]) && m_pClientList[i]->m_bIsInitComplete)
				if ((ipClient->m_cMapIndex == pClient->m_cMapIndex) &&
					(ipClient->m_sX >= pClient->m_sX - 11) &&
					(ipClient->m_sX <= pClient->m_sX + 11) &&
					(ipClient->m_sY >= pClient->m_sY - 9) &&
					(ipClient->m_sY <= pClient->m_sY + 9) ) {

						if (bOwnerSend == TRUE || i != sOwnerH) {
							if(_bGetIsPlayerHostile(i,sOwnerH) && sOwnerH != i && m_pClientList[i]->m_iAdminUserLevel == 0)
								*ipStatus = iStatus & STATUS_ENEMYFLAGS;
							else
								*ipStatus = iStatus;

							iRet = ipClient->m_pXSock->iSendMsg(data, dataLength, cKey);
						}
				}
		}
	}
	else {

		CNpc * pNpc = m_pNpcList[sOwnerH];
		if (pNpc == NULL) return;

		switch (wMsgType) 
		{
		case OBJECTDAMAGE:
		case OBJECTDAMAGEMOVE:
		case OBJECTDYING:
			dataLength = 11;

			wp  = (WORD *)cp;
			*wp = sOwnerH + 40000;
			cp += 2;
			*cp = pNpc->m_cDir;
			cp++;
			*cp = (unsigned char)sV1;
			cp++;
			*cp = (unsigned char)sV2;
			cp++;

			if (wMsgType == OBJECTDYING){
				dataLength = 15;

				sp  = (short *)cp;
				*sp = pNpc->m_sX;
				cp += 2;
				sp  = (short *)cp;
				*sp = pNpc->m_sY;
				cp += 2;
			}
			break;

		case OBJECTATTACK:
		case OBJECTATTACKMOVE:
			dataLength = 13;
			
			wp  = (WORD *)cp;
			*wp = sOwnerH + 40000;
			cp += 2;
			*cp = pNpc->m_cDir;
			cp++;
			*cp = sV1 - pNpc->m_sX;
			cp++;
			*cp = sV2 - pNpc->m_sY;
			cp++;
			sp  = (short *)cp;
			*sp = sV3;
			cp += 2;
			break;

		case MSGTYPE_CONFIRM:
		case MSGTYPE_REJECT:
		case OBJECTNULLACTION:
		default:
			dataLength = 27;

			wp  = (WORD *)cp;
			*wp = sOwnerH + 10000;
			cp += 2;
			sp  = (short *)cp;
			*sp = pNpc->m_sX;
			cp += 2;
			sp  = (short *)cp;
			*sp = pNpc->m_sY;
			cp += 2;
			sp  = (short *)cp;
			*sp = pNpc->m_sType;
			cp += 2;
			*cp = pNpc->m_cDir;
			cp++;
			memcpy(cp, pNpc->m_cName, 5);
			cp += 5;
			sp  = (short *)cp;
			*sp = pNpc->m_sAppr2;
			cp += 2;

			ip  = (int *)cp;
			ipStatus = ip;
			*ip = pNpc->m_iStatus;
			cp += 4;
			if (wMsgType != OBJECTNULLACTION || pNpc->m_bIsKilled == FALSE) {
				*cp = 0; 
			}
			else *cp = 1;
			cp++;
			break;
		}

		iShortCutIndex = 0;

		CClient * pClient;
		while (i = m_iClientShortCut[iShortCutIndex++]) 
		{
			if ((pClient = m_pClientList[i]) && pClient->m_bIsInitComplete) {
				if ( (pClient->m_cMapIndex == pNpc->m_cMapIndex) &&
					(pClient->m_sX >= pNpc->m_sX - 11) &&
					(pClient->m_sX <= pNpc->m_sX + 11) &&
					(pClient->m_sY >= pNpc->m_sY - 9) &&
					(pClient->m_sY <= pNpc->m_sY + 9) ) 
				{
					iRet = pClient->m_pXSock->iSendMsg(data, dataLength, cKey);  
				}
			}
		}
	}
}


int CGame::iComposeMoveMapData(short sX, short sY, int iClientH, char cDir, char * pData)
{
	int ix, iy, iSize, iIndex;
	class CTile * pTileSrc;
	short total;

	if (m_pClientList[iClientH] == NULL) return 0;

	iSize = 2;
	pTileSrc = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + 
		(sX) + (sY)*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

	total = 0;
	iIndex = 0;
	while (1) {
		ix = _tmp_iMoveLocX[cDir][iIndex];
		iy = _tmp_iMoveLocY[cDir][iIndex];
		if ((ix == -1) || (iy == -1)) break;
		iIndex++;

		if(WriteTileData(pData + iSize, iSize, iClientH, pTileSrc, ix, iy))
			total++;
	}

	*((short *)pData) = total;
	return iSize;
}


void CGame::OnTimer(char cType)
{
	DWORD dwTime;
	register BYTE b;


	dwTime = timeGetTime();

	if ((dwTime - m_dwGameTime1) > 300 _ms) {
		NpcProcess();
		m_dwGameTime1 = dwTime;
	}

	MsgProcess();

	if ((dwTime - m_dwGameTime2) > 3 _s) {
		CheckClientResponseTime();
		bSendMsgToLS(MSGID_GAMESERVERALIVE, NULL);
		CheckDayOrNightMode();
		InvalidateRect(G_hWnd, NULL, TRUE);
		m_dwGameTime2 = dwTime;


		if ((m_bIsGameStarted == FALSE)     && (m_bIsItemAvailable == TRUE)      && 
			(m_bIsNpcAvailable == TRUE)     && (m_bIsMagicAvailable == TRUE)     &&
			(m_bIsSkillAvailable == TRUE)   && (m_bIsPotionAvailable == TRUE)   &&
			(m_bIsQuestAvailable == TRUE)   && (m_bIsBuildItemAvailable == TRUE) && 
			(m_iSubLogSockActiveCount == MAXSUBLOGSOCK)
			) 
		{
			//PutLogList("Initializing drops list...");
			//m_drops.InitDrops();
		//	PutLogList("Sending start message...");
			SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, NULL, NULL);
			m_bIsGameStarted = TRUE;
		}
	}

	if ((dwTime - m_dwGameTime6) > 1 _s) {
		if(m_astoria.get() && m_astoria->CheckVictory())
		{
			EventEnd();
		}
		DelayEventProcessor();
		SendStockMsgToGateServer();


		if (m_iFinalShutdownCount != 0) {
			m_iFinalShutdownCount--;
			wsprintf(g_cTxt, "Final Shutdown...%d", m_iFinalShutdownCount);
			PutLogList(g_cTxt);
			if (m_iFinalShutdownCount <= 1) {

				SendMessage(m_hWnd, WM_DESTROY, NULL, NULL);
				return;

			}
		}


		if (!m_bIsGameServerRegistered && m_pSubLogSock[0] == NULL) {
			m_pSubLogSock[0] = new XSocket(m_hWnd, SERVERSOCKETBLOCKLIMIT);
			m_pSubLogSock[0]->bConnect(m_cLogServerAddr, m_iGateServerPort, (WM_ONLOGSOCKETEVENT + 1));
			m_pSubLogSock[0]->bInitBufferSize(MSGBUFFERSIZE);
			//wsprintf(g_cTxt, "(*) Try to connect sub-log-socket(0)... Addr:%s  Port:%d", m_cLogServerAddr, m_iGateServerPort);
			//PutLogList(g_cTxt);
		}
		else if(m_bIsGameServerRegistered) for (b = 1; b < MAXSUBLOGSOCK; b++){
			if(m_pSubLogSock[b] == NULL && !m_bIsSocketConnected[b] && m_bIsSocketConnected[b-1]){
				m_pSubLogSock[b] = new XSocket(m_hWnd, SERVERSOCKETBLOCKLIMIT);
				m_pSubLogSock[b]->bConnect(m_cLogServerAddr, m_iGateServerPort, (WM_ONLOGSOCKETEVENT + b + 1));
				m_pSubLogSock[b]->bInitBufferSize(MSGBUFFERSIZE);
				//wsprintf(g_cTxt, "(*) Try to connect sub-log-socket(%d)... Addr:%s  Port:%d", b, m_cLogServerAddr, m_iGateServerPort);
				//PutLogList(g_cTxt);
			}		 
		}

		m_dwGameTime6 = dwTime;
	}

	if ((dwTime - m_dwGameTime3) > 3 _s) {
		SyncMiddlelandMapInfo();
		CheckDynamicObjectList();
		DynamicObjectEffectProcessor();
		NoticeHandler();
		SpecialEventHandler();
		// EnergySphereProcessor();
		m_dwGameTime3 = dwTime;
		for(std::list<ConfirmedIP>::iterator it = confirmedIPs.begin(); it != confirmedIPs.end();)
			if((dwTime - it->timeReceived) > 30 _s) it = confirmedIPs.erase(it);
			else it++;

		for(std::list<RecentDisconnect>::iterator it = m_recentDCs.begin(); it != m_recentDCs.end();){
			for(int i = 0; i < 3; i++){
				if((it->disconnectTimes[i] != 0) && (dwTime - it->disconnectTimes[i]) > 10 _m){
					it->dcCount--;	
					it->disconnectTimes[i] = 0;
				}
			}
			if(it->dcCount == 0) it = m_recentDCs.erase(it);
			else it++;
		}
	}


	if ((dwTime - m_dwGameTime4) > 600 _ms) {
		MobGenerator();
		m_dwGameTime4 = dwTime;
	}

	if ((dwTime - m_dwGameTime5) > 3 _m) {
		if (m_iMiddlelandMapIndex >= 0) {
			// Crusade
			SaveOccupyFlagData();
			//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
			//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
		}
		m_dwGameTime5 = dwTime;


		srand( (unsigned)time( NULL ) );   
	}

	if ((dwTime - m_dwFishTime) > 4 _s) {
		FishProcessor();
		FishGenerator();
		SendCollectedMana();
		Scheduler();
		m_dwFishTime = dwTime;
	}

	if ((dwTime - m_dwWhetherTime) > 1 _m) {
		UpdateWebsiteStats();
		WhetherProcessor();
		if (m_bIsApocalypseMode == TRUE) DoAbaddonThunderDamageHandler(-1);
		if (m_bHeldenianMode) UpdateHeldenianStatus();
		m_dwWhetherTime = dwTime;
		TileCleaner();

		uint32 add;
		if(dwTime - m_startTime < 5 _m)
		{
			add = dice(2,4);
		}
		else if(dwTime - m_startTime < 30 _m)
		{
			add = dice(2,6);
		}
		else
		{
			add = dice(2,8);
		}
		if(add > m_onlineCntAdd)
			m_onlineCntAdd++;
		else if(add < m_onlineCntAdd)
			m_onlineCntAdd--;
	}


	if ((dwTime - m_dwCanFightzoneReserveTime) > 2 _h) {
		FightzoneReserveProcessor();
		m_dwCanFightzoneReserveTime = dwTime;
	}

	if ((m_bIsServerShutdowned == FALSE) && (m_bOnExitProcess == TRUE) && ((dwTime - m_dwExitProcessTime) > 1000*2)) {
		if (_iForcePlayerDisconect(15) == 0) {
			PutLogList("(!!!) GAME SERVER SHUTDOWN PROCESS COMPLETED! All players are disconnected.");
			m_bIsServerShutdowned = TRUE;

			if ((m_cShutDownCode == 3) || (m_cShutDownCode == 4)) {
				PutLogFileList("(!!!) AUTO-SERVER-REBOOTING!");
				bInit();
//				m_iAutoRebootingCount++;
			}
			else {
				if (m_iFinalShutdownCount == 0)	m_iFinalShutdownCount = 20;
			}
		}
		m_dwExitProcessTime = dwTime;
	}

	if ((dwTime - m_dwMapSectorInfoTime) > 10 _s) {
		m_dwMapSectorInfoTime = dwTime;
		UpdateMapSectorInfo();

		MineralGenerator();

		m_iMapSectorInfoUpdateCount++;
		if (m_iMapSectorInfoUpdateCount >= 5) {
			AgingMapSectorInfo();
			m_iMapSectorInfoUpdateCount = 0;
		}
	}
}

void CGame::CheckClientResponseTime()
{
	// register int i, iPlusTime, iMaxSuperAttack, iValue, iMapSide,iTmpMapSide;
	register int i, iPlusTime, iMaxSuperAttack, iValue;

	short sTemp;
	DWORD dwTime;
	//SYSTEMTIME SysTime;

	/*
	GetLocalTime(&SysTime);
	switch (SysTime.wDayOfWeek) {
	case 1:	iWarPeriod = 30; break; 
	case 2:	iWarPeriod = 30; break; 
	case 3:	iWarPeriod = 60; break; 
	case 4:	iWarPeriod = 60*2;  break; 
	case 5:	iWarPeriod = 60*5;  break; 
	case 6:	iWarPeriod = 60*10; break; 
	case 0:	iWarPeriod = 60*20; break; 
	}
	*/

	dwTime = timeGetTime();

	for (i = 1; i < MAXCLIENTS; i++) {
		if (m_pClientList[i] != NULL) {

			if ((dwTime - m_pClientList[i]->m_dwTime) > CLIENTTIMEOUT ) {
				if (m_pClientList[i]->m_bIsInitComplete == TRUE) {

					//Testcode 
					wsprintf(g_cTxt, "Client Timeout: %s (%s)", m_pClientList[i]->m_cCharName ,m_pClientList[i]->m_cIPaddress);
					PutLogList(g_cTxt);

					DeleteClient(i, TRUE, TRUE);
				}
				else {
					DeleteClient(i, FALSE, FALSE); 
				}
			}
			else if (m_pClientList[i]->m_bIsInitComplete == TRUE) {
				m_pClientList[i]->m_iTimeLeft_ShutUp--;
				if (m_pClientList[i]->m_iTimeLeft_ShutUp < 0) m_pClientList[i]->m_iTimeLeft_ShutUp = 0;


				m_pClientList[i]->m_iTimeLeft_Rating--;
				if (m_pClientList[i]->m_iTimeLeft_Rating < 0) m_pClientList[i]->m_iTimeLeft_Rating = 0;

				if (((dwTime - m_pClientList[i]->m_dwHungerTime) > HUNGERTIME) && (m_pClientList[i]->m_bIsKilled == FALSE)) {

					if ((m_pClientList[i]->m_iLevel < LEVELLIMIT) || (m_pClientList[i]->m_iAdminUserLevel >= 1 )) {
					}
					else m_pClientList[i]->m_iHungerStatus--;
					if (m_pClientList[i]->m_iHungerStatus <= 0) m_pClientList[i]->m_iHungerStatus = 0;
					m_pClientList[i]->m_dwHungerTime = dwTime;

					if ( (m_pClientList[i]->m_iHP > 0) && (m_pClientList[i]->m_iHungerStatus < 30) ) {
						SendNotifyMsg(NULL, i, NOTIFY_HUNGER, m_pClientList[i]->m_iHungerStatus, NULL, NULL, NULL);
					}
				}

				if ((m_pClientList[i]->m_iHungerStatus <= 30) && (m_pClientList[i]->m_iHungerStatus >= 0)) 
					iPlusTime = (30 - m_pClientList[i]->m_iHungerStatus)_s;
				else iPlusTime = 0;

				iPlusTime = abs(iPlusTime);


				if ((dwTime - m_pClientList[i]->m_dwHPTime) > (DWORD)(HPUPTIME + iPlusTime)) {
					TimeHitPointsUp(i);
					m_pClientList[i]->m_dwHPTime = dwTime;
				}


				if ((dwTime - m_pClientList[i]->m_dwMPTime) > (DWORD)(MPUPTIME + iPlusTime)) {
					TimeManaPointsUp(i);
					m_pClientList[i]->m_dwMPTime = dwTime;
				}


				if ((dwTime - m_pClientList[i]->m_dwSPTime) > (DWORD)(SPUPTIME + iPlusTime)) {
					TimeStaminarPointsUp(i);
					m_pClientList[i]->m_dwSPTime = dwTime;
				}


				if ((m_pClientList[i]->m_bIsPoisoned == TRUE) && ((dwTime - m_pClientList[i]->m_dwPoisonTime) > POISONTIME)) {
					PoisonEffect(i, NULL);
					m_pClientList[i]->m_dwPoisonTime = dwTime;
				}

				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFightZone == FALSE) &&
					((dwTime - m_pClientList[i]->m_dwAutoSaveTime) > (DWORD)AUTOSAVETIME)) {

						bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, i);
						m_pClientList[i]->m_dwAutoSaveTime = dwTime;
				}


				if ((dwTime - m_pClientList[i]->m_dwExpStockTime) > (DWORD)EXPSTOCKTIME) {
					m_pClientList[i]->m_dwExpStockTime = dwTime;
					CalcExpStock(i);
					CheckUniqueItemEquipment(i);
					CheckCrusadeResultCalculation(i);
					CheckHeldenianResultCalculation(i);
				}


				if ((dwTime - m_pClientList[i]->m_dwAutoExpTime) > (DWORD)AUTOEXPTIME) {

					iValue = (m_pClientList[i]->m_iLevel);
					if (iValue <= 0) iValue = 1;
					if (m_pClientList[i]->m_iAutoExpAmount < iValue) {
						if ((m_pClientList[i]->m_iExp + iValue) < m_iLevelExpTable[m_pClientList[i]->m_iLevel+1]) {
							GetExp(i, iValue);
							CalcExpStock(i);
						}
					}

					m_pClientList[i]->m_iAutoExpAmount = 0;
					m_pClientList[i]->m_dwAutoExpTime = dwTime;
				}


				if (m_pClientList[i]->m_iSpecialAbilityTime == 3) {
					SendNotifyMsg(NULL, i, NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);

					short sItemIndex = m_pClientList[i]->m_sItemEquipmentStatus[EQUIPPOS_RHAND];
					if (sItemIndex != -1) { //Notify player Res available if possible
						if (m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_RESURWAND_MS10 || 
							m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_RESURWAND_MS20) {
							if(m_pClientList[i]->GetInt() >= 100 && m_pClientList[i]->GetMag() >= 100){
								m_pClientList[i]->m_cMagicMastery[94] = TRUE; //Resurrection
								SendNotifyMsg(NULL, i, NOTIFY_SPELL_SKILL, NULL, NULL, NULL, NULL);
							}
						}
					}
				}
				m_pClientList[i]->m_iSpecialAbilityTime -= 3;
				if (m_pClientList[i]->m_iSpecialAbilityTime < 0) m_pClientList[i]->m_iSpecialAbilityTime = 0;


				if (m_pClientList[i]->m_bIsSpecialAbilityEnabled == TRUE) {
					if (((dwTime - m_pClientList[i]->m_specialAbilityStartTime)/1000) > m_pClientList[i]->m_specialAbilityLastSec) {

						SendNotifyMsg(NULL, i, NOTIFY_SPECIALABILITYSTATUS, 3, NULL, NULL, NULL);
						m_pClientList[i]->m_bIsSpecialAbilityEnabled = FALSE;

						m_pClientList[i]->m_iSpecialAbilityTime = SPECABLTYTIMESEC;
						sTemp = m_pClientList[i]->m_sAppr4;
						sTemp = sTemp & 0xFF0F;
						m_pClientList[i]->m_sAppr4 = sTemp;
						SendEventToNearClient_TypeA(i, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTNULLACTION, NULL, NULL, NULL);
					}
				}

				//Crusade
				m_pClientList[i]->m_iLockedMapTime -= 3;
				if (m_pClientList[i]->m_iLockedMapTime < 0) {
					m_pClientList[i]->m_iLockedMapTime = 0;
					ZeroMemory(m_pClientList[i]->m_cLockedMapName, sizeof(m_pClientList[i]->m_cLockedMapName));
					strcpy(m_pClientList[i]->m_cLockedMapName, "NONE");
				}


				m_pClientList[i]->m_iDeadPenaltyTime -= 3;
				if (m_pClientList[i]->m_iDeadPenaltyTime < 0) m_pClientList[i]->m_iDeadPenaltyTime = 0;

				if ( (m_pClientList[i]->m_bIsWarLocation == TRUE) ) {
					// Crusade
					if ((m_bIsCrusadeMode == FALSE) || (m_pClientList[i]->m_bIsInBuilding == TRUE))
						m_pClientList[i]->m_iTimeLeft_ForceRecall--;

					if (m_pClientList[i]->m_iTimeLeft_ForceRecall <= 0) {
						m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
						m_pClientList[i]->m_dwWarBeginTime = dwTime;
						m_pClientList[i]->m_bIsWarLocation = FALSE;

						SendNotifyMsg(NULL, i, NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, 0);
					}
				}
				
				if (m_pClientList[i] == NULL) break;
				if (   (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsApocalypseMap == TRUE) 
					&& (m_bIsApocalypseMode == FALSE)
					&& (m_pClientList[i]->m_iAdminUserLevel == 0))
				{	m_pClientList[i]->m_bIsWarLocation = TRUE;
					m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;				
				}
					Use_ApocalypseGate(i);	

				if(m_pClientList[i]->m_cMapIndex == m_iAstoriaMapIndex && !m_astoria.get())
				{
					SYSTEMTIME currTime;
					GetLocalTime(&currTime);

					if((currTime.wDayOfWeek == FRIDAY ||
						currTime.wDayOfWeek == SATURDAY ||
						currTime.wDayOfWeek == SUNDAY) && !m_pClientList[i]->IsGM())
					{
						SendNotifyMsg(NULL, i, NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, 0);
					}
				}

				if (m_pClientList[i] == NULL) break;
				if (m_pClientList[i]->m_iSkillMsgRecvCount >= 2) {
					//PutLogFileList(g_cTxt);
					DeleteClient(i, TRUE, TRUE);
				}
				else {
					m_pClientList[i]->m_iSkillMsgRecvCount = 0;
				}

				if (m_pClientList[i] == NULL) break;


				if ((m_pClientList[i]->m_iLevel < m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iLevelLimit) && (m_pClientList[i]->m_iAdminUserLevel < 1) ) {
					SendNotifyMsg(NULL, i, NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, 0);
				}

				if (m_pClientList[i] == NULL) break;


				if ( (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit != 0) &&
					(m_pClientList[i]->m_iLevel > m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit) && (m_pClientList[i]->m_iAdminUserLevel < 1) ) {
						SendNotifyMsg(NULL, i, NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, 0);
				}

				/*		if (m_pClientList[i] == NULL) break;

				if ((memcmp(m_pClientList[i]->m_cLocation, "NONE",4) == 0) &&
				(strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, sideMap[ARESDEN]) == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, sideMap[ELVINE]) == 0)) {

				SendNotifyMsg(NULL, i, NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
				RequestTeleportHandler(i, 0);
				} */




				/*
				if (m_pClientList[i] == NULL) break;
				if ((m_pClientList[i]->m_dwFightzoneDeadTime != NULL) && 
				((dwTime - m_pClientList[i]->m_dwFightzoneDeadTime) > 1000*30)) {

				m_pClientList[i]->m_dwFightzoneDeadTime = NULL;
				ResurrectPlayer(i);
				}
				*/

				if (m_pClientList[i] == NULL) break;

				m_pClientList[i]->m_iSuperAttackCount++;
				if (m_pClientList[i]->m_iSuperAttackCount > 12) {

					m_pClientList[i]->m_iSuperAttackCount = 0;
					iMaxSuperAttack = (m_pClientList[i]->m_iLevel / 10);
					if (m_pClientList[i]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[i]->m_iSuperAttackLeft++;

					SendNotifyMsg(NULL, i, NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
				}


				m_pClientList[i]->m_iTimeLeft_FirmStamina--;
				if (m_pClientList[i]->m_iTimeLeft_FirmStamina < 0) m_pClientList[i]->m_iTimeLeft_FirmStamina = 0;


				if (m_pClientList[i] == NULL) break;
				if (m_pClientList[i]->m_bIsSendingMapStatus == TRUE) _SendMapStatus(i);

				if (m_pClientList[i]->m_iConstructionPoint > 0) {
					CheckCommanderConstructionPoint(i);
				}
			}
		}
	}
}
//==============================================================================
bool CGame::bSendMsgToLS(DWORD dwMsg, int iClientH, bool bFlag,char * pData)
{
	DWORD * dwp;
	WORD  * wp;
	BYTE  * bp;
	int     iRet, i, iSize;
	char    cCharName[11], cAccountName[11], cAccountPassword[11], cAddress[16], cGuildName[21], cTxt[120], * cp;
	char    cGuildLoc[11], cTemp[120];
	int   * ip, iSendSize;


	/*
	m_iCurSubLogSockIndex++;
	if (m_iCurSubLogSockIndex >= MAXSUBLOGSOCK) m_iCurSubLogSockIndex = 0;


	iCnt = 0;
	bLoopFlag = FALSE;
	while (bLoopFlag == FALSE) {
	if (m_pSubLogSock[m_iCurSubLogSockIndex] != NULL) 
	bLoopFlag = TRUE;
	else m_iCurSubLogSockIndex++;

	iCnt++;
	if (iCnt >= MAXSUBLOGSOCK) {

	if (m_bOnExitProcess == FALSE) {
	m_cShutDownCode      = 3;
	m_bOnExitProcess     = TRUE;
	m_dwExitProcessTime  = timeGetTime();

	PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by Log-server connection Lost)!!!");
	}
	return FALSE;
	}
	}
	*/



	ZeroMemory(G_cData50000, sizeof(G_cData50000));
	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	ZeroMemory(cAddress,   sizeof(cAddress));
	ZeroMemory(cGuildName, sizeof(cGuildName));
	ZeroMemory(cGuildLoc,  sizeof(cGuildLoc));

	switch (dwMsg) {

	case MSGID_PARTYOPERATION:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(pData, 50);
		if (iRet == -1) return FALSE;
		break;

	case MSGID_SERVERSTOCKMSG:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(pData, m_iIndexGSS+1);
		if (iRet == -1) return FALSE;
		break;

	case MSGID_GAMESERVERALIVE:
		if(!m_bIsGameStarted) return FALSE;
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_GAMESERVERALIVE;
		wp   = (WORD *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp  = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);
		wp  = (WORD *)cp;
		*wp = m_iTotalClients;
		cp += 2;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 8);
		if (iRet == -1) return FALSE;
		break;

	case MSGID_ITEMLOG:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_ITEMLOG;
		wp   = (WORD *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);
		memcpy(cp, pData, 47);
		cp += 47;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 53);
		break;

	case MSGID_SENDSERVERSHUTDOWNMSG:
		/*if (m_pMainLogSock == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_SENDSERVERSHUTDOWNMSG;
		wp   = (WORD *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		iRet = m_pMainLogSock->iSendMsg(G_cData50000, 6);*/
		break;

	case MSGID_GAMESERVERSHUTDOWNED:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_GAMESERVERSHUTDOWNED;
		wp   = (WORD *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6);
		return TRUE;

	case MSGID_REQUEST_SETACCOUNTWAITSTATUS:
	case MSGID_REQUEST_SETACCOUNTINITSTATUS:

		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

		if (m_pClientList[iClientH] == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iLevel;
		cp += 4;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 20);
		iSendSize = 16;
		break;

	case MSGID_ENTERGAMECONFIRM:


		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_ENTERGAMECONFIRM;
		wp   = (WORD *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
		cp += 10;

		memcpy(cp, m_pClientList[iClientH]->m_cAccountPassword, 10);
		cp += 10;

		memcpy(cp, m_cServerName, 10);
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt));
		m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTxt);
		memcpy(cp, cTxt, 16);
		cp += 16;

		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iLevel;
		cp += 4;

		wsprintf(g_cTxt, "(Client Login) Enter Game: %s(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iLevel);
		PutLogList(g_cTxt);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
		iSendSize = 56;
		break;

	case MSGID_REQUEST_REGISTERGAMESERVER:

		//wsprintf(cTxt, "(!) Try to register game server(%s)", m_cServerName);
		//PutLogList(cTxt);

		dwp  = (DWORD *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_REQUEST_REGISTERGAMESERVER;
		wp   = (WORD *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		SafeCopy(cAddress, m_cGameServerAddr, strlen(m_cGameServerAddr));
		
		SafeCopy(cp, m_cServerName, 10);
		cp += 10;

		SafeCopy(cp, WorldName, 10);
		cp += 10;

		SafeCopy(cp, cAddress, 16);
		cp += 16;

		wp  = (WORD *)cp;
		*wp = m_iGameServerPort;
		cp += 2;

		bp  = (BYTE *)cp;
		*bp = ReceivedAllConfig;
		cp++;

		*cp = m_iTotalMaps;
		cp++;

		wp  = (WORD *)cp;
		*wp = GSID;
		cp += 2;

		for (i = 0; i < m_iTotalMaps; i++) {
			SafeCopy(cp, m_pMapList[i]->m_cName, 11);
			cp += 11;
		}

		m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 47 + m_iTotalMaps*11);
		return TRUE;


	case MSGID_REQUEST_REGISTERGAMESERVERSOCKET:
		dwp  = (DWORD *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_REQUEST_REGISTERGAMESERVERSOCKET;
		wp  = (WORD *)(G_cData50000 + 4);
		*wp = GSID;
		m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6);
		//wsprintf(cTxt, "(!) Try to register game server socket(%d) on ID[%u]",m_iCurSubLogSockIndex, GSID);
		//PutLogList(cTxt);
		return TRUE;

	case MSGID_REQUEST_PLAYERDATA:

		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_REQUEST_PLAYERDATA;
		wp   = (WORD *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		//testcode
		if (strlen(m_pClientList[iClientH]->m_cCharName) == 0) PutLogList("(X) CharName NULL!");

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		ZeroMemory(cTemp, sizeof(cTemp));
		iRet = m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp);
		memcpy((char *)cp, cTemp, 15);
		cp += 15;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 52);
		iSendSize = 52;
		break;
		//Crusade 
		/*
		case MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA:


		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

		if (m_iMiddlelandMapIndex < 0) return FALSE;

		//testcode
		PutLogList("(!) Middleland Aresden OccupyFlag data saved.");

		dwp  = (DWORD *)(G_cData50000 + INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);
		iSize = _iComposeFlagStatusContents(cp, 1);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize + 10);
		iSendSize = 6 + iSize + 10;
		break;

		case MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA:


		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

		if (m_iMiddlelandMapIndex < 0) return FALSE;

		//testcode
		PutLogList("(!) Middleland Elvine OccupyFlag data saved.");

		dwp  = (DWORD *)(G_cData50000 + INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);
		iSize = _iComposeFlagStatusContents(cp, 2);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize + 10);
		iSendSize = 6 + iSize + 10;
		break;
		*/
	case MSGID_REQUEST_SAVEPLAYERDATA_REPLY:
	case MSGID_REQUEST_SAVEPLAYERDATA:
	case MSGID_REQUEST_SAVEPLAYERDATALOGOUT:

		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		if (strlen(m_pClientList[iClientH]->m_cCharName) == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		SafeCopy(cp, m_pClientList[iClientH]->m_cCharName);
		cp += 10;

		SafeCopy(cp, m_pClientList[iClientH]->m_cAccountName);
		cp += 10;

		SafeCopy(cp, m_pClientList[iClientH]->m_cAccountPassword);
		cp += 10;

		*cp = (char)bFlag;
		cp++;

		iSize = _iComposePlayerDataFileContents(iClientH, cp);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37 + iSize);
		iSendSize = 37 + iSize;
		break;

	case MSGID_REQUEST_NOSAVELOGOUT:

		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_REQUEST_NOSAVELOGOUT;
		wp   = (WORD *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		*cp = (char)bFlag; 
		cp++;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37);
		iSendSize = 37;
		break;

	case MSGID_REQUEST_CREATENEWGUILD:

		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_REQUEST_CREATENEWGUILD;
		wp   = (WORD *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
		memcpy(cGuildLoc, m_pClientList[iClientH]->m_cLocation, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;
		memcpy((char *)cp, cGuildLoc, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iGuildGUID;
		cp += 4;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 75);
		iSendSize = 75;
		break;

	case MSGID_REQUEST_DISBANDGUILD:

		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_REQUEST_DISBANDGUILD;
		wp   = (WORD *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
		iSendSize = 56;
		break;

	case MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN:

		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN;
		wp   = (WORD *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
		iSendSize = 36;
		break;

	case MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN:

		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN;
		wp   = (WORD *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
		iSendSize = 36;
		break;

	case MSGID_GAMEMASTERLOG:
	case MSGID_GAMEITEMLOG:
	case MSGID_GAMECRUSADELOG:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		if (pData == NULL) return FALSE ;

		dwp  = (DWORD *)(G_cData50000 + INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		iSize =  strlen(pData) ;
		memcpy((char *)cp, pData, iSize);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize);
		iSendSize = 6 + iSize;
		break;

	case MSGID_REQUEST_LGNPTS:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = NULL;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		wp = (WORD *)cp;
		*wp = iClientH;
		cp += 2;

		memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
		cp += 10;

		iSendSize = 18;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);
		break;

	case MSGID_REQUEST_LGNSVC:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

		memcpy(G_cData50000, pData, 6);

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		wp = (WORD *)cp;
		*wp = iClientH;
		cp += 2;

		memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
		cp += 10;

		iSendSize = 18;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);
		break;

	case MSGID_SUBCASH:		
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = NULL;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		memcpy(cp, pData, 12);

		iSendSize = 18;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);
		break;

	}

	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:

		wsprintf(g_cTxt, "(!!!) Sub-log-socket(%d) send error!", m_iCurSubLogSockIndex);
		PutLogList(g_cTxt);
		PutLogFileList(g_cTxt);

		delete m_pSubLogSock[m_iCurSubLogSockIndex];
		m_pSubLogSock[m_iCurSubLogSockIndex] = NULL;
		m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] = FALSE;
		m_iSubLogSockActiveCount--;


		m_pSubLogSock[m_iCurSubLogSockIndex] = new class XSocket(m_hWnd, SERVERSOCKETBLOCKLIMIT);
		m_pSubLogSock[m_iCurSubLogSockIndex]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + m_iCurSubLogSockIndex + 1));
		m_pSubLogSock[m_iCurSubLogSockIndex]->bInitBufferSize(MSGBUFFERSIZE);

		wsprintf(g_cTxt, "(!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", m_iCurSubLogSockIndex, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(g_cTxt);

		m_iSubLogSockFailCount++;

		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);

		return FALSE;
	}

	return TRUE;
}



void CGame::ResponsePlayerDataHandler(char * pData, DWORD dwSize)
{
	WORD * wp;
	DWORD * dwp ;
	char * cp, cCharName[11], cTxt[120];
	int  i; 

	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	for (i = 1; i < MAXCLIENTS; i++) 
		if (m_pClientList[i] != NULL) {
			if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {
				wp = (WORD *)(pData + INDEX2_MSGTYPE);
				switch (*wp) {
				case LOGRESMSGTYPE_CONFIRM:
					InitPlayerData(i, pData, dwSize); 
					break;

				case LOGRESMSGTYPE_REJECT:

					if( *cp == 1) {
						ZeroMemory(cTxt, sizeof(cTxt));
						dwp  = (DWORD *)(cTxt + INDEX4_MSGID);
						*dwp = MSGID_RESPONSE_INITPLAYER;
						wp   = (WORD *)(cTxt + INDEX2_MSGTYPE);
						*wp  = MSGTYPE_REJECT;

						m_pClientList[i]->m_pXSock->iSendMsg(cTxt, 6); 
					}
					else {
						wsprintf(g_cTxt, "(HACK?) Not existing character(%s) data request! Rejected!", m_pClientList[i]->m_cCharName);
						PutLogList(g_cTxt);
						//PutLogFileList(g_cTxt); 

						DeleteClient(i, FALSE, FALSE);
					}
					break;

				default:
					break;
				}

				return;
			}
		}

		wsprintf(cTxt, "(!)Non-existing player data received from Log server: CharName(%s)", cCharName);
		PutLogList(cTxt);
}

void CGame::InitPlayerData(int iClientH, char * pData, DWORD dwSize)
{
	char  * cp, cName[11], cData[256], cTxt[256], cGuildStatus;
	DWORD * dwp;
	WORD  * wp;
	int   * ip, i, iRet, iTotalItemA, iTotalItemB, iStats;
	bool    bRet, bFlag;
	char  * pBuffer = NULL;
	short * sp;

	CClient * player = m_pClientList[iClientH];

	if (!player) return;
	if (player->m_bIsInitComplete == TRUE) return; 


	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	cp += 10;

	////player->m_cAccountStatus = *cp;
	//cp++;

	//cGuildStatus = *cp;
	//cp++;

	player->m_iHitRatio		= 0;
	player->m_iDefenseRatio	= 0;
	player->m_side				= 0;

	bRet = _bDecodePlayerDatafileContents(iClientH, cp, dwSize - 19);
	if (!bRet) {
		wsprintf(g_cTxt, "(HACK?) Character(%s) data error!", player->m_cCharName);
		DeleteClient(iClientH, FALSE, TRUE);
		return;
	}	

	//***************************************************************************

	if(!player->IsGM() && player->m_iLevel > m_sMaxPlayerLevel) {
		wsprintf(g_cTxt, "(HACK) (%s) Player: (%s) High level hack (%i)", player->m_cIPaddress, player->m_cCharName, player->m_iLevel);
		PutLogFileList(g_cTxt, HACK_LOGFILE);
		PutLogList(g_cTxt);
		DeleteClient(iClientH, FALSE, TRUE, TRUE, TRUE);
		return;
	}

	int iTotalPoints = 0;
	for (i = 0; i <	MAXSKILLTYPE; i++) 
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];
	if ((iTotalPoints-21 > m_sCharSkillLimit) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		wsprintf(g_cTxt, "(HACK) Packet Editing: (%s) Player: (%s) - has more than allowed skill points (%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, iTotalPoints);
		PutLogFileList(g_cTxt);
		DeleteClient(iClientH, FALSE, TRUE, TRUE, TRUE);
		return;
	}


	if ((player->m_sX == -1) && (player->m_sY == -1)) {
		GetMapInitialPoint(player->m_cMapIndex, &player->m_sX, &player->m_sY, player->m_cLocation);
	}

	if(player->m_iPKCount > 0)
		player->SetStatusFlag(STATUS_PK, TRUE);

	iSetSide(iClientH);

	player->m_iNextLevelExp = m_iLevelExpTable[player->m_iLevel + 1];

	CalcTotalItemEffect(iClientH, -1, TRUE); //FALSE
	iCalcTotalWeight(iClientH);
	_SendQuestContents(iClientH);

	player->ValidateSkills(TRUE);

	if ((player->m_iAdminUserLevel >= 1) && (player->m_iAdminUserLevel <= 4))
	{
		player->SetStatusFlag(STATUS_INVISIBILITY, TRUE);
		player->m_GMFlags |= GMFLAG_INVENCIBLE | GMFLAG_NOAGGRO;
	}

	if ((cGuildStatus == 0) && (memcmp(player->m_cGuildName, "NONE", 4) != 0)) {
		ZeroMemory(player->m_cGuildName, sizeof(player->m_cGuildName));
		strcpy(player->m_cGuildName, "NONE");
		player->m_iGuildRank = -1;
		player->m_iGuildGUID = -1;

		SendNotifyMsg(NULL, iClientH, NOTIFY_GUILDDISBANDED, NULL, NULL, NULL, player->m_cGuildName);
	}

	if (player == NULL) {
		wsprintf(cTxt, "<%d> InitPlayerData error - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);
		return;
	}

	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(cData + INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITPLAYER;
	wp   = (WORD *)(cData + INDEX2_MSGTYPE);
	*wp  = MSGTYPE_CONFIRM;

	iRet = player->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:

		wsprintf(cTxt, "<%d> InitPlayerData - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);

		DeleteClient(iClientH, FALSE, TRUE); //!!!!!
		return;
	}

	player->m_bIsInitComplete = TRUE;

	bSendMsgToLS(MSGID_ENTERGAMECONFIRM, iClientH);

	if(player->m_iPartyID != NULL){
		if (m_pMapList[player->m_cMapIndex]->m_isPartyDisabled && !player->IsGM()) {
			RequestDismissPartyHandler(iClientH);
		}
		else
		{
			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 5; 
			cp += 2;
			wp = (WORD *)cp;
			*wp = iClientH;
			cp += 2;
			memcpy(cp, player->m_cCharName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = player->m_iPartyID;
			cp += 2;
			bSendMsgToLS(MSGID_PARTYOPERATION, iClientH, FALSE, cData);

			for (i = 0; i < MAXPARTYMEMBERS; i++)
				if (m_stPartyInfo[player->m_iPartyID].iIndex[i] == 0) {
					m_stPartyInfo[player->m_iPartyID].iIndex[i] = iClientH;
					m_stPartyInfo[player->m_iPartyID].iTotalMembers++;
					break;
				}
		}
	}


	pBuffer = new char [MSGBUFFERSIZE+1];
	ZeroMemory(pBuffer, MSGBUFFERSIZE+1);

	dwp  = (DWORD *)(pBuffer + INDEX4_MSGID);
	*dwp = MSGID_PLAYERCHARACTERCONTENTS;
	wp   = (WORD *) (pBuffer + INDEX2_MSGTYPE);
	*wp  = MSGTYPE_CONFIRM;

	cp = (char *)(pBuffer + INDEX2_MSGTYPE + 2);

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iHP;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iMP;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iSP;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iDefenseRatio;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iHitRatio;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iLevel;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->GetStr();
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->GetInt();
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iVit;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->GetDex();
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->GetMag();
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iRange;
	cp  += 4;

	iStats = (m_pClientList[iClientH]->GetBaseStr() + m_pClientList[iClientH]->GetBaseDex() + m_pClientList[iClientH]->m_iVit +  
		m_pClientList[iClientH]->GetBaseInt() + m_pClientList[iClientH]->GetBaseMag() + m_pClientList[iClientH]->m_iRange); 

	m_pClientList[iClientH]->m_iLU_Pool =  m_pClientList[iClientH]->m_iLevel*3 - (iStats - 70);
	wp = (WORD *)cp; 
	*wp = m_pClientList[iClientH]->m_iLU_Pool;
	cp += 2;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iExp;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iEnemyKillCount;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iPKCount;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iRewardGold;
	cp  += 4;

	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
	cp  += 10;

	memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
	cp  += 20;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iGuildRank;
	cp  += 4;


	*cp = (char)m_pClientList[iClientH]->m_iSuperAttackLeft;
	cp++;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iFightzoneNumber;
	cp  += 4;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 115);
	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete[] pBuffer;
		return;
	}

	ZeroMemory(pBuffer, sizeof(pBuffer));
	ZeroMemory(cp, sizeof(cp));

	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(pBuffer);
	*dwp = MSGID_PLAYERSKILLCONTENTS;

	cp = (char *)(pBuffer + INDEX2_MSGTYPE + 2);

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_cSkillMastery[0];
	cp += 2;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_cSkillMastery[1];
	cp += 2;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_cSkillMastery[2];
	cp += 2;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_cSkillMastery[3];
	cp += 2;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_cSkillMastery[4];
	cp += 2;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_cSkillMastery[5];
	cp += 2;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_cSkillMastery[6];
	cp += 2;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_cSkillMastery[7];
	cp += 2;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_cSkillMastery[8];
	cp += 2;
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_cSkillMastery[9];
	cp += 2;

	for (i = 0; i < MAXMAGICTYPE; i++) {
		*cp = m_pClientList[iClientH]->m_cMagicMastery[i];
		cp++;
	}

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 6 + 20 + 100);

	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete[] pBuffer;
		return;
	}
	dwp  = (DWORD *)(pBuffer + INDEX4_MSGID);
	*dwp = MSGID_PLAYERITEMLISTCONTENTS;
	wp   = (WORD *) (pBuffer + INDEX2_MSGTYPE);
	*wp  = MSGTYPE_CONFIRM;


	iTotalItemA = 0;
	for (i = 0; i < MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
			iTotalItemA++;


	bFlag = FALSE;
	while (bFlag == FALSE) {
		bFlag = TRUE;
		for (i = 0; i < MAXITEMS-1; i++)
			if ((m_pClientList[iClientH]->m_pItemList[i] == NULL) && (m_pClientList[iClientH]->m_pItemList[i+1] != NULL)) {
				m_pClientList[iClientH]->m_pItemList[i] = m_pClientList[iClientH]->m_pItemList[i+1];
				m_pClientList[iClientH]->m_pItemList[i+1] = NULL;

				m_pClientList[iClientH]->m_ItemPosList[i].x = m_pClientList[iClientH]->m_ItemPosList[i+1].x;
				m_pClientList[iClientH]->m_ItemPosList[i].y = m_pClientList[iClientH]->m_ItemPosList[i+1].y;
				bFlag = FALSE;
			}
	}


	m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	CalcTotalItemEffect(iClientH, -1, FALSE);

	cp = (char *)(pBuffer + INDEX2_MSGTYPE + 2);

	*cp = iTotalItemA;
	cp++;

	for (i = 0; i < iTotalItemA; i++) {
		// ### ERROR POINT!!!
		if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
			wsprintf(g_cTxt, "Player error: Client(%s) Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(g_cTxt);

			DeleteClient(iClientH, FALSE, TRUE);
			if(pBuffer != NULL) delete[] pBuffer;
			return;
		}
		memcpy(cp, m_pClientList[iClientH]->m_pItemList[i]->m_cName, 20);
		cp += 20;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
		cp += 4;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemType;
		cp++;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos;
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_bIsItemEquipped[i];
		cp++;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sLevelLimit;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cGenderLimit;
		cp++;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan;
		cp += 2;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSprite;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSpriteFrame;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor; 
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2; 
		cp++;
		dwp =(DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute & 0x00000001); 
		cp++;
		*/
	}

	iTotalItemB = 0;
	for (i = 0; i < MAXBANKITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) 
			iTotalItemB++;

	*cp = iTotalItemB;
	cp++;

	for (i = 0; i < iTotalItemB; i++) {

		if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
			wsprintf(g_cTxt, "Player error: Client(%s) Bank-Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(g_cTxt);

			DeleteClient(iClientH, FALSE, TRUE);
			if(pBuffer != NULL) delete[] pBuffer;
			return;
		}
		memcpy(cp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName, 20);
		cp += 20;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount;
		cp += 4;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemType;
		cp++;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cEquipPos;
		cp++;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sLevelLimit;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cGenderLimit;
		cp++;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan;
		cp += 2;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wWeight;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSprite;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSpriteFrame;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor; 
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2; 
		cp++;
		dwp =(DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute & 0x00000001); 
		cp++;
		*/
	}

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 6 + iTotalItemA*44 + iTotalItemB*43);//44 //43
	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete[] pBuffer;
		return;
	}

	PlayerMapEntry(iClientH);
	Notify_ApocalypseGateState(iClientH); 

	if (m_astoria.get())
		SendNotifyMsg(NULL, iClientH, NOTIFY_EVENTSTART, m_astoria->GetEventType(), NULL, NULL, NULL);

	if(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone && !m_pClientList[iClientH]->IsGM()){
		bool toRecall = TRUE;
		std::list<RecentDisconnect>::iterator it = m_recentDCs.begin();
		for(; it != m_recentDCs.end(); it++){
			if(strcmp(it->playerName, player->m_cCharName) == 0) {
				DWORD dwTime = timeGetTime();  
				for(i = 0; i < 3; i++){
					if((dwTime - it->disconnectTimes[i]) < 18 _s){
						toRecall = FALSE;
						break;
					}
				}
				if(toRecall)
					m_recentDCs.erase(it);
				break;
			}
		}
		if(toRecall) {
			RequestTeleportHandler(iClientH, 0);
		}
	}

	return;
}

bool CGame::bReadProgramConfigFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, * token, cReadMode, cTxt[120], cGSMode[16] = "";
	char seps[] = "= \t\n", * urlDelimiter = "/";
	int webLen;
	
		char szHostName[255];
					gethostname(szHostName, 255);
					struct hostent *host_entry;
					host_entry=gethostbyname(szHostName);
					char * szLocalIP;
					int port = 5656;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		PutLogList("(ERROR) Cannot open configuration file.");
		return FALSE;
	}
	else {
		//PutLogList("(*) Reading configuration file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		StrTok pStrTok(new CStrTok(cp, seps));
		token = pStrTok->pGet();
		while( token != NULL )   {

			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					ZeroMemory(m_cServerName, sizeof(m_cServerName));
					if (strlen(token) > 10) {
						wsprintf(cTxt, "(!!!) Game server name(%s) must be within 10 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cServerName, token);
					wsprintf(cTxt, "(*) Game server name : %s", m_cServerName);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 2:
					m_iGameServerPort = atoi(token);
					wsprintf(cTxt, "(*) Game server port : %d", m_iGameServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 3:
					ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
					if (strlen(token) > 15) {
						wsprintf(cTxt, "(!!!) Log server address(%s) must be within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cLogServerAddr, token);
					wsprintf(cTxt, "(*) Log server address : %s", m_cLogServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 4:
					m_iLogServerPort = atoi(token);
					wsprintf(cTxt, "(*) Log server port : %d", m_iLogServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

						case 5:
					ZeroMemory(m_websiteAddr, sizeof(m_websiteAddr));
					ZeroMemory(m_websiteScriptAddr, sizeof(m_websiteScriptAddr));
					if (strlen(token) >= 120) {
						wsprintf(cTxt, "(!!!) Website script url(%s) must be within 120 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(cTxt, token);
					webLen = strcspn(token, urlDelimiter);
					if (webLen == NULL || webLen > 60 || (strlen(token) - webLen) > 60){
						wsprintf(cTxt, "(!!!) Website script url(%s) is incorrectly formed!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					memcpy(m_websiteAddr, token, webLen);
					memcpy(m_websiteScriptAddr, token + webLen, strlen(token) - webLen);
					wsprintf(cTxt, "(*) Website address : %s", m_websiteAddr);
					PutLogList(cTxt);
					wsprintf(cTxt, "(*) Website script address : %s", m_websiteScriptAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;	

				case 6:
					m_websitePort = atoi(token);
					wsprintf(cTxt, "(*) Website port : %d", m_websitePort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
					
				case 7:
					ZeroMemory(m_cLogServerAddrExternal, sizeof(m_cLogServerAddrExternal));
					if (strlen(token) > 15) {
						wsprintf(cTxt, "(!!!) Log server address(%s) must be within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cLogServerAddrExternal, token);
					wsprintf(cTxt, "(*) Log server External address : %s", m_cLogServerAddrExternal);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 8:
					ZeroMemory(m_cGameServerAddr, sizeof(m_cGameServerAddr));
					if (strlen(token) > 15) {
						wsprintf(cTxt, "(!!!) Game server address(%s) must be within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cGameServerAddr, token);
					wsprintf(cTxt, "(*) Game server address : %s", m_cGameServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 9:
					ZeroMemory(m_cGameServerAddrExternal, sizeof(m_cGameServerAddrExternal));
					if (strlen(token) > 15) 
					{	wsprintf(cTxt, "(!!!) External (Internet) Game server IP(%s) must within 15 chars!", token);
					PutLogList(cTxt);
					return FALSE;
					}
					strcpy(m_cGameServerAddrExternal, token);
					wsprintf(cTxt, "(*) Game server External IP : %s", m_cGameServerAddrExternal);
					PutLogList(cTxt);

				szLocalIP = inet_ntoa (*(struct in_addr *)*host_entry->h_addr_list);
					strcpy(m_cGameServerAddr, szLocalIP);
					m_iGateServerPort = port;

					wsprintf(cTxt, "(*) Gate server port : %d",m_iGateServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 10:
					ZeroMemory(WorldName, sizeof(WorldName));
					if (strlen(token) > 10) {
						wsprintf(cTxt, "(!!!) World server name(%s) must be within 10 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(WorldName, token);
					wsprintf(cTxt, "(*) World server name : %s", WorldName);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 11:
					if (strlen(token) > 10) {
						wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map name(%s) must be within 10 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					if (_bRegisterMap(token) == FALSE) {
						return FALSE;
					}
					cReadMode = 0;
					break;
		
				}
			}
			else {
				if (memcmp(token, "game-server-name", 16) == 0)			cReadMode = 1;
				
				if (memcmp(token, "game-server-port", 16) == 0)			cReadMode = 2;
				if (memcmp(token, "log-server-address", 18) == 0)		cReadMode = 3;
				if (memcmp(token, "log-server-port", 15) == 0)			cReadMode = 4;
				if (memcmp(token, "website-script-address", 22) == 0)	cReadMode = 5;
				if (memcmp(token, "website-port", 12) == 0)				cReadMode = 6;
				if (memcmp(token, "log-server-ext-address", 22) == 0)		cReadMode = 7;
				if (memcmp(token, "game-server-address", 19) == 0)		cReadMode = 8;
				if (memcmp(token, "game-server-ext-address", 23) == 0)	cReadMode = 9;
				if (memcmp(token, "world-server-name", 17) == 0)			cReadMode = 10;
				if (memcmp(token, "game-server-map", 15) == 0)			cReadMode = 11;
			}

			token = pStrTok->pGet();
		}

		delete[] cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}
BOOL CGame::bReadSettingsConfigFile(char * cFn) 
{ 
   FILE * pFile; 
   HANDLE hFile; 
   DWORD  dwFileSize; 
   char * cp, * token, cReadMode, cTxt[120], cGSMode[16] = "", len; 
   char seps[] = "= \t\n"; 
   class CStrTok * pStrTok; 

   cReadMode = 0; 

   hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
   dwFileSize = GetFileSize(hFile, NULL); 
   if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile); 

   pFile = fopen(cFn, "rt"); 
   if (pFile == NULL) { 
      //      . 
      //   PutLogList("(!) Cannot open configuration file."); 
      return FALSE; 
   } 
   else { 
     // PutLogList("(!) Reading settings file..."); 
      cp = new char[dwFileSize+2]; 
      ZeroMemory(cp, dwFileSize+2); 
      fread(cp, dwFileSize, 1, pFile); 

      pStrTok = new class CStrTok(cp, seps); 
      token = pStrTok->pGet(); 
      //token = strtok( cp, seps );    
      while( token != NULL )   { 

         if (cReadMode != 0) { 
            switch (cReadMode) { 

            case 1: 
               if ((strlen(token) != 0) && (strlen(token) <= 10000) && (strlen(token) >= 1)) 
               { 
                  m_iPrimaryDropRate = atoi(token); 
               } 
               else 
               { 
                  wsprintf(cTxt, "(!!!) Primary drop rate(%s) invalid must be between 1 to 10000", token); 
                  PutLogList(cTxt); 
               } 
               wsprintf(cTxt, "(*) Primary drop rate: (%d)", m_iPrimaryDropRate); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 2: 
               if ((strlen(token) != 0) && (strlen(token) <= 10000) && (strlen(token) >= 1)) 
               { 
                  m_iSecondaryDropRate = atoi(token); 
               } 
               else 
               { 
                  wsprintf(cTxt, "(!!!) Secondary drop rate(%s) invalid must be between 1 to 10000", token); 
                  PutLogList(cTxt); 
               } 
               wsprintf(cTxt, "(*) Secondary drop rate: (%d)", m_iSecondaryDropRate); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 3: 
               if ((strlen(token) != 0) && (strlen(token) <= 100) && (strlen(token) >= 1)) 
               { 
                  m_iEnemyKillAdjust = atoi(token); 
               } 
               else 
               { 
                  wsprintf(cTxt, "(!!!) ENEMY-KILL-ADJUST: (%s) invalid must be between 1 to 100", token); 
                  PutLogList(cTxt); 
               } 
               wsprintf(cTxt, "(*) Player gains (%d) EK per enemy kill.", m_iEnemyKillAdjust); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 4: 
               m_sRaidTimeMonday = atoi(token); 
               if (m_sRaidTimeMonday == 0) m_sRaidTimeMonday = 3; 
               wsprintf(cTxt, "(*) Monday Raid Time : (%d) minutes", m_sRaidTimeMonday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 5: 
               m_sRaidTimeTuesday = atoi(token); 
               if (m_sRaidTimeTuesday == 0) m_sRaidTimeTuesday = 3; 
               wsprintf(cTxt, "(*) Tuesday Raid Time : (%d) minutes", m_sRaidTimeTuesday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

			case 6: 
               m_sRaidTimeWednesday = atoi(token); 
               if (m_sRaidTimeWednesday == 0) m_sRaidTimeWednesday = 3; 
               wsprintf(cTxt, "(*) Wednesday Raid Time : (%d) minutes", m_sRaidTimeWednesday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 7: 
               m_sRaidTimeThursday = atoi(token); 
               if (m_sRaidTimeThursday == 0) m_sRaidTimeThursday = 3; 
               wsprintf(cTxt, "(*) Thursday Raid Time : (%d) minutes", m_sRaidTimeThursday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 8: 
               m_sRaidTimeFriday = atoi(token); 
               if (m_sRaidTimeFriday == 0) m_sRaidTimeFriday = 10; 
               wsprintf(cTxt, "(*) Friday Raid Time : (%d) minutes", m_sRaidTimeFriday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 9: 
               m_sRaidTimeSaturday = atoi(token); 
               if (m_sRaidTimeSaturday == 0) m_sRaidTimeSaturday = 45; 
               wsprintf(cTxt, "(*) Saturday Raid Time : (%d) minutes", m_sRaidTimeSaturday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 10: 
               m_sRaidTimeSunday = atoi(token); 
               if (m_sRaidTimeSunday == 0) m_sRaidTimeSunday = 60; 
               wsprintf(cTxt, "(*) Sunday Raid Time : (%d) minutes", m_sRaidTimeSunday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 
	

 
			case 11: 
               m_sSlateSuccessRate = atoi(token); 
               wsprintf(cTxt, "(*) Slate Success Rate (%d) percent", m_sSlateSuccessRate); 
               PutLogList(cTxt); 
			   if (m_sSlateSuccessRate == 0) m_sSlateSuccessRate = 14; 
               cReadMode = 0; 
               break;

			case 12: 
               m_sCharStatLimit = atoi(token); 
               if (m_sCharStatLimit == 0) m_sCharStatLimit = 200; 
               cReadMode = 0;
               break;

			case 13: 
               m_sCharSkillLimit = atoi(token); 
               if (m_sCharSkillLimit == 0) m_sCharSkillLimit = 700; 
               cReadMode = 0;
               break;

			case 14: 
               m_cRepDropModifier = atoi(token); 
               wsprintf(cTxt, "(*) Rep<->Drop modifier: (%d)", m_cRepDropModifier); 
               PutLogList(cTxt); 
               if (m_cRepDropModifier < 0) m_cRepDropModifier = 0;
               cReadMode = 0; 
               break;

			
			case 15: 
               m_sMaxPlayerLevel = atoi(token); 
			if (m_sMaxPlayerLevel >= 801) m_sMaxPlayerLevel = 800; 
               if (m_sMaxPlayerLevel == 0) m_sMaxPlayerLevel = 180; 
               cReadMode = 0;
               break;

		 case 16: 
               m_sExpModifier = atoi(token); 
               wsprintf(cTxt, "(*) Exp modifier: (%d)", m_sExpModifier); 
               PutLogList(cTxt); 
               if (m_sExpModifier < 0) m_sExpModifier = 0;
               cReadMode = 0; 
               break;
			
			}
         } 
         else { 
            if (memcmp(token, "primary-drop-rate"      , 17) == 0)   cReadMode = 1; 
            if (memcmp(token, "secondary-drop-rate"      , 19) == 0)   cReadMode = 2; 
             if (memcmp(token, "enemy-kill-adjust"      , 17) == 0)   cReadMode = 3; 
             if (memcmp(token, "monday-raid-time"      , 16) == 0)   cReadMode = 4; 
            if (memcmp(token, "tuesday-raid-time"      , 17) == 0)   cReadMode = 5; 
            if (memcmp(token, "wednesday-raid-time"      , 19) == 0)   cReadMode = 6; 
            if (memcmp(token, "thursday-raid-time"      , 18) == 0)   cReadMode = 7; 
            if (memcmp(token, "friday-raid-time"      , 16) == 0)   cReadMode = 8; 
            if (memcmp(token, "saturday-raid-time"      , 18) == 0)   cReadMode = 9; 
            if (memcmp(token, "sunday-raid-time"      , 16) == 0)   cReadMode = 10; 
			if (memcmp(token, "slate-success-rate", 18) == 0)		cReadMode = 11;
			if (memcmp(token, "character-stat-limit", 20) == 0)		cReadMode = 12;
			if (memcmp(token, "character-skill-limit", 21) == 0)		cReadMode = 13;
			if (memcmp(token, "rep-drop-modifier", 17) == 0)		cReadMode = 14;
			if (memcmp(token, "max-player-level", 16) == 0)		cReadMode = 15;
			if (memcmp(token, "exp-modifier", 12) == 0)		cReadMode = 16;
			
         } 

         token = pStrTok->pGet(); 
         //token = strtok( NULL, seps ); 
      } 

      delete pStrTok; 
      delete cp; 
   } 
   if (pFile != NULL) fclose(pFile); 

   return TRUE; 
} 

bool CGame::bReadCrusadeStructureConfigFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, * token, cReadModeA, cReadModeB;
	char seps[] = "= \t\n";
	int   iIndex;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		PutLogList("(ERROR) Cannot open Crusade Schedule file.");
		return FALSE;
	}
	else {
		//PutLogList("(*) Reading Crusade configuration file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		iIndex = 0;
		StrTok pStrTok(new CStrTok(cp, seps));
		token = pStrTok->pGet();
		while( token != NULL ) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
					switch (cReadModeB) {
					case 1:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format(1).");
							delete[] cp;
							return FALSE;
						}
						iIndex = atoi(token);

						if (m_stCrusadeStructures[iIndex].cType != NULL) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Duplicate Crusade number.");
							delete[] cp;
							return FALSE;
						}

						cReadModeB = 2;
						break;

					case 2:
						ZeroMemory(m_stCrusadeStructures[iIndex].cMapName, sizeof(m_stCrusadeStructures[iIndex].cMapName));
						memcpy(m_stCrusadeStructures[iIndex].cMapName, token, strlen(token));
						cReadModeB = 3;
						break;


					case 3:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete[] cp;
							return FALSE;
						}
						m_stCrusadeStructures[iIndex].cType = atoi(token);
						cReadModeB = 4;
						break;

					case 4:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete[] cp;
							return FALSE;
						}
						m_stCrusadeStructures[iIndex].dX = atoi(token);
						cReadModeB = 5;
						break;

					case 5:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete[] cp;
							return FALSE;
						}
						m_stCrusadeStructures[iIndex].dY = atoi(token);
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;
				case 2: 
					m_iMaxGMGMana = atoi(token); 
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				default: 
					break;
				}
			}
			else {
				if (memcmp(token, "crusade-structure", 17) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
				if (memcmp(token, "Mana-Stone", 10) == 0) {
					cReadModeA = 2;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}

		delete[] cp;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			PutLogList("(!!!) CRITICAL ERROR! Crusade Structure configuration file contents error!");
			return FALSE;
		}
	}

	if (pFile != NULL) fclose(pFile);
	return TRUE;
}



bool CGame::_bRegisterMap(char * pName)
{
	int i;
	char cTmpName[11], cTxt[120];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pName);
	for (i = 0; i < MAXMAPS; i++)
		if ((m_pMapList[i] != NULL) && (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) {
			wsprintf(cTxt, "(ERROR) CRITICAL ERROR! Map (%s) is already installed! cannot add.", cTmpName);
			PutLogList(cTxt);
			return FALSE;
		}

	for (i = 0; i < MAXMAPS; i++)
		if (m_pMapList[i] == NULL) {
			m_pMapList[i] = (class CMap *)new class CMap(this);
			//wsprintf(cTxt, "(*) Loading Map (%s)", pName);
			//PutLogList(cTxt);
			if (m_pMapList[i]->bInit(pName) == FALSE) {
				wsprintf(cTxt, "(ERROR) Data file %s loading fail!", pName);
				PutLogList(cTxt);
				return FALSE;
			}

		if ((m_iBtFieldMapIndex == -1) && (strcmp("BtField", pName) == 0))
			m_iBtFieldMapIndex = i;
		if ((m_iGodHMapIndex == -1) && (strcmp("GodH", pName) == 0)) m_iGodHMapIndex = i;

			if ((m_iMiddlelandMapIndex == -1) && (strcmp("middleland", pName) == 0)) 
				m_iMiddlelandMapIndex = i;
			else if ((m_iAresdenMapIndex == -1) && (strcmp(sideMap[ARESDEN], pName) == 0)) 
				m_iAresdenMapIndex = i;
			else if ((m_iElvineMapIndex == -1) && (strcmp(sideMap[ELVINE], pName) == 0)) 
				m_iElvineMapIndex = i;
			else if ((m_iIstriaMapIndex == -1) && (strcmp(sideMap[ISTRIA], pName) == 0)) 
				m_iIstriaMapIndex = i;
			else if ((m_iAstoriaMapIndex == -1) && (strcmp("astoria", pName) == 0)) 
				m_iAstoriaMapIndex = i;

				m_iGodHMapIndex = i;
//wsprintf(cTxt, "m_iBtFieldMapIndex (%d) ", m_iBtFieldMapIndex);
//	 PutLogList(cTxt);
			m_iTotalMaps++;
			return TRUE;
		}

	wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map (%s) canot be added - no more map space.", pName);
	PutLogList(cTxt);
	return FALSE;
}



bool CGame::_bDecodePlayerDatafileContents(int iClientH, char * pData, DWORD dwSize)
{
	int    i, iNotUsedItemPrice;
	char   cTxt[200], ItemName[25], OriginBlockDate[25];
	BYTE   NItems, NBankItems;
	DWORD  ItemCount;
	bool   IsItemEquipped;
	CItem * item;
	WORD   BankItemIndex, TotalSkillPoints, sTmpType, sTmpAppr1;
	static long charIndexEnd = 751;

	iNotUsedItemPrice = 0;
	//bGetOffsetValue = +1
	//wGetOffsetValue = +2
	//dwGetOffsetValue = +4
	if(m_pClientList[iClientH] == NULL) return FALSE;
	m_pClientList[iClientH]->m_dwCharID = dwGetOffsetValue(pData, 0);
	m_pClientList[iClientH]->m_sCharIDnum1 = (short)dwGetOffsetValue(pData, 4);
	m_pClientList[iClientH]->m_sCharIDnum2 = (short)dwGetOffsetValue(pData, 8);
	m_pClientList[iClientH]->m_sCharIDnum3 = (short)dwGetOffsetValue(pData, 12);
	m_pClientList[iClientH]->m_iLevel = wGetOffsetValue(pData, 16);
	m_pClientList[iClientH]->SetStr( bGetOffsetValue(pData, 18), false );
	m_pClientList[iClientH]->m_iVit = bGetOffsetValue(pData, 19);
	m_pClientList[iClientH]->SetDex( bGetOffsetValue(pData, 20) );
	m_pClientList[iClientH]->SetInt( bGetOffsetValue(pData, 21), false );
	m_pClientList[iClientH]->SetMag( bGetOffsetValue(pData, 22) );
	m_pClientList[iClientH]->m_iRange = bGetOffsetValue(pData, 23);
	m_pClientList[iClientH]->m_iLuck = bGetOffsetValue(pData, 24);
	m_pClientList[iClientH]->m_iExp = dwGetOffsetValue(pData, 25);
	m_pClientList[iClientH]->m_cSex = (Sex)bGetOffsetValue(pData, 29);
	m_pClientList[iClientH]->m_cSkin = bGetOffsetValue(pData, 30);
	m_pClientList[iClientH]->m_cHairStyle = bGetOffsetValue(pData, 31);
	m_pClientList[iClientH]->m_cHairColor = bGetOffsetValue(pData, 32);
	m_pClientList[iClientH]->m_cUnderwear = bGetOffsetValue(pData, 33);
	//m_pClientList[iClientH]->ApprColor = Retrive32DWordValue(cp, 34);
	//m_pClientList[iClientH]->Appr1 = Retrive16WordValue(cp, 38);
	//m_pClientList[iClientH]->Appr2 = Retrive16WordValue(cp, 42);
	//m_pClientList[iClientH]->Appr3 = Retrive16WordValue(cp, 46);
	//m_pClientList[iClientH]->Appr4 = Retrive16WordValue(cp, 50);
	ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
	SafeCopy(m_pClientList[iClientH]->m_cLocation, pData+54, 10);
	ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
	SafeCopy(m_pClientList[iClientH]->m_cMapName, pData+64, 10);
	m_pClientList[iClientH]->m_cMapIndex = (char) iGetMapIndex(m_pClientList[iClientH]->m_cMapName);
	if (m_pClientList[iClientH]->m_cMapIndex == -1)
	{
		wsprintf(cTxt, "(!) Player(%s) tries to enter unknown map : %s", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName);
		PutLogList(cTxt);
		return FALSE;
	}
	m_pClientList[iClientH]->m_sX = (short)wGetOffsetValue(pData, 74);
	m_pClientList[iClientH]->m_sY = (short)wGetOffsetValue(pData, 76);
	m_pClientList[iClientH]->m_iContribution = dwGetOffsetValue(pData, 78);
	m_pClientList[iClientH]->m_iSpecialAbilityTime = dwGetOffsetValue(pData, 82);
	ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
	SafeCopy(m_pClientList[iClientH]->m_cLockedMapName, pData+86, 10);
	m_pClientList[iClientH]->m_iLockedMapTime = dwGetOffsetValue(pData, 96);
	//LastSaveDate
	ZeroMemory(OriginBlockDate, sizeof(OriginBlockDate));
	SafeCopy(OriginBlockDate, pData+100, 20);
	char seps[] = " :-";
	StrTok pStrTok(new CStrTok(OriginBlockDate, seps));
	m_pClientList[iClientH]->m_iPenaltyBlockYear = atoi(pStrTok->pGet());
	m_pClientList[iClientH]->m_iPenaltyBlockMonth = atoi(pStrTok->pGet());
	m_pClientList[iClientH]->m_iPenaltyBlockDay = atoi(pStrTok->pGet());
	ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
	SafeCopy(m_pClientList[iClientH]->m_cGuildName, pData+120, 20);
	m_pClientList[iClientH]->m_iGuildGUID = (short)wGetOffsetValue(pData, 140);
	m_pClientList[iClientH]->m_iGuildRank = (signed char)bGetOffsetValue(pData, 142);
	m_pClientList[iClientH]->m_iFightzoneNumber = bGetOffsetValue(pData, 143);
	m_pClientList[iClientH]->m_iReserveTime = dwGetOffsetValue(pData, 144);
	m_pClientList[iClientH]->m_iFightZoneTicketNumber = bGetOffsetValue(pData, 148);
	m_pClientList[iClientH]->m_iQuest = wGetOffsetValue(pData, 149);
	m_pClientList[iClientH]->m_iQuestID = dwGetOffsetValue(pData, 151);
	m_pClientList[iClientH]->m_iCurQuestCount = wGetOffsetValue(pData, 155);
	m_pClientList[iClientH]->m_iQuestRewardType = (sWORD)wGetOffsetValue(pData, 157);
	m_pClientList[iClientH]->m_iQuestRewardAmount = dwGetOffsetValue(pData, 159);
	m_pClientList[iClientH]->m_bIsQuestCompleted = bGetOffsetValue(pData, 163) ? TRUE : FALSE;
	m_pClientList[iClientH]->m_iSpecialEventID = dwGetOffsetValue(pData, 164);
	m_pClientList[iClientH]->m_iWarContribution = dwGetOffsetValue(pData, 168);
	m_pClientList[iClientH]->m_iCrusadeDuty = bGetOffsetValue(pData, 172);
	m_pClientList[iClientH]->m_dwCrusadeGUID = dwGetOffsetValue(pData, 173);
	m_pClientList[iClientH]->m_iConstructionPoint = dwGetOffsetValue(pData, 177);
	m_pClientList[iClientH]->m_reputation = (int)dwGetOffsetValue(pData, 181);
	m_pClientList[iClientH]->m_iHP = dwGetOffsetValue(pData, 185);
	m_pClientList[iClientH]->m_iMP = dwGetOffsetValue(pData, 189);
	m_pClientList[iClientH]->m_iSP = dwGetOffsetValue(pData, 193);
	m_pClientList[iClientH]->m_iEnemyKillCount = dwGetOffsetValue(pData, 197);
	m_pClientList[iClientH]->m_iPKCount = (int)dwGetOffsetValue(pData, 201);
	m_pClientList[iClientH]->m_iRewardGold = dwGetOffsetValue(pData, 205);
	m_pClientList[iClientH]->m_iDownSkillIndex = (signed char)bGetOffsetValue(pData, 209);
	m_pClientList[iClientH]->m_iHungerStatus = bGetOffsetValue(pData, 210);
	m_pClientList[iClientH]->m_iSuperAttackLeft = wGetOffsetValue(pData, 211);
	m_pClientList[iClientH]->m_iTimeLeft_ShutUp = dwGetOffsetValue(pData, 213);
	m_pClientList[iClientH]->m_iTimeLeft_Rating = dwGetOffsetValue(pData, 217);
	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = dwGetOffsetValue(pData, 221);
	m_pClientList[iClientH]->m_iTimeLeft_FirmStamina = dwGetOffsetValue(pData, 225);
	m_pClientList[iClientH]->m_iDeadPenaltyTime = dwGetOffsetValue(pData, 229);
	m_pClientList[iClientH]->m_iPartyID = dwGetOffsetValue(pData, 233);
	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = wGetOffsetValue(pData, 237);
	m_pClientList[iClientH]->m_elo = wGetOffsetValue(pData, 239);
	//m_bIsBankModified +1
	m_pClientList[iClientH]->m_iAdminUserLevel = bGetOffsetValue(pData, 242);
	for (i = 0; i < MAXMAGICTYPE; i++) 
		m_pClientList[iClientH]->m_cMagicMastery[i] = bGetOffsetValue(pData, 243+i);
	ZeroMemory(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile));
	SafeCopy(m_pClientList[iClientH]->m_cProfile, pData+343, 255);

	for(BYTE b = 0; b < 10; b++)
	{
		m_pClientList[iClientH]->m_cSkillMastery[b] = bGetOffsetValue(pData, (598+b));//+55
		m_pClientList[iClientH]->m_iSkillSSN[b] = dwGetOffsetValue(pData, (653+(b*4)));//+100
	}

	for (i = 0; i < MAXITEMEQUIPPOS; i++) m_pClientList[iClientH]->m_sItemEquipmentStatus[i] = -1;
	for (i = 0; i < MAXITEMS; i++) m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
	NItems = bGetOffsetValue(pData, charIndexEnd);
	NBankItems = bGetOffsetValue(pData, (charIndexEnd+1 + (NItems*64)+1));
	if(NItems > MAXITEMS || NBankItems > MAXBANKITEMS) return FALSE;
	if(NItems > 0)

		for	(BYTE b = 0; b < NItems; b++) {
			WORD IndexForItem = (charIndexEnd+1 + (b*64));
			ZeroMemory(ItemName, sizeof(ItemName));
			SafeCopy(ItemName, pData+IndexForItem, 20);
			item = m_pClientList[iClientH]->m_pItemList[b] = new CItem;
			if(_bInitItemAttr(item, ItemName) == FALSE)
			{
				ZeroMemory(cTxt, sizeof(cTxt));
				wsprintf(cTxt, "(!!!) Client(%s)-Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, ItemName);
				PutLogFileList(cTxt, ERROR_LOGFILE);
				SAFEDELETE(m_pClientList[iClientH]->m_pItemList[b]);
				return FALSE;
			}
			ItemCount = dwGetOffsetValue(pData, (IndexForItem+20));
			if(ItemCount < 0) ItemCount = 1;
			if(iGetItemWeight(item, ItemCount) > _iCalcMaxLoad(iClientH) )
			{
				ItemCount = 1;
				ZeroMemory(cTxt, sizeof(cTxt));
				wsprintf(cTxt, "(!) Client(%s)-Item(%s) is too heavy.", m_pClientList[iClientH]->m_cCharName, item->m_cName);
				PutLogFileList(cTxt, ERROR_LOGFILE);
				SAFEDELETE(m_pClientList[iClientH]->m_pItemList[b]);
				return FALSE;
			}
			item->m_dwCount = ItemCount;
			item->m_sTouchEffectType = wGetOffsetValue(pData, (IndexForItem+24));
			item->m_sTouchEffectValue1 = (short)dwGetOffsetValue(pData, (IndexForItem+26));
			item->m_sTouchEffectValue2 = (short)dwGetOffsetValue(pData, (IndexForItem+30));
			item->m_sTouchEffectValue3 = (short)dwGetOffsetValue(pData, (IndexForItem+34));
			item->m_cItemColor = bGetOffsetValue(pData, (IndexForItem+38));
			item->m_sItemSpecEffectValue1 = (short)wGetOffsetValue(pData, (IndexForItem+39));
			item->m_sItemSpecEffectValue2 = (short)wGetOffsetValue(pData, (IndexForItem+41));
			item->m_sItemSpecEffectValue3 = (short)wGetOffsetValue(pData, (IndexForItem+43));
			item->m_wCurLifeSpan = wGetOffsetValue(pData, (IndexForItem+45));
			item->m_dwAttribute = dwGetOffsetValue(pData, (IndexForItem+47));
			if(item->m_sTouchEffectType == ITET_UNIQUE_OWNER)
			{
				if((item->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
					(item->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
					(item->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3) )
				{
					ZeroMemory(cTxt, sizeof(cTxt));
					wsprintf(cTxt,"(!) Player(%s) have Item(%s) with another owner ID-> [%d  %d  %d] - [%d  %d  %d]", m_pClientList[iClientH]->m_cCharName, item->m_cName,
						item->m_sTouchEffectValue1, item->m_sTouchEffectValue2,
						item->m_sTouchEffectValue3, m_pClientList[iClientH]->m_sCharIDnum1, m_pClientList[iClientH]->m_sCharIDnum2,
						m_pClientList[iClientH]->m_sCharIDnum3);
					PutLogList(cTxt);
				}
			}
			if((item->m_dwAttribute & 0x00000001 ) != NULL 
				&& item->m_sIDnum > 884 &&  item->m_sIDnum < 880) //Quick hack. TODO: Fix Endu for Magic jewels
				item->m_wMaxLifeSpan = item->m_sItemSpecEffectValue1;
			if (((item->m_dwAttribute & 0xF0000000) >> 28) > 0) {
				switch (item->m_cCategory) 
				{
				case 5:
				case 6: 
					item->m_wMaxLifeSpan = item->m_sItemSpecEffectValue1;
					break;
				}
			}
			item->AdjustByStat();

			if(item->m_wCurLifeSpan > item->m_wMaxLifeSpan) item->m_wCurLifeSpan = item->m_wMaxLifeSpan;
			if((item->m_wCurLifeSpan == 0) && (item->m_sItemEffectType == ITEMEFFECTTYPE_ALTERITEMDROP))
			{
				ZeroMemory(cTxt, sizeof(cTxt));
				wsprintf(cTxt, "(!) Player(%s) has a Zemstone with lifespan = 0!", m_pClientList[iClientH]->m_cCharName);
				PutLogFileList(cTxt, ERROR_LOGFILE);
				item->m_wCurLifeSpan = 1;
			}

			if (item->m_cItemType == ITEMTYPE_NOTUSED)
			{
				iNotUsedItemPrice += item->m_wPrice;
				SAFEDELETE(m_pClientList[iClientH]->m_pItemList[b]);
			}
			else if(_bCheckDupItemID(item) == TRUE)
			{
				_bItemLog(ITEMLOG_DUPITEMID, iClientH, NULL, item);
				iNotUsedItemPrice += item->m_wPrice;
				SAFEDELETE(m_pClientList[iClientH]->m_pItemList[b]);
			}
			if(m_pClientList[iClientH]->m_pItemList[b] != NULL)
			{
				IsItemEquipped = bGetOffsetValue(pData, (IndexForItem+51)) ? TRUE : FALSE;
				if(IsItemEquipped && item->m_cItemType == ITEMTYPE_EQUIP)
					m_pClientList[iClientH]->m_bIsItemEquipped[b] = TRUE;
			}
			if(m_pClientList[iClientH]->m_bIsItemEquipped[b] == TRUE && bEquipItemHandler(iClientH, b) == FALSE) m_pClientList[iClientH]->m_bIsItemEquipped[b] = FALSE;
			m_pClientList[iClientH]->m_ItemPosList[b].x = (int)wGetOffsetValue(pData, (IndexForItem+52));
			m_pClientList[iClientH]->m_ItemPosList[b].y = (int)wGetOffsetValue(pData, (IndexForItem+54));
			item->ItemUniqueID = ullGetOffsetValue(pData, (IndexForItem+56));
			if (m_pClientList[iClientH]->m_ItemPosList[b].y < -10) m_pClientList[iClientH]->m_ItemPosList[b].y = -10;
		}
		BankItemIndex = (charIndexEnd+1 + (NItems*64)+2);
		if(NBankItems > 0)
			for(BYTE b = 0; b < NBankItems; b++)
			{
				WORD IndexForItem = (BankItemIndex + (b*59));
				ZeroMemory(ItemName, sizeof(ItemName));
				SafeCopy(ItemName, pData+IndexForItem, 20);
				item = m_pClientList[iClientH]->m_pItemInBankList[b] = new CItem;
				if(_bInitItemAttr(item, ItemName) == FALSE)
				{
					ZeroMemory(cTxt, sizeof(cTxt));
					wsprintf(cTxt, "(!!!) Client(%s)-Bank Item(%s) is a non-existing item! Connection closed.", m_pClientList[iClientH]->m_cCharName, ItemName);
					PutLogFileList(cTxt, ERROR_LOGFILE);
					SAFEDELETE(m_pClientList[iClientH]->m_pItemInBankList[b]);
					return FALSE;
				}
				ItemCount = dwGetOffsetValue(pData, (IndexForItem+20));
				if(ItemCount < 0) ItemCount = 1;
				if(iGetItemWeight(item, ItemCount) > _iCalcMaxLoad(iClientH) ) //FIX: Break into smaller stacks possibly
				{
					ItemCount = 1;
					ZeroMemory(cTxt, sizeof(cTxt));
					wsprintf(cTxt, "(!) Client(%s)-BankItem(%s) is too heavy.", m_pClientList[iClientH]->m_cCharName, item->m_cName);
					PutLogFileList(cTxt, ERROR_LOGFILE);
					SAFEDELETE(m_pClientList[iClientH]->m_pItemInBankList[b]);
					return FALSE;
				}
				item->m_dwCount = ItemCount;
				item->m_sTouchEffectType = wGetOffsetValue(pData, (IndexForItem+24));
				item->m_sTouchEffectValue1 = (short)dwGetOffsetValue(pData, (IndexForItem+26));
				item->m_sTouchEffectValue2 = (short)dwGetOffsetValue(pData, (IndexForItem+30));
				item->m_sTouchEffectValue3 = (short)dwGetOffsetValue(pData, (IndexForItem+34));
				item->m_cItemColor = bGetOffsetValue(pData, (IndexForItem+38));
				item->m_sItemSpecEffectValue1 = (short)wGetOffsetValue(pData, (IndexForItem+39));
				item->m_sItemSpecEffectValue2 = (short)wGetOffsetValue(pData, (IndexForItem+41));
				item->m_sItemSpecEffectValue3 = (short)wGetOffsetValue(pData, (IndexForItem+43));
				item->m_wCurLifeSpan = wGetOffsetValue(pData, (IndexForItem+45));
				item->m_dwAttribute = dwGetOffsetValue(pData, (IndexForItem+47));
				item->ItemUniqueID = ullGetOffsetValue(pData, (IndexForItem+51));

				if((item->m_dwAttribute & 0x00000001) != NULL
					&& item->m_sIDnum > 884 &&  item->m_sIDnum < 880) //Quick hack. TODO: Fix Endu for Magic jewels
					item->m_wMaxLifeSpan = item->m_sItemSpecEffectValue1;

				int iValue = (item->m_dwAttribute & 0xF0000000) >> 28;
				if(iValue > 0)
				{
					switch (item->m_cCategory) {
					case 5:
					case 6:
						item->m_wMaxLifeSpan = item->m_sItemSpecEffectValue1;
						break;
					}
				}
				item->AdjustByStat();
				if(item->m_wCurLifeSpan > item->m_wMaxLifeSpan)
					item->m_wCurLifeSpan = item->m_wMaxLifeSpan;
				if((item->m_wCurLifeSpan == 0) && (item->m_sItemEffectType == ITEMEFFECTTYPE_ALTERITEMDROP))
				{
					ZeroMemory(cTxt, sizeof(cTxt));
					wsprintf(cTxt, "(!) Player(%s) has a Zemstone with lifespan = 0!", m_pClientList[iClientH]->m_cCharName);
					PutLogFileList(cTxt, ERROR_LOGFILE);
					item->m_wCurLifeSpan = 1;
				}
				if(item->m_cItemType == ITEMTYPE_NOTUSED)
				{
					iNotUsedItemPrice += item->m_wPrice;
					SAFEDELETE(m_pClientList[iClientH]->m_pItemInBankList[b]);
				}
				else if(_bCheckDupItemID(item) == TRUE)
				{
					_bItemLog(ITEMLOG_DUPITEMID, iClientH, NULL, item);
					iNotUsedItemPrice += item->m_wPrice;
					SAFEDELETE(m_pClientList[iClientH]->m_pItemInBankList[b]);
				}
			}

			bool bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bIsValidLoc(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			if(bRet == FALSE)
			{
				if ((m_pClientList[iClientH]->m_sX != -1) || (m_pClientList[iClientH]->m_sY != -1))
				{
					ZeroMemory(cTxt, sizeof(cTxt));
					wsprintf(cTxt, "Invalid location error! %s (%d, %d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
					PutLogFileList(cTxt, ERROR_LOGFILE);
					return FALSE;
				}
			}

			if(!m_pClientList[iClientH]->IsGM())
			{
				//if((m_pClientList[iClientH]->m_iLU_Pool < 0) || (m_pClientList[iClientH]->m_iLU_Pool > m_sCharStatLimit)) return FALSE;
				if((m_pClientList[iClientH]->GetBaseStr() < 10) || (m_pClientList[iClientH]->GetBaseStr() > m_sCharStatLimit)) return FALSE;
				if((m_pClientList[iClientH]->GetBaseDex() < 10) || (m_pClientList[iClientH]->GetBaseDex() > m_sCharStatLimit)) return FALSE;
				if((m_pClientList[iClientH]->m_iVit < 10) || (m_pClientList[iClientH]->m_iVit > m_sCharStatLimit)) return FALSE;
				if((m_pClientList[iClientH]->GetBaseInt() < 10) || (m_pClientList[iClientH]->GetBaseInt() > m_sCharStatLimit)) return FALSE;
				if((m_pClientList[iClientH]->GetBaseMag() < 10) || (m_pClientList[iClientH]->GetBaseMag() > m_sCharStatLimit)) return FALSE;
				if((m_pClientList[iClientH]->m_iRange < 10) || (m_pClientList[iClientH]->m_iRange > m_sCharStatLimit)) return FALSE;
				//if((m_pClientList[iClientH]->m_cAccountStatus != 2) && (m_pClientList[iClientH]->m_iLevel > LEVELLIMIT)) return FALSE;
			}
			if((m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cCharName) == FALSE) || (m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cAccountName) == FALSE)) return FALSE;
			if(m_pClientList[iClientH]->m_iPenaltyBlockYear != 0 && !IsDatePast(OriginBlockDate)) return FALSE;
			if(m_pClientList[iClientH]->m_iReserveTime != 0)
			{
				SYSTEMTIME SysTime;
				GetLocalTime(&SysTime);
				__int64 iDateSum1 = (__int64)m_pClientList[iClientH]->m_iReserveTime;
				__int64 iDateSum2 = (__int64)(SysTime.wMonth*10000 + SysTime.wDay*100 + SysTime.wHour);
				if(iDateSum2 >= iDateSum1)
				{
					SendNotifyMsg(NULL, i, NOTIFY_FIGHTZONERESERVE, -2, NULL, NULL, NULL);
					m_pClientList[iClientH]->m_iFightzoneNumber = 0;
					m_pClientList[iClientH]->m_iReserveTime = 0;
					m_pClientList[iClientH]->m_iFightZoneTicketNumber = 0;
				}
			}
			if(m_pClientList[iClientH]->m_iAdminUserLevel < 0) m_pClientList[iClientH]->m_iAdminUserLevel = 0;
			if(m_pClientList[iClientH]->m_cSex == MALE) sTmpType = 1;
			else if(m_pClientList[iClientH]->m_cSex == FEMALE) sTmpType = 4;
			switch (m_pClientList[iClientH]->m_cSkin) {
			case 1:
				break;
			case 2:
				sTmpType += 1;
				break;
			case 3:
				sTmpType += 2;
				break;
			}
			if(m_pClientList[iClientH]->m_iAdminUserLevel >= 10) sTmpType = m_pClientList[iClientH]->m_iAdminUserLevel;
			sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);

			m_pClientList[iClientH]->m_sType  = sTmpType;
			m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1;

			iCalcTotalWeight(iClientH);
			TotalSkillPoints = 0;
			for(int b = 0; b < 24; b++) TotalSkillPoints += m_pClientList[iClientH]->m_cSkillMastery[b];

			if (m_pClientList[iClientH]->m_sCharIDnum1 == 0) {
				int _i, _iTemp1, _iTemp2;
				short _sID1, _sID2, _sID3;

				_iTemp1 = 1;
				_iTemp2 = 1;
				for (_i = 0; _i < 10; _i++) {
					_iTemp1 += m_pClientList[iClientH]->m_cCharName[_i];
					_iTemp2 += abs(m_pClientList[iClientH]->m_cCharName[_i] ^ m_pClientList[iClientH]->m_cCharName[_i]);
				}

				_sID1 = (short)timeGetTime(); 
				_sID2 = (short)_iTemp1; 
				_sID3 = (short)_iTemp2;

				m_pClientList[iClientH]->m_sCharIDnum1 = _sID1;
				m_pClientList[iClientH]->m_sCharIDnum2 = _sID2;
				m_pClientList[iClientH]->m_sCharIDnum3 = _sID3;
			}

			m_pClientList[iClientH]->m_iRewardGold += iNotUsedItemPrice;
			if (IsSame(m_pClientList[iClientH]->m_cLocation, "NONE")) m_pClientList[iClientH]->m_bIsNeutral = TRUE;

			return TRUE;
}
//=============================================================================
int CGame::_iComposePlayerDataFileContents(int iClientH, char * pData)
{
	SYSTEMTIME SysTime;
	char  cTxt[30];
	int   i;
	BYTE  NItems, NBankItems;
	WORD  IndexForItem, Index;
	static long charIndexEnd = 751;

	if (m_pClientList[iClientH] == NULL) return 0;
	//char id +4
	PutOffsetValue(pData, 4, DWORDSIZE, m_pClientList[iClientH]->m_sCharIDnum1);
	PutOffsetValue(pData, 8, DWORDSIZE, m_pClientList[iClientH]->m_sCharIDnum2);
	PutOffsetValue(pData, 12, DWORDSIZE, m_pClientList[iClientH]->m_sCharIDnum3);
	PutOffsetValue(pData, 16, WORDSIZE, m_pClientList[iClientH]->m_iLevel);
	PutOffsetValue(pData, 18, BYTESIZE, m_pClientList[iClientH]->GetBaseStr());
	PutOffsetValue(pData, 19, BYTESIZE, m_pClientList[iClientH]->m_iVit);
	PutOffsetValue(pData, 20, BYTESIZE, m_pClientList[iClientH]->GetBaseDex());
	PutOffsetValue(pData, 21, BYTESIZE, m_pClientList[iClientH]->GetBaseInt());
	PutOffsetValue(pData, 22, BYTESIZE, m_pClientList[iClientH]->GetBaseMag());
	PutOffsetValue(pData, 23, BYTESIZE, m_pClientList[iClientH]->m_iRange);
	PutOffsetValue(pData, 24, BYTESIZE, m_pClientList[iClientH]->m_iLuck);
	PutOffsetValue(pData, 25, DWORDSIZE, m_pClientList[iClientH]->m_iExp);
	PutOffsetValue(pData, 29, BYTESIZE, m_pClientList[iClientH]->m_cSex);
	PutOffsetValue(pData, 30, BYTESIZE, m_pClientList[iClientH]->m_cSkin);
	PutOffsetValue(pData, 31, BYTESIZE, m_pClientList[iClientH]->m_cHairStyle);
	PutOffsetValue(pData, 32, BYTESIZE, m_pClientList[iClientH]->m_cHairColor);
	PutOffsetValue(pData, 33, BYTESIZE, m_pClientList[iClientH]->m_cUnderwear);

	PutOffsetValue(pData, 34, DWORDSIZE, m_pClientList[iClientH]->m_iApprColor);
	PutOffsetValue(pData, 38, DWORDSIZE, m_pClientList[iClientH]->m_sAppr1);
	PutOffsetValue(pData, 42, DWORDSIZE, m_pClientList[iClientH]->m_sAppr2);
	PutOffsetValue(pData, 46, DWORDSIZE, m_pClientList[iClientH]->m_sAppr3);
	PutOffsetValue(pData, 50, DWORDSIZE, m_pClientList[iClientH]->m_sAppr4);
	ZeroMemory(pData+54, 10);
	SafeCopy(pData+54, m_pClientList[iClientH]->m_cLocation);
	ZeroMemory(pData+64, 10);
	SafeCopy(pData+64, m_pClientList[iClientH]->m_cMapName);
	PutOffsetValue(pData, 74, WORDSIZE, m_pClientList[iClientH]->m_sX);
	PutOffsetValue(pData, 76, WORDSIZE, m_pClientList[iClientH]->m_sY);
	PutOffsetValue(pData, 78, DWORDSIZE, m_pClientList[iClientH]->m_iContribution);
	PutOffsetValue(pData, 82, DWORDSIZE, m_pClientList[iClientH]->m_iSpecialAbilityTime);
	ZeroMemory(pData+86, 10);
	SafeCopy(pData+86, m_pClientList[iClientH]->m_cLockedMapName);
	PutOffsetValue(pData, 96, DWORDSIZE, m_pClientList[iClientH]->m_iLockedMapTime);
	ZeroMemory(pData+100, 20);
	ZeroMemory(cTxt, sizeof(cTxt));
	wsprintf(cTxt, "%d-%d-%d 00:00:00", m_pClientList[iClientH]->m_iPenaltyBlockYear, m_pClientList[iClientH]->m_iPenaltyBlockMonth, m_pClientList[iClientH]->m_iPenaltyBlockDay);
	SafeCopy(pData+100, cTxt);
	ZeroMemory(pData+120, 20);
	if (m_pClientList[iClientH]->m_iGuildRank != -1)
	{
		SafeCopy(pData+120, m_pClientList[iClientH]->m_cGuildName);
		PutOffsetValue(pData, 140, WORDSIZE, m_pClientList[iClientH]->m_iGuildGUID);
	}
	else
	{
		SafeCopy(pData+120, "NONE");
		PutOffsetValue(pData, 140, WORDSIZE, -1);
	}
	PutOffsetValue(pData, 142, WORDSIZE, m_pClientList[iClientH]->m_iGuildRank);
	PutOffsetValue(pData, 143, BYTESIZE, m_pClientList[iClientH]->m_iFightzoneNumber);
	PutOffsetValue(pData, 144, DWORDSIZE, m_pClientList[iClientH]->m_iReserveTime);
	PutOffsetValue(pData, 148, BYTESIZE, m_pClientList[iClientH]->m_iFightZoneTicketNumber);
	PutOffsetValue(pData, 149, WORDSIZE, m_pClientList[iClientH]->m_iQuest);
	PutOffsetValue(pData, 151, WORDSIZE, m_pClientList[iClientH]->m_iQuestID);
	PutOffsetValue(pData, 155, WORDSIZE, m_pClientList[iClientH]->m_iCurQuestCount);
	PutOffsetValue(pData, 157, WORDSIZE, m_pClientList[iClientH]->m_iQuestRewardType);
	PutOffsetValue(pData, 159, DWORDSIZE, m_pClientList[iClientH]->m_iQuestRewardAmount);
	PutOffsetValue(pData, 163, BYTESIZE, m_pClientList[iClientH]->m_bIsQuestCompleted);
	PutOffsetValue(pData, 164, DWORDSIZE, m_pClientList[iClientH]->m_iSpecialEventID);
	PutOffsetValue(pData, 168, DWORDSIZE, m_pClientList[iClientH]->m_iWarContribution);
	PutOffsetValue(pData, 172, BYTESIZE, m_pClientList[iClientH]->m_iCrusadeDuty);
	PutOffsetValue(pData, 173, DWORDSIZE, m_pClientList[iClientH]->m_dwCrusadeGUID);
	PutOffsetValue(pData, 177, DWORDSIZE, m_pClientList[iClientH]->m_iConstructionPoint);
	PutOffsetValue(pData, 181, DWORDSIZE, m_pClientList[iClientH]->m_reputation);
	if(m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = m_pClientList[iClientH]->GetMaxHP();
	PutOffsetValue(pData, 185, DWORDSIZE, m_pClientList[iClientH]->m_iHP);
	if(m_pClientList[iClientH]->m_iMP <= 0) m_pClientList[iClientH]->m_iMP = 30;
	PutOffsetValue(pData, 189, DWORDSIZE, m_pClientList[iClientH]->m_iMP);
	if(m_pClientList[iClientH]->m_iSP < 0) m_pClientList[iClientH]->m_iSP = 20;
	PutOffsetValue(pData, 193, DWORDSIZE, m_pClientList[iClientH]->m_iSP);
	PutOffsetValue(pData, 197, DWORDSIZE, m_pClientList[iClientH]->m_iEnemyKillCount);
	PutOffsetValue(pData, 201, DWORDSIZE, m_pClientList[iClientH]->m_iPKCount);
	PutOffsetValue(pData, 205, DWORDSIZE, m_pClientList[iClientH]->m_iRewardGold);
	PutOffsetValue(pData, 209, BYTESIZE, m_pClientList[iClientH]->m_iDownSkillIndex);
	PutOffsetValue(pData, 210, BYTESIZE, m_pClientList[iClientH]->m_iHungerStatus);
	PutOffsetValue(pData, 211, WORDSIZE, m_pClientList[iClientH]->m_iSuperAttackLeft);
	PutOffsetValue(pData, 213, DWORDSIZE, m_pClientList[iClientH]->m_iTimeLeft_ShutUp);
	PutOffsetValue(pData, 217, DWORDSIZE, m_pClientList[iClientH]->m_iTimeLeft_Rating);
	PutOffsetValue(pData, 221, DWORDSIZE, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall);
	PutOffsetValue(pData, 225, DWORDSIZE, m_pClientList[iClientH]->m_iTimeLeft_FirmStamina);
	PutOffsetValue(pData, 229, DWORDSIZE, m_pClientList[iClientH]->m_iDeadPenaltyTime);
	PutOffsetValue(pData, 233, DWORDSIZE, m_pClientList[iClientH]->m_iPartyID);
	PutOffsetValue(pData, 237, WORDSIZE, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft);
	PutOffsetValue(pData, 239, WORDSIZE, m_pClientList[iClientH]->m_elo);
	PutOffsetValue(pData, 241, BYTESIZE, m_pClientList[iClientH]->m_bIsBankModified);
	//adminlevel +1
	for (i = 0; i < MAXMAGICTYPE; i++) 
		PutOffsetValue(pData, 243+i, BYTESIZE, m_pClientList[iClientH]->m_cMagicMastery[i]);//+48
	if(strlen(m_pClientList[iClientH]->m_cProfile) == 0){
		SafeCopy(pData+343, "__________");
		//return (Index+12);
	}
	else{
		SafeCopy(pData+343, m_pClientList[iClientH]->m_cProfile);
		//return (Index+2+strlen(m_pClientList[iClientH]->m_cProfile)+1);
	}  

	for (i = 0; i < 10; i++){
		PutOffsetValue(pData, 598+i, BYTESIZE, m_pClientList[iClientH]->m_cSkillMastery[i]);
		PutOffsetValue(pData, 653+(i*4),DWORDSIZE, m_pClientList[iClientH]->m_iSkillSSN[i]);
	}

	NItems = 0;
	NBankItems = 0;

	for(i = 0; i < MAXITEMS; i++)
		if(m_pClientList[iClientH]->m_pItemList[i] != NULL){
			IndexForItem = (charIndexEnd+1 + (NItems*64));
			ZeroMemory(pData+IndexForItem, 20);
			SafeCopy(pData+IndexForItem, m_pClientList[iClientH]->m_pItemList[i]->m_cName);
			PutOffsetValue(pData, (IndexForItem+20), DWORDSIZE, m_pClientList[iClientH]->m_pItemList[i]->m_dwCount);
			PutOffsetValue(pData, (IndexForItem+24), WORDSIZE, m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType);
			PutOffsetValue(pData, (IndexForItem+26), DWORDSIZE, m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1);
			PutOffsetValue(pData, (IndexForItem+30), DWORDSIZE, m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2);
			PutOffsetValue(pData, (IndexForItem+34), DWORDSIZE, m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3);
			PutOffsetValue(pData, (IndexForItem+38), BYTESIZE, m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor);
			PutOffsetValue(pData, (IndexForItem+39), WORDSIZE, m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue1);
			PutOffsetValue(pData, (IndexForItem+41), WORDSIZE, m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2);
			PutOffsetValue(pData, (IndexForItem+43), WORDSIZE, m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue3);
			PutOffsetValue(pData, (IndexForItem+45), WORDSIZE, m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan);
			PutOffsetValue(pData, (IndexForItem+47), DWORDSIZE, m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute);
			PutOffsetValue(pData, (IndexForItem+51), BYTESIZE, m_pClientList[iClientH]->m_bIsItemEquipped[i]);
			PutOffsetValue(pData, (IndexForItem+52), WORDSIZE, m_pClientList[iClientH]->m_ItemPosList[i].x);
			PutOffsetValue(pData, (IndexForItem+54), WORDSIZE, m_pClientList[iClientH]->m_ItemPosList[i].y);
			PutOffsetValue(pData, (IndexForItem+56), I64SIZE, m_pClientList[iClientH]->m_pItemList[i]->ItemUniqueID);
			NItems++;
		}
		PutOffsetValue(pData, charIndexEnd, BYTESIZE, NItems);

		Index = charIndexEnd+1+(NItems*64);
		if(m_pClientList[iClientH]->m_bIsBankModified)
			for(i = 0; i < MAXBANKITEMS; i++)
				if(m_pClientList[iClientH]->m_pItemInBankList[i] != NULL){
					IndexForItem = (Index+1+(NBankItems*59));
					ZeroMemory(pData+IndexForItem, 20);
					SafeCopy(pData+IndexForItem, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName);
					PutOffsetValue(pData, (IndexForItem+20), DWORDSIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount);
					PutOffsetValue(pData, (IndexForItem+24), WORDSIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectType);
					PutOffsetValue(pData, (IndexForItem+26), DWORDSIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue1);
					PutOffsetValue(pData, (IndexForItem+30), DWORDSIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue2);
					PutOffsetValue(pData, (IndexForItem+34), DWORDSIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue3);
					PutOffsetValue(pData, (IndexForItem+38), BYTESIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor);
					PutOffsetValue(pData, (IndexForItem+39), WORDSIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue1);
					PutOffsetValue(pData, (IndexForItem+41), WORDSIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2);
					PutOffsetValue(pData, (IndexForItem+43), WORDSIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue3);
					PutOffsetValue(pData, (IndexForItem+45), WORDSIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan);
					PutOffsetValue(pData, (IndexForItem+47), DWORDSIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute);
					PutOffsetValue(pData, (IndexForItem+51), I64SIZE, m_pClientList[iClientH]->m_pItemInBankList[i]->ItemUniqueID);
					NBankItems++;
				}
				PutOffsetValue(pData, Index, BYTESIZE, NBankItems);
				return (Index);                                                      
}
//=============================================================================
bool CGame::_bDecodeItemConfigFileContents(char * pData, DWORD dwMsgSize)
{
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iItemConfigListIndex, iTemp;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();

	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) 
			{
			case 1:
				switch (cReadModeB) 
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemIDnumber");
						delete[] pContents;
						return FALSE;
					}
					iItemConfigListIndex = atoi(token);

					if (m_pItemConfigList[iItemConfigListIndex] != NULL) {
						wsprintf(cTxt, "(!!!) CRITICAL ERROR! Duplicate ItemIDnum(%d)", iItemConfigListIndex);
						PutLogList(cTxt);
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex] = new class CItem;
					m_pItemConfigList[iItemConfigListIndex]->m_sIDnum = iItemConfigListIndex;
					cReadModeB++;
					break;
				case 2:
					// m_cName 
					ZeroMemory(m_pItemConfigList[iItemConfigListIndex]->m_cName, sizeof(m_pItemConfigList[iItemConfigListIndex]->m_cName));
					memcpy(m_pItemConfigList[iItemConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB++;
					break;
				case 3:
					// m_cItemType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemType");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cItemType = atoi(token);
					cReadModeB++;
					break;
				case 4:
					// m_cEquipPos
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - EquipPos");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cEquipPos = atoi(token);
					cReadModeB++;
					break;
				case 5:
					// m_sItemEffectType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectType");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectType = atoi(token);
					cReadModeB++;
					break;
				case 6:
					// m_sItemEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue1");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue1 = atoi(token);
					cReadModeB++;
					break;
				case 7:
					// m_sItemEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue2");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue2 = atoi(token);
					cReadModeB++;
					break;
				case 8:
					// m_sItemEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue3");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue3 = atoi(token);
					cReadModeB++;
					break;
				case 9:
					// m_sItemEffectValue4
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue4");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue4 = atoi(token);
					cReadModeB++;
					break;
				case 10:
					// m_sItemEffectValue5
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue5");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue5 = atoi(token);
					cReadModeB++;
					break;
				case 11:
					// m_sItemEffectValue6
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue6");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue6 = atoi(token);
					cReadModeB++;
					break;
				case 12:
					// m_wMaxLifeSpan
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxLifeSpan");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_wMaxLifeSpan = (WORD)atoi(token);
					cReadModeB++;
					break;
				case 13:
					// m_sSpecialEffect
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxFixCount");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffect = atoi(token);
					cReadModeB++;
					break;
				case 14:
					// m_sSprite
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Sprite");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSprite = atoi(token);
					cReadModeB++;
					break;
				case 15:
					// m_sSpriteFrame
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SpriteFrame");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpriteFrame = atoi(token);
					cReadModeB++;
					break;
				case 16:
					// m_wPrice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Price");
						delete[] pContents;
						return FALSE;
					}
					iTemp = atoi(token);
					if (iTemp < 0) 
						m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = FALSE;
					else m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = TRUE;

					m_pItemConfigList[iItemConfigListIndex]->m_wPrice = abs(iTemp);
					cReadModeB++;
					break;
				case 17:
					// m_wWeight
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Weight");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_wWeight = atoi(token);
					cReadModeB++;
					break;
				case 18:
					// Appr Value
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ApprValue");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cApprValue = atoi(token);
					cReadModeB++;
					break;
				case 19:
					// m_cSpeed
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Speed");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cSpeed = atoi(token);
					cReadModeB++;
					break;

				case 20:
					// m_sLevelLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - LevelLimit");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sLevelLimit = atoi(token);
					cReadModeB++;
					break;

				case 21:
					// m_cGederLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - GenderLimit");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cGenderLimit = atoi(token);
					cReadModeB++;
					break;

				case 22:
					// m_sSpecialEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SM_HitRatio");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue1 = atoi(token);
					cReadModeB++; 
					break;

				case 23:
					// m_sSpecialEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - L_HitRatio");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue2 = atoi(token);
					cReadModeB++;
					break;

				case 24:
					// m_sRelatedSkill
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - RelatedSkill");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sRelatedSkill = atoi(token);
					cReadModeB++;
					break;

				case 25:
					// m_cCategory
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cCategory = atoi(token);
					cReadModeB++;
					break;

				case 26:
					// m_cItemColor
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
						delete[] pContents;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cItemColor = atoi(token);
					//cReadModeB++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				//case 27:
				//	// m_isLogged		
				///*	if( strcmp(token,"FALSE") == 0 )
				//		m_pItemConfigList[iItemConfigListIndex]->m_isLogged = FALSE;
				//	else if( strcmp(token,"TRUE") == 0 )
				//		m_pItemConfigList[iItemConfigListIndex]->m_isLogged = TRUE;
				//	else*/
				//	if( strcmp(token,"TRUE") == 0 ) 
				//		m_pItemConfigList[iItemConfigListIndex]->m_isLogged = TRUE;
				//	else
				//	{
				//		m_pItemConfigList[iItemConfigListIndex]->m_isLogged = FALSE;
				//		/*PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Is logged");
				//		delete[] pContents;
				//		return FALSE;*/
				//	}
				//	cReadModeA = 0;
				//	cReadModeB = 0;
				//	break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "Item", 4) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}

			if (memcmp(token, "[ENDITEMLIST]", 13) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto DICFC_STOPDECODING;
			}
		}
		token = pStrTok->pGet();
		//token = strtok( NULL, seps );
	}

DICFC_STOPDECODING:;

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(ERROR) CRITICAL ERROR! ITEM configuration file contents error!");
		return FALSE;
	}

	//wsprintf(cTxt, "(!) ITEM(Total:%d) configuration - success!", iItemConfigListIndex);
	//PutLogList(cTxt);

	// 2002-09-09 #1
	m_bReceivedItemList = true;

	return TRUE;
}


bool CGame::_bInitItemAttr(class CItem * pItem, char * pItemName)
{
	register int i;
	char cTmpName[22];

	if (strlen(pItemName) > 21) return false;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	for (i = 0; i < MAXITEMTYPES; i++) 
		if (m_pItemConfigList[i] != NULL) {
			if (memcmp(cTmpName, m_pItemConfigList[i]->m_cName, 20) == 0) {

				ZeroMemory(pItem->m_cName, sizeof(pItem->m_cName));
				strcpy(pItem->m_cName, m_pItemConfigList[i]->m_cName);
				pItem->m_cItemType         = m_pItemConfigList[i]->m_cItemType;
				pItem->m_cEquipPos         = m_pItemConfigList[i]->m_cEquipPos;
				pItem->m_sItemEffectType   = m_pItemConfigList[i]->m_sItemEffectType;
				pItem->m_sItemEffectValue1 = m_pItemConfigList[i]->m_sItemEffectValue1;
				pItem->m_sItemEffectValue2 = m_pItemConfigList[i]->m_sItemEffectValue2;
				pItem->m_sItemEffectValue3 = m_pItemConfigList[i]->m_sItemEffectValue3;
				pItem->m_sItemEffectValue4 = m_pItemConfigList[i]->m_sItemEffectValue4;
				pItem->m_sItemEffectValue5 = m_pItemConfigList[i]->m_sItemEffectValue5;
				pItem->m_sItemEffectValue6 = m_pItemConfigList[i]->m_sItemEffectValue6;
				pItem->m_wMaxLifeSpan      = m_pItemConfigList[i]->m_wMaxLifeSpan;
				pItem->m_wCurLifeSpan	   = pItem->m_wMaxLifeSpan;
				pItem->m_sSpecialEffect    = m_pItemConfigList[i]->m_sSpecialEffect;

				pItem->m_sSprite           = m_pItemConfigList[i]->m_sSprite;
				pItem->m_sSpriteFrame      = m_pItemConfigList[i]->m_sSpriteFrame;
				pItem->m_wPrice            = m_pItemConfigList[i]->m_wPrice;
				pItem->m_wWeight           = m_pItemConfigList[i]->m_wWeight;
				pItem->m_cApprValue        = m_pItemConfigList[i]->m_cApprValue;
				pItem->m_cSpeed            = m_pItemConfigList[i]->m_cSpeed;
				pItem->m_sLevelLimit       = m_pItemConfigList[i]->m_sLevelLimit;
				pItem->m_cGenderLimit      = m_pItemConfigList[i]->m_cGenderLimit;

				pItem->m_sSpecialEffectValue1 = m_pItemConfigList[i]->m_sSpecialEffectValue1;
				pItem->m_sSpecialEffectValue2 = m_pItemConfigList[i]->m_sSpecialEffectValue2;

				pItem->m_sRelatedSkill     = m_pItemConfigList[i]->m_sRelatedSkill;
				pItem->m_cCategory         = m_pItemConfigList[i]->m_cCategory;
				pItem->m_sIDnum			   = m_pItemConfigList[i]->m_sIDnum;

				pItem->m_bIsForSale	       = m_pItemConfigList[i]->m_bIsForSale;
				pItem->m_cItemColor        = m_pItemConfigList[i]->m_cItemColor;
				pItem->m_isLogged			= m_pItemConfigList[i]->m_isLogged;
				return TRUE;
			}
		}


		return FALSE;
}


bool CGame::_bInitItemAttr(class CItem * pItem, int iItemID)
{
	register int i;
	char cTmpName[21];

	if(iItemID == ITEM_NONE || iItemID == ITEM_INVALID)
		return FALSE;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	//strcpy(cTmpName, pItemName);

	for (i = 0; i < MAXITEMTYPES; i++) 
		if (m_pItemConfigList[i] != NULL) {
			if (iItemID ==  m_pItemConfigList[i]->m_sIDnum) {

				ZeroMemory(pItem->m_cName, sizeof(pItem->m_cName));
				strcpy(pItem->m_cName, m_pItemConfigList[i]->m_cName);
				pItem->m_cItemType         = m_pItemConfigList[i]->m_cItemType;
				pItem->m_cEquipPos         = m_pItemConfigList[i]->m_cEquipPos;
				pItem->m_sItemEffectType   = m_pItemConfigList[i]->m_sItemEffectType;
				pItem->m_sItemEffectValue1 = m_pItemConfigList[i]->m_sItemEffectValue1;
				pItem->m_sItemEffectValue2 = m_pItemConfigList[i]->m_sItemEffectValue2;
				pItem->m_sItemEffectValue3 = m_pItemConfigList[i]->m_sItemEffectValue3;
				pItem->m_sItemEffectValue4 = m_pItemConfigList[i]->m_sItemEffectValue4;
				pItem->m_sItemEffectValue5 = m_pItemConfigList[i]->m_sItemEffectValue5;
				pItem->m_sItemEffectValue6 = m_pItemConfigList[i]->m_sItemEffectValue6;
				pItem->m_wMaxLifeSpan      = m_pItemConfigList[i]->m_wMaxLifeSpan;
				pItem->m_wCurLifeSpan	   = pItem->m_wMaxLifeSpan;
				pItem->m_sSpecialEffect    = m_pItemConfigList[i]->m_sSpecialEffect;

				pItem->m_sSprite           = m_pItemConfigList[i]->m_sSprite;
				pItem->m_sSpriteFrame      = m_pItemConfigList[i]->m_sSpriteFrame;
				pItem->m_wPrice            = m_pItemConfigList[i]->m_wPrice;
				pItem->m_wWeight           = m_pItemConfigList[i]->m_wWeight;
				pItem->m_cApprValue        = m_pItemConfigList[i]->m_cApprValue;
				pItem->m_cSpeed            = m_pItemConfigList[i]->m_cSpeed;
				pItem->m_sLevelLimit       = m_pItemConfigList[i]->m_sLevelLimit;
				pItem->m_cGenderLimit      = m_pItemConfigList[i]->m_cGenderLimit;

				pItem->m_sSpecialEffectValue1 = m_pItemConfigList[i]->m_sSpecialEffectValue1;
				pItem->m_sSpecialEffectValue2 = m_pItemConfigList[i]->m_sSpecialEffectValue2;

				pItem->m_sRelatedSkill     = m_pItemConfigList[i]->m_sRelatedSkill;
				pItem->m_cCategory         = m_pItemConfigList[i]->m_cCategory;
				pItem->m_sIDnum			   = m_pItemConfigList[i]->m_sIDnum;

				pItem->m_bIsForSale	       = m_pItemConfigList[i]->m_bIsForSale;
				pItem->m_cItemColor        = m_pItemConfigList[i]->m_cItemColor;
				pItem->m_isLogged			= m_pItemConfigList[i]->m_isLogged;
				return TRUE;
			}
		}


		return FALSE;
}



bool CGame::_bGetIsStringIsNumber(char * pStr)
{
	int i;
	for (i = 0; i < (int)strlen(pStr); i++)
		if ((pStr[i] != '-') && ((pStr[i] < (char)'0') || (pStr[i] > (char)'9'))) return FALSE;

	return TRUE;
}

bool CGame::bSetNpcFollowMode(char * pName, char * pFollowName, char cFollowOwnerType)
{
	register int i, iIndex, iMapIndex, iFollowIndex;
	char cTmpName[11], cFollowSide;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	iMapIndex    = -1;
	iFollowIndex = -1;

	for (i = 1; i < MAXNPCS; i++)
		if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, pName, 5) == 0) ) {
			iIndex = i;
			iMapIndex = m_pNpcList[i]->m_cMapIndex;
			break;
		}

		switch (cFollowOwnerType) {
		case OWNERTYPE_NPC:
			for (i = 1; i < MAXNPCS; i++)
				if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, pFollowName, 5) == 0) ) {
					if (m_pNpcList[i]->m_cMapIndex != iMapIndex) return FALSE;
					iFollowIndex = i;
					cFollowSide = m_pNpcList[i]->m_side;
					break;
				}
				break;

		case OWNERTYPE_PLAYER:
			for (i = 1; i < MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pFollowName, 10) == 0) ) {
					if (m_pClientList[i]->m_cMapIndex != iMapIndex) return FALSE;
					iFollowIndex = i;
					cFollowSide = m_pClientList[i]->m_side;
					break;
				}
			break;
		}

		if ((iIndex == -1) || (iFollowIndex == -1)) return FALSE;

		m_pNpcList[iIndex]->m_cMoveType = MOVETYPE_FOLLOW;
		m_pNpcList[iIndex]->m_cFollowOwnerType  = cFollowOwnerType;
		m_pNpcList[iIndex]->m_iFollowOwnerIndex = iFollowIndex;
		m_pNpcList[iIndex]->m_side             = cFollowSide;

		return TRUE;
}


bool CGame::bCreateNewNpc(char * pNpcName, char * pName, char * pMapName, char cSA, char cMoveType, int * poX, int * poY, char * pWaypointList, RECT * pArea, int iSpotMobIndex, char cChangeSide, bool bHideGenMode, bool bIsSummoned, bool bFirmBerserk, bool bIsMaster, int iGuildGUID)
{
	register int i, t, j, k, iMapIndex;
	char  cTmpName[11], cTxt[120];
	short sX, sY, sRange;
	bool  bFlag;
	SYSTEMTIME SysTime;

	if (strlen(pName) == 0)   return FALSE;
	if (strlen(pNpcName) == 0) return FALSE;

	GetLocalTime(&SysTime);

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMapName);
	iMapIndex = -1;

	for (i = 0; i < MAXMAPS; i++)
		if (m_pMapList[i] != NULL) {
			if (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0) 
				iMapIndex = i;
		}

		if (iMapIndex == -1) return FALSE;

		for (i = 1; i < MAXNPCS; i++)
			if (m_pNpcList[i] == NULL) {
				m_pNpcList[i] = new class CNpc(pName, i);

				if (!m_pNpcList[i]->initNpcAttr(pNpcName, cSA) )
				{
					wsprintf(cTxt, "(!) Not existing NPC creation request! (%s) Ignored.", pNpcName);
					PutLogList(cTxt);

					delete m_pNpcList[i];
					m_pNpcList[i] = NULL;
					return FALSE;
				}

				if (m_pNpcList[i]->m_cDayOfWeekLimit < 10) {
					if (m_pNpcList[i]->m_cDayOfWeekLimit != SysTime.wDayOfWeek) {
						delete m_pNpcList[i];
						m_pNpcList[i] = NULL;
						return FALSE;
					}
				}

				switch (cMoveType) {
				case MOVETYPE_GUARD:
				case MOVETYPE_RANDOM:
					if ( (poX != NULL) && (poY != NULL) && (*poX != NULL) && (*poY != NULL) ) {
						sX = *poX;
						sY = *poY;
					}
					else {
						for ( j = 0; j <= 30; j++) {
							sX = (rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15;
							sY = (rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15;

							bFlag = TRUE;
							for (k = 0; k < MAXMGAR; k++)
								if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].left != -1) {
									if ((sX >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].left) &&
										(sX <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].right) &&
										(sY >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].top) &&
										(sY <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].bottom)) {
											bFlag = FALSE;
									}
								}
								if (bFlag == TRUE) goto GET_VALIDLOC_SUCCESS;

						}

						delete m_pNpcList[i];
						m_pNpcList[i] = NULL;
						return FALSE;

GET_VALIDLOC_SUCCESS:;
					}
					break;

				case MOVETYPE_RANDOMAREA:
					sRange = (short)(pArea->right - pArea->left);
					sX     = (short)((rand() % sRange) + pArea->left);
					sRange = (short)(pArea->bottom - pArea->top);
					sY     = (short)((rand() % sRange) + pArea->top);
					break;

				case MOVETYPE_RANDOMWAYPOINT:
					sX = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[dice(1,10) - 1]].x;
					sY = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[dice(1,10) - 1]].y;
					break;

				default:
					if ( (poX != NULL) && (poY != NULL) && (*poX != NULL) && (*poY != NULL) ) {
						sX = *poX;
						sY = *poY;
					}
					else {
						sX = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[0]].x;
						sY = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[0]].y;
					}
					break;
				}

				if (!bGetEmptyPosition(&sX, &sY, iMapIndex) || 
					(bHideGenMode && getPlayerNum(iMapIndex, sX, sY, 7) > 0)) 
				{
					delete m_pNpcList[i];
					m_pNpcList[i] = NULL;
					return FALSE;
				}

				if ((poX != NULL) && (poY != NULL)) {
					*poX = sX;
					*poY = sY;
				}

				m_pNpcList[i]->m_sX = sX;
				m_pNpcList[i]->m_sY = sY;

				m_pNpcList[i]->m_vX = sX;
				m_pNpcList[i]->m_vY = sY;

				for (t = 0; t < 10; t++)
					m_pNpcList[i]->m_iWayPointIndex[t] = pWaypointList[t];

				m_pNpcList[i]->m_cTotalWaypoint = 0;
				for (t = 0; t < 10; t++)
					if (m_pNpcList[i]->m_iWayPointIndex[t] != -1) m_pNpcList[i]->m_cTotalWaypoint++;

				if (pArea != NULL) {
					// RANDOMAREA Copy
					SetRect(&m_pNpcList[i]->m_rcRandomArea, pArea->left, pArea->top, pArea->right, pArea->bottom);
				}

				switch (cMoveType) {
				case MOVETYPE_GUARD:
					m_pNpcList[i]->m_dX = m_pNpcList[i]->m_sX;
					m_pNpcList[i]->m_dY = m_pNpcList[i]->m_sY;
					break;

				case MOVETYPE_SEQWAYPOINT: 
					m_pNpcList[i]->m_cCurWaypoint = 1;

					m_pNpcList[i]->m_dX  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].x;
					m_pNpcList[i]->m_dY  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].y;
					break;

				case MOVETYPE_RANDOMWAYPOINT:
					m_pNpcList[i]->m_cCurWaypoint = (rand() % (m_pNpcList[i]->m_cTotalWaypoint - 1)) + 1;

					m_pNpcList[i]->m_dX  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].x;
					m_pNpcList[i]->m_dY  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].y;
					break;

				case MOVETYPE_RANDOMAREA:
					m_pNpcList[i]->m_cCurWaypoint = 0;

					sRange = (short)(m_pNpcList[i]->m_rcRandomArea.right - m_pNpcList[i]->m_rcRandomArea.left);
					m_pNpcList[i]->m_dX = (short)((rand() % sRange) + m_pNpcList[i]->m_rcRandomArea.left);
					sRange = (short)(m_pNpcList[i]->m_rcRandomArea.bottom - m_pNpcList[i]->m_rcRandomArea.top);
					m_pNpcList[i]->m_dY = (short)((rand() % sRange) + m_pNpcList[i]->m_rcRandomArea.top);
					break;

				case MOVETYPE_RANDOM:
					m_pNpcList[i]->m_dX = (short)((rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15);
					m_pNpcList[i]->m_dY = (short)((rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15);
					break;
				}
				m_pNpcList[i]->m_tmp_iError  = 0;
				m_pNpcList[i]->m_cMoveType   = cMoveType;

				switch (m_pNpcList[i]->m_cActionLimit) {
				case 2:
				case 3:
				case 5:
					m_pNpcList[i]->m_cBehavior = BEHAVIOR_STOP;

					switch (m_pNpcList[i]->m_sType) {
					case 15:
					case 19:
					case 20:
					case 24:
					case 25:
					case 26:
						m_pNpcList[i]->m_cDir      = 4 + dice(1,3) -1;
						break;

					default:
						m_pNpcList[i]->m_cDir      = dice(1,8);
						break;
					}
					break;
			case 8: // Heldenian gate
			m_pNpcList[i]->m_cDir      = 3;
			m_pNpcList[i]->m_cBehavior = BEHAVIOR_STOP;	
			if (m_pNpcList[i]->m_cSize > 0)
			{	for(short sx1 = (sX - 1); sx1 <= sX + 1; sx1++)
				for(short sy1 = (sY - 1); sy1 <= sY + 1; sy1++)
				{	m_pMapList[iMapIndex]->SetTempMoveAllowedFlag(sx1, sy1, FALSE);		
			}	}
			break;
				default: 
					m_pNpcList[i]->m_cBehavior = BEHAVIOR_MOVE;
					m_pNpcList[i]->m_cDir      = 5;
					break;
				}

				m_pNpcList[i]->m_iFollowOwnerIndex  = NULL;
				m_pNpcList[i]->m_iTargetIndex	    = NULL;
				m_pNpcList[i]->m_cTurn              = (rand() % 2);

				switch (m_pNpcList[i]->m_sType) {
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
					m_pNpcList[i]->m_sAppr2 = (short)0xF000;
					m_pNpcList[i]->m_sAppr2 = m_pNpcList[i]->m_sAppr2 | ((rand() % 13) << 4);
					m_pNpcList[i]->m_sAppr2 = m_pNpcList[i]->m_sAppr2 | (rand() % 9);
					break;

				case 36:
				case 37:
				case 38:
				case 39:
					m_pNpcList[i]->m_sAppr2 = 3;
					break;
				case 64:
					m_pNpcList[i]->m_sAppr2 = 1;
					break;

				default:
					m_pNpcList[i]->m_sAppr2 = 0;
					break;
				}

				m_pNpcList[i]->m_cMapIndex          = (char)iMapIndex;
				m_pNpcList[i]->m_dwTime             = timeGetTime() + (rand() % 10000);
				m_pNpcList[i]->m_dwMPupTime			= timeGetTime();
				m_pNpcList[i]->m_dwHPupTime			= m_pNpcList[i]->m_dwMPupTime;
				m_pNpcList[i]->m_sBehaviorTurnCount	= 0;
				m_pNpcList[i]->m_bIsSummoned        = bIsSummoned;
				m_pNpcList[i]->m_bIsMaster          = bIsMaster;
				if (bIsSummoned == TRUE) 
					m_pNpcList[i]->m_dwSummonedTime = timeGetTime();

				if (bFirmBerserk == TRUE) {
					m_pNpcList[i]->SetMagicFlag(MAGICTYPE_BERSERK, TRUE);
					m_pNpcList[i]->m_iExpDice *= 2;
				}

				// !!!
				if (cChangeSide != -1) 
				{
					m_pNpcList[i]->m_side = cChangeSide;
					m_pNpcList[i]->SetSideFlag((Side)cChangeSide);
				}

				m_pNpcList[i]->m_cBravery = (rand() % 3) + m_pNpcList[i]->m_iMinBravery;
				m_pNpcList[i]->m_iSpotMobIndex		= iSpotMobIndex;
				m_pNpcList[i]->m_iGuildGUID         = iGuildGUID;

	
				//testcode
				if (iGuildGUID != 0) {
					wsprintf(g_cTxt, "Summon War Unit(%d) GUID(%d)", m_pNpcList[i]->m_sType, iGuildGUID);
					PutLogList(g_cTxt);
				}

				m_pMapList[iMapIndex]->SetOwner(i, OWNERTYPE_NPC, sX, sY);
				m_pMapList[iMapIndex]->m_iTotalActiveObject++;
				m_pMapList[iMapIndex]->m_iTotalAliveObject++;

				switch (m_pNpcList[i]->m_sType) {
				case 36:
				case 37:
				case 38:
				case 39:
				case 42:
					m_pMapList[iMapIndex]->bAddCrusadeStructureInfo(m_pNpcList[i]->m_sType, sX, sY, m_pNpcList[i]->m_side);
					break;
				case 64:
					m_pMapList[iMapIndex]->bAddCropsTotalSum();
					return TRUE;
					break;
				}

				SendEventToNearClient_TypeA(i, OWNERTYPE_NPC, MSGID_EVENT_LOG, MSGTYPE_CONFIRM, NULL, NULL, NULL);
				return TRUE;
			}

	return FALSE;
}

/*
bool CGame::bCreateNewNpc(char * pNpcName, char * pName, char * pMapName, short sX, short sY)
{
register int i, iMapIndex;
char cTmpName[11];

ZeroMemory(cTmpName, sizeof(cTmpName));
strcpy(cTmpName, pMapName);
iMapIndex = -1;

for (i = 0; i < MAXMAPS; i++)
if (m_pMapList[i] != NULL) {
if (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0) 
iMapIndex = i;
}

if (iMapIndex == -1) return FALSE;

for (i = 1; i < MAXNPCS; i++)
if (m_pNpcList[i] == NULL) {
m_pNpcList[i] = new class CNpc(pName);

if (_binitNpcAttr(m_pNpcList[i], pNpcName) == FALSE) {
PutLogList("(!) Not existing NPC creation request! Ignored.");
delete m_pNpcList[i];
m_pNpcList[i] = NULL;
return FALSE;
}

GetEmptyPosition(&sX, &sY, iMapIndex);

m_pNpcList[i]->m_sX = sX;
m_pNpcList[i]->m_sY = sY;
// testcode
m_pNpcList[i]->m_dX          = rand() % 450 + 30;
m_pNpcList[i]->m_dY          = rand() % 450 + 30;
m_pNpcList[i]->m_tmp_iError  = 0;


m_pNpcList[i]->m_cMoveType          = MOVETYPE_SEQWAYPOINT;
m_pNpcList[i]->m_cBehavior          = BEHAVIOR_MOVE;
m_pNpcList[i]->m_iFollowOwnerIndex  = NULL;
m_pNpcList[i]->m_iTargetIndex	    = NULL;

m_pNpcList[i]->m_cDir               = 5;
m_pNpcList[i]->m_sAppr2             = 0;
m_pNpcList[i]->m_sStatus            = NULL;
m_pNpcList[i]->m_cMapIndex          = (char)iMapIndex;
m_pNpcList[i]->m_dwTime             = timeGetTime() + (rand() % 10000);
m_pNpcList[i]->m_dwActionTime       = 1500 + (rand() % 1000);
m_pNpcList[i]->m_sBehaviorTurnCount	= 0;
m_pNpcList[i]->m_cTargetSearchRange = 2 + (rand() % 4);

m_pNpcList[i]->m_cBravery = (rand() % 3) + m_pNpcList[i]->m_iMinBravery;

m_pMapList[iMapIndex]->SetOwner(i, OWNERTYPE_NPC, sX, sY);

return TRUE;
}

return FALSE;
}
*/


void CGame::NpcProcess()
{
	register int i, iMaxHP;
	DWORD dwTime, dwActionTime;

	dwTime = timeGetTime();

	for (i = 1; i < MAXNPCS; i++) {

		if (m_pNpcList[i] != NULL) {
			switch(m_pNpcList[i]->m_cBehavior)
			{
				case BEHAVIOR_ATTACK:
					dwActionTime = m_pNpcList[i]->m_dwActionTime + 50*dice(1,7);
					break;
				case BEHAVIOR_MOVE:
				case BEHAVIOR_FLEE:
					dwActionTime = m_pNpcList[i]->m_dwActionTime + 400; 
					break;
				default:
					dwActionTime = m_pNpcList[i]->m_dwActionTime; 
					break;
			}


			if (m_pNpcList[i]->m_cMagicEffectStatus[ MAGICTYPE_ICE ] != 0) 
				dwActionTime += (dwActionTime/2);
		}

		if ((m_pNpcList[i] != NULL) && ((dwTime - m_pNpcList[i]->m_dwTime) > dwActionTime)) {
			m_pNpcList[i]->m_dwTime = dwTime;

			if (m_pNpcList[i]->m_cMagicLevel != 0) {
				if ((dwTime - m_pNpcList[i]->m_dwMPupTime) > MPUPTIME) {
					m_pNpcList[i]->m_dwMPupTime = dwTime;

					m_pNpcList[i]->m_iMP += dice(1, (m_pNpcList[i]->m_iMaxMana/5));

					if (m_pNpcList[i]->m_iMP > m_pNpcList[i]->m_iMaxMana)
						m_pNpcList[i]->m_iMP = m_pNpcList[i]->m_iMaxMana;
				}
			}


			if (((dwTime - m_pNpcList[i]->m_dwHPupTime) > HPUPTIME) && (m_pNpcList[i]->m_bIsKilled == FALSE)) {
				m_pNpcList[i]->m_dwHPupTime = dwTime;

				iMaxHP = dice(m_pNpcList[i]->m_iHitDice, 8) + m_pNpcList[i]->m_iHitDice;
				if (m_pNpcList[i]->m_iHP < iMaxHP) {

					m_pNpcList[i]->m_iHP += dice(1, m_pNpcList[i]->m_iHitDice); 
					if (m_pNpcList[i]->m_iHP > iMaxHP) m_pNpcList[i]->m_iHP = iMaxHP;
					if (m_pNpcList[i]->m_iHP <= 0)     m_pNpcList[i]->m_iHP = 1;
				}
			}

			switch (m_pNpcList[i]->m_cBehavior) {
			case BEHAVIOR_DEAD:
				NpcBehavior_Dead(i);
				break;
			case BEHAVIOR_STOP:
				m_pNpcList[i]->behavior_stop();
				break;
			case BEHAVIOR_MOVE:
				m_pNpcList[i]->behavior_move();
				break;
			case BEHAVIOR_ATTACK:
				m_pNpcList[i]->behavior_attack();
				break;
			case BEHAVIOR_FLEE:
				NpcBehavior_Flee(i);
				break;
			}


			if ((m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_iHP != 0) && (m_pNpcList[i]->m_bIsSummoned == TRUE)) {
				switch (m_pNpcList[i]->m_sType) {
				case 29: 	
					if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > 1000*90)
						NpcKilledHandler(NULL, NULL, i, 0);
					break;
				case 64: 
					if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > PLANTTIME) 
						DeleteNpc(i);
					break;
				default: 					
					if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > SUMMONTIME) 
						NpcKilledHandler(NULL, NULL, i, 0);
					break;
				}
			}
		}
	}
}


void CGame::ChatMsgHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
	register int i, iRet;
	WORD * wp;
	int  * ip;
	char * cp, * cp2;
	char   cBuffer[256], cTemp[256], cSendMode = NULL;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (dwMsgSize > 83 +30) return;

	if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) return;

	if (memcmp((pData + 10), m_pClientList[iClientH]->m_cCharName, strlen(m_pClientList[iClientH]->m_cCharName)) != 0) return;

	if ((m_pClientList[iClientH]->m_bIsObserverMode == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->IncPlayerActivity(m_pClientList[iClientH]);
	}

	cp = (char *)(pData + 21);


	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
		char cTemp[200] ;
		ZeroMemory(cTemp,sizeof(cTemp)) ;
		pData[dwMsgSize-1] = NULL;
		wsprintf(cTemp,"GM Chat(%s):\"%s\"",m_pClientList[iClientH]->m_cCharName,cp) ;

		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
	}

	switch (*cp) {
	case '$':

		*cp = 32;

		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0)
			 cSendMode = CHAT_PARTY;
		else cSendMode = NULL;

		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		break;

	case '@':

		*cp = 32;

		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 1))
			 cSendMode = CHAT_GUILD;
		else cSendMode = NULL;

		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		break;

	case '!':
		*cp = 32;

		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 10))
			 cSendMode = CHAT_SHOUT;			
		else cSendMode = NULL;

		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;

		if (m_pClientList[iClientH]->IsDead()) cSendMode = NULL;

		break;

	case '%':
		*cp = 32;

		if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) {
			ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = CHAT_GM;
			cp2++;
			ip = (int *)cp2;
			*ip = NULL;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}

		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) cSendMode = 10;
		else cSendMode = NULL;

		break;

	case '^':
		*cp = 32;

		if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iGuildRank != -1)) {

			ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = CHAT_GUILD; 
			cp2++;
			ip = (int *)cp2;
			*ip = m_pClientList[iClientH]->m_iGuildGUID;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}

		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 10) && 
			(m_pClientList[iClientH]->m_iGuildRank != -1) ) 
			 cSendMode = 1;			
		else cSendMode = NULL;

		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;


		if (m_pClientList[iClientH]->IsDead()) cSendMode = NULL;

		break;

	case '~':

		*cp = 32;
		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 1))
			 cSendMode = CHAT_NATIONSHOUT;
		else cSendMode = NULL;

		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;

		if (m_pClientList[iClientH]->IsDead()) cSendMode = NULL;
		break;

	case '/':
		ZeroMemory(cBuffer, sizeof(cBuffer));
		memcpy(cBuffer, cp, dwMsgSize - 21);
		cp = (char *)(cBuffer);

		if (memcmp(cp, "/who", 4) == 0) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_TOTALUSERS, NULL, NULL, NULL, NULL);
		} 
		else if (memcmp(cp, "/mcount", 8) == 0) {
			Apocalypse_MonsterCount(iClientH);
		} else if (memcmp(cp, "/send ", 5) == 0) {
			AdminOrder_Pushplayer(iClientH, cp, dwMsgSize -21);
		} else if (memcmp(cp, "/goto ", 6) == 0) {
			AdminOrder_GoTo(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/clearmap", 9) == 0) {
			AdminOrder_CleanMap(iClientH, cp, dwMsgSize);
		} else if (memcmp(cp, "/afk", 5) == 0) {
			PlayerOrder_SetAFK(iClientH);
		} else if (memcmp(cp, "/checkrep", 9) == 0) {
			AdminOrder_CheckRep(iClientH,cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/fi ", 4) == 0) {
			CheckAndNotifyPlayerConnection(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/to", 3) == 0) {
			ToggleWhisperPlayer(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/setpf ", 7) == 0) {
			SetPlayerProfile(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/pf ", 4) == 0) {
			GetPlayerProfile(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/shutup ", 8) == 0) {
			ShutUpPlayer(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/rep+ ", 6) == 0)  {
			SetPlayerReputation(iClientH, cp, 1, dwMsgSize - 21);
		} else if (memcmp(cp, "/rep- ", 6) == 0) {
			SetPlayerReputation(iClientH, cp, 0, dwMsgSize - 21);
		} else if (memcmp(cp, "/hold", 5) == 0) {
			SetSummonMobAction(iClientH, 1, dwMsgSize - 21);
		} else if (memcmp(cp, "/tgt ", 5) == 0) {
			SetSummonMobAction(iClientH, 2, dwMsgSize - 21, cp);
		} else if (memcmp(cp, "/free", 5) == 0) {
			SetSummonMobAction(iClientH, 0, dwMsgSize - 21);
		} else if (memcmp(cp, "/closeconn ", 11) == 0) {
			AdminOrder_CloseConn(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/eventspell ", 12) == 0) {
			AdminOrder_EventSpell(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/eventarmor", 11) == 0) {
			AdminOrder_EventArmor(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/eventshield", 12) == 0) {
			AdminOrder_EventSheild(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/eventchat", 10) == 0) {
			AdminOrder_EventChat(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/eventparty", 11) == 0) {
			AdminOrder_EventParty(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/eventreset", 11) == 0) {
			AdminOrder_EventReset(iClientH);
		} else if (memcmp(cp, "/eventtp", 8) == 0) {
			AdminOrder_EventTP(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/eventillusion", 14) == 0) {
			AdminOrder_EventIllusion(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/ban", 4) == 0) {
			UserCommand_BanGuildsman(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/reservefightzone", 17) == 0) {
			AdminOrder_ReserveFightzone(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/dissmiss ", 9) == 0) {
			UserCommand_DissmissGuild(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/attack ", 8) == 0) {
			AdminOrder_CallGuard(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/createfish ", 12) == 0) {
			AdminOrder_CreateFish(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/teleport ", 10) == 0 || memcmp(cp, "/tp ", 4) == 0) {
			AdminOrder_Teleport(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/summonplayer ", 14) == 0) {
			AdminOrder_SummonPlayer(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/unsummonall", 12) == 0) {
			AdminOrder_UnsummonAll(iClientH);
		} else if (memcmp(cp, "/unsummonboss", 13) == 0) {
			AdminOrder_UnsummonBoss(iClientH);
		} else if (memcmp(cp, "/checkip ", 9) == 0) {
			AdminOrder_CheckIP(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/polymorph ", 11) == 0) {
			AdminOrder_Polymorph(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/noaggro", 8) == 0) {
			AdminOrder_ToggleNoAggro(iClientH);
		} else if (memcmp(cp, "/invincible", 11) == 0) {
			AdminOrder_ToggleInvincible(iClientH);
		} else if (memcmp(cp, "/setinvi", 8) == 0 || memcmp(cp, "/invi", 5) == 0) {
			AdminOrder_SetInvi(iClientH);
		} else if (memcmp(cp, "/sethp", 6) == 0 ) {
			AdminOrder_SetHP(iClientH, atoi(cp+6));
		} else if (memcmp(cp, "/setmp", 6) == 0 ) {
			AdminOrder_SetMP(iClientH, atoi(cp+6));
		} else if (memcmp(cp, "/setmag", 7) == 0 ) {
			AdminOrder_SetMag(iClientH, atoi(cp+7));
		} else if (memcmp(cp, "/gns ", 4) == 0) {
			AdminOrder_GetNpcStatus(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/setattackmode ", 15) == 0) {
			AdminOrder_SetAttackMode(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/setforcerecalltime ", 20) == 0) {
			AdminOrder_SetForceRecallTime(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/summon ", 8) == 0) {
			AdminOrder_Summon(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/disconnectall", 14) == 0) {
			AdminOrder_DisconnectAll(iClientH);
		} else if (memcmp(cp, "/createitem ", 12) == 0 || memcmp(cp, "/ci ", 4) == 0) {
			AdminOrder_CreateItem(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/energysphere ", 14) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 2)
			{	
				EnergySphereProcessor(TRUE, iClientH);
				wsprintf(g_cTxt, "GM Order(%s): energysphere ", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);
			}
		} else if (memcmp(cp, "/apocalypse", 11) == 0) {	
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 4)
			{	wsprintf(cTemp, "GM Order(%-10s): /beginapocalypse", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
				GlobalStartApocalypseMode(iClientH);
			}
			return;
		} else	if (memcmp(cp, "/endapocalypse", 14) == 0) {	
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 4) 	
			{	
				wsprintf(cTemp, "GM Order(%-10s): /endapocalypse", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
				GlobalEndApocalypseMode(iClientH);
			}
			return;
		} else if (memcmp(cp, "/heldenian", 10) == 0) {	
			if (m_pClientList[iClientH]->m_iAdminUserLevel < 4)
			{	
				SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
				return;
			}
			wsprintf(cTemp, "GM Order(%-10s): /beginheldenian", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
			StartHeldenianMode(iClientH);
			return;
		} else if (memcmp(cp, "/endheldenian ", 14) == 0) {	
			if (m_pClientList[iClientH]->m_iAdminUserLevel < 4)
			{	
				SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
				return;
			}
			wsprintf(cTemp, "GM Order(%-10s): /endheldenian", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
			Side side = (Side)atoi(cp+14);
			HeldenianEndWarNow(m_iHeldenianType, side); 
			return;
		} 
		else if (memcmp(cp, "/crusade", 8) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 4) {
				GlobalStartCrusadeMode();
				wsprintf(g_cTxt, "GM Order(%s): begincrusadetotalwar", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);
			}
		} else if (memcmp(cp, "/endcrusade", 11) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 4) {
				ManualEndCrusadeMode(0);
				wsprintf(g_cTxt, "GM Order(%s): endcrusade", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);
			} 
		} else if (memcmp(cp, "/astoria ", 9) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 4) {
				EventType eType = (EventType)atoi(cp+9);
				EventStart(eType);
				wsprintf(g_cTxt, "GM Order(%s): Start Astoria(%u)", m_pClientList[iClientH]->m_cCharName, eType);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);
			}
		} else if (memcmp(cp, "/endastoria", 11) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 4) {
				wsprintf(g_cTxt, "GM Order(%s): End Astoria", m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);
				EventEnd();
			}
		} else if (memcmp(cp, "/joinparty ", 11) == 0) {
			RequestJoinPartyHandler(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/dismissparty", 13) == 0) {
			RequestDismissPartyHandler(iClientH);
		} else if (memcmp(cp, "/getpartyinfo", 13) == 0) {
			GetPartyInfoHandler(iClientH);
		} else if (memcmp(cp, "/deleteparty", 12) == 0) {
			RequestDeletePartyHandler(iClientH);
		} else if ((memcmp(cp, "/shutdownthisserverrightnow ", 28) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel >= 4)) {
			m_cShutDownCode      = 2;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Admin-Command)!!!");
			bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);

			if (m_iMiddlelandMapIndex > 0) {
				// Crusade
				SaveOccupyFlagData();
				//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
				//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
			}
			return;
		} else if ((memcmp(cp, "/setobservermode", 16) == 0 || memcmp(cp, "/obs", 4) == 0) && 
			(m_pClientList[iClientH]->m_iAdminUserLevel >= 3)) {
			AdminOrder_SetObserverMode(iClientH);
		} else if ((memcmp(cp, "/getticket", 10) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel >= 2)) {
			AdminOrder_GetFightzoneTicket(iClientH);
		}

		return;
	}

	pData[dwMsgSize-1] = NULL;

	if ((m_pClientList[iClientH]->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ] == 1) && (dice(1,3) != 2)) {
		// Confuse Language
		cp = (char *)(pData + INDEX2_MSGTYPE + 17);

		while (*cp != NULL) {
			if ((cp[0] != NULL) && (cp[0] != ' ') && (cp[1] != NULL) && (cp[1] != ' ')) {
				switch (dice(1,3)) {
				case 1:	memcpy(cp, "", 2); break;
				case 2:	memcpy(cp, "", 2); break;
				case 3:	memcpy(cp, "", 2); break;
				}
				cp += 2;
			}
			else cp++; 
		}
	}

	cp = (char *)(pData + INDEX2_MSGTYPE + 17);

	if ((cSendMode == NULL) && (m_pClientList[iClientH]->m_iWhisperPlayerIndex != -1)) {
		cSendMode = CHAT_WHISPER;

		if (*cp == '#') cSendMode = CHAT_NORMAL;

		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = CHAT_NORMAL;
	}

	wp = (WORD *)(pData + INDEX2_MSGTYPE);
	*wp = (WORD)iClientH;
	cp = (char *)(pData + INDEX2_MSGTYPE + 16);
	*cp = cSendMode;

	bool send;
	if (cSendMode != CHAT_WHISPER) {
		for (i = 1; i < MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) continue;

					if (m_bIsCrusadeMode) {
							if (!m_pClientList[iClientH]->IsNeutral() && 
								!m_pClientList[i]->IsNeutral() && 
								m_pClientList[i]->m_side != m_pClientList[iClientH]->m_side) 
							{
								send = FALSE;
							}
							else 
								send = TRUE;
					}else{ 
						send = TRUE;
					}
					if(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isChatDisabled == false || i == iClientH || m_pClientList[iClientH]->IsGM() || m_pClientList[i]->IsGM())
						switch (cSendMode) 
						{
						case CHAT_NORMAL:
							if ( (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) &&
								(m_pClientList[i]->m_sX > m_pClientList[iClientH]->m_sX - 10) &&
								(m_pClientList[i]->m_sX < m_pClientList[iClientH]->m_sX + 10) &&
								(m_pClientList[i]->m_sY > m_pClientList[iClientH]->m_sY - 7) &&
								(m_pClientList[i]->m_sY < m_pClientList[iClientH]->m_sY + 7) ) {

									if (send)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
							}
							break;

						case CHAT_GUILD:
							if ( (memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0) &&
								(memcmp(m_pClientList[i]->m_cGuildName, "NONE", 4) != 0) ) 
							{
								if (send)
									iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
							}
							break;

						case CHAT_SHOUT:
							if (send)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
							break;

						case CHAT_GM:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
							break;

						case CHAT_NATIONSHOUT:
							if (m_pClientList[i]->m_side == m_pClientList[iClientH]->m_side) 
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
							break;

						case CHAT_PARTY:
							if ( (m_pClientList[i]->m_iPartyID != NULL) && (m_pClientList[i]->m_iPartyID == m_pClientList[iClientH]->m_iPartyID) ) 
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
							break;
						}

					switch (iRet) 
					{
					case XSOCKEVENT_QUENEFULL:
					case XSOCKEVENT_SOCKETERROR:
					case XSOCKEVENT_CRITICALERROR:
					case XSOCKEVENT_SOCKETCLOSED:
						//DeleteClient(i, TRUE, TRUE);
						break;
					}
			}
	}
	else if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isChatDisabled == false || m_pClientList[iClientH]->IsGM()
		|| (m_pClientList[iClientH]->m_iWhisperPlayerIndex < MAXCLIENTS &&  m_pClientList[ m_pClientList[iClientH]->m_iWhisperPlayerIndex ] != NULL && 
		m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->IsGM())) {
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pData, dwMsgSize);

		if (m_pClientList[iClientH]->m_iWhisperPlayerIndex == 10000) {
			ZeroMemory(cBuffer, sizeof(cBuffer));
			cp = (char *)(cBuffer);
			*cp =  GSM_WHISPERMSG;
			cp++;

			memcpy(cp, m_pClientList[iClientH]->m_cWhisperPlayerName, 10);
			cp += 10;

			wp = (WORD *)cp;
			*wp = (WORD)dwMsgSize;
			cp += 2;

			memcpy(cp, pData, dwMsgSize);
			cp += dwMsgSize;

			bStockMsgToGateServer(cBuffer, (13 +dwMsgSize));
		}
		else if (m_pClientList[ m_pClientList[iClientH]->m_iWhisperPlayerIndex ] != NULL) {
			if( strcmp(m_pClientList[iClientH]->m_cWhisperPlayerName, m_pClientList[ m_pClientList[iClientH]->m_iWhisperPlayerIndex ]->m_cCharName) == 0)  {
				iRet = m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_pXSock->iSendMsg(pData, dwMsgSize);
				if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel > 0) {
					char cTxt[200] ;

					ZeroMemory(cTxt,sizeof(cTxt)) ;

					wsprintf(cTxt,"PC Chat(%s):\"%s\"\tto GM(%s)",m_pClientList[iClientH]->m_cCharName,pData+21,m_pClientList[iClientH]->m_cWhisperPlayerName) ;
					bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL, cTxt);
				}
			}
		}

		switch (iRet) {
		case XSOCKEVENT_QUENEFULL:
		case XSOCKEVENT_SOCKETERROR:
		case XSOCKEVENT_CRITICALERROR:
		case XSOCKEVENT_SOCKETCLOSED:
			//DeleteClient(i, TRUE, TRUE);
			break;
		}
	}
}


void CGame::ChatMsgHandlerGSM(int iMsgType, int iV1, char * pName, char * pData, DWORD dwMsgSize)
{
	register int i, iRet;
	DWORD * dwp;
	WORD * wp;
	short * sp;
	char * cp, cTemp[256];

	ZeroMemory(cTemp, sizeof(cTemp));

	dwp = (DWORD *)cTemp;
	*dwp = MSGID_COMMAND_CHATMSG;

	wp  = (WORD *)(cTemp + INDEX2_MSGTYPE);
	*wp = NULL;

	cp  = (char *)(cTemp + INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;

	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;

	memcpy(cp, pName, 10);
	cp += 10;

	*cp = (char)iMsgType;
	cp++;

	memcpy(cp, pData, dwMsgSize);
	cp += dwMsgSize;

	switch (iMsgType) {
	case CHAT_GUILD:
		for (i = 1; i < MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
				if ( (m_pClientList[i]->m_iGuildGUID == iV1) && (m_pClientList[i]->m_iGuildGUID != 0)) {
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize +22);
				}
			}
			break;

	case CHAT_SHOUT:
	case CHAT_GM:
		for (i = 1; i < MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize +22);
			}
			break;
	}
}

void CGame::ShowClientMsg(int iClientH, char* pMsg)
{
	char * cp, cTemp[256];
	DWORD * dwp, dwMsgSize;
	WORD * wp;
	short * sp;

	ZeroMemory(cTemp, sizeof(cTemp));

	dwp = (DWORD *)cTemp;
	*dwp = MSGID_COMMAND_CHATMSG;

	wp  = (WORD *)(cTemp + INDEX2_MSGTYPE);
	*wp = NULL;

	cp  = (char *)(cTemp + INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;

	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;

	memcpy(cp, "Server", 8);
	cp += 10;

	*cp = CHAT_GM;
	cp++;

	dwMsgSize = strlen(pMsg);
	if(dwMsgSize > 50) dwMsgSize = 50;
	memcpy(cp, pMsg, dwMsgSize);
	cp += dwMsgSize;

	m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, dwMsgSize + 22);
}

int CGame::iClientMotion_Attack_Handler(int iClientH, short sX, short sY, short dX, short dY, short wType, char cDir, WORD wTargetObjectID, bool bResponse, bool bIsDash)
{
	char cData[100];
	DWORD * dwp, dwTime;
	WORD  * wp;
	int     iRet, iExp, tdX = 0, tdY = 0;
	short   sOwner, sAbsX, sAbsY;
	char    cOwnerType, tgtDist = 1;
	bool    bNearAttack = FALSE;
	int  iErr = 0, tX = 0, tY = 0, i = 1;
	short sItemIndex;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;

	dwTime = timeGetTime();
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;

#ifndef NO_MSGSPEEDCHECK
	m_pClientList[iClientH]->m_iAttackMsgRecvCount++;
	if (m_pClientList[iClientH]->m_iAttackMsgRecvCount >= 7) {
		if (m_pClientList[iClientH]->m_dwAttackLAT != 0) {

			if ((dwTime - m_pClientList[iClientH]->m_dwAttackLAT) < (80*8*7 -3000)) {

				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
			}
		}
		m_pClientList[iClientH]->m_dwAttackLAT = dwTime;
		m_pClientList[iClientH]->m_iAttackMsgRecvCount = 0;
	}
#endif

	if ((wTargetObjectID != NULL) && (wType != 2)) {
		if (wTargetObjectID < MAXCLIENTS) {
			if (m_pClientList[wTargetObjectID] != NULL) {
				tdX = m_pClientList[wTargetObjectID]->m_sX;
				tdY = m_pClientList[wTargetObjectID]->m_sY;
				tgtDist = 1;
			}
		}else if ((wTargetObjectID > 10000) && (wTargetObjectID < (10000 + MAXNPCS))){
			if (m_pNpcList[wTargetObjectID - 10000] != NULL){
				tdX = m_pNpcList[wTargetObjectID - 10000]->m_sX;
				tdY = m_pNpcList[wTargetObjectID - 10000]->m_sY;
				tgtDist = (m_pNpcList[wTargetObjectID - 10000]->m_cSize < 2) ? 1 : m_pNpcList[wTargetObjectID - 10000]->m_cSize;
			}
		}
		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwner, &cOwnerType, dX, dY);
		if(sOwner == (wTargetObjectID - 10000)) {
			dX = tdX = m_pNpcList[sOwner]->m_sX;
			dY = tdY = m_pNpcList[sOwner]->m_sY;
			bNearAttack = FALSE;
		}
		else if((tdX == dX) && (tdY == dY)) {
			bNearAttack = FALSE;
		}
		else if ((abs(tdX - dX) <= 1) && (abs(tdY - dY) <= 1)) {
			dX = tdX;
			dY = tdY;
			bNearAttack = TRUE;	
		}	
	}

	if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
		(dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return 0;


	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;


	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->IncPlayerActivity(m_pClientList[iClientH]);
	}

	sAbsX = abs(sX - dX);
	sAbsY = abs(sY - dY);
	if ((wType != 2) && (wType < 20)) {
		sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_TWOHAND ];
		if (sItemIndex != -1) {
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return 0;
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_STORMBRINGER) {
				if (sAbsX > (3+tgtDist) || sAbsY > (3+tgtDist)) wType = 0;
			}
			else{
				if (sAbsX > tgtDist || sAbsY > tgtDist) wType = 0;
			}
		}
		else{
			if (sAbsX > tgtDist || sAbsY > tgtDist) wType = 0;
		}
	}

	if(m_pClientList[iClientH]->m_bSkillUsingStatus[19]) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(/*0,*/ iClientH, OWNERTYPE_PLAYER, sX, sY);
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, OWNERTYPE_PLAYER, sX, sY);
	}

	ClearSkillUsingStatus(iClientH);

	m_pClientList[iClientH]->m_cDir = cDir;

	iExp = 0;

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);

	if (sOwner != NULL) {
		if ((wType != 0) && ((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) > 100)) {
			if (m_pClientList[iClientH]->m_bIsInBuilding == FALSE) {
				sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[EQUIPPOS_TWOHAND];
				if (sItemIndex != -1 && m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
					if(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_DIRECTION_BOW){
						sAbsX = abs(sX - dX);
						sAbsY = abs(sY - dY);
						tgtDist = sAbsX > sAbsY ? sAbsX : sAbsY;
						for(i = 1; i < tgtDist; i++){
							if (dice(1, 4) <= 3) {
								iErr = 0;
								m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, tX, tY);
								if (cOwnerType != OWNERTYPE_NONE)
									iExp += calculateAttackEffect(sOwner, cOwnerType, iClientH, OWNERTYPE_PLAYER, tX, tY, wType, bNearAttack, bIsDash);
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);
						if(iExp == 0 && cOwnerType == OWNERTYPE_NPC && dice(1,2) == 1) {
							iExp += calculateAttackEffect(sOwner, cOwnerType, iClientH, OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);
						}
						iExp += calculateAttackEffect(sOwner, cOwnerType, iClientH, OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);						
					}
					else if(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_FIRE_BOW){
						if ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) != 0) {

							if(!m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) && (abs(dX - sX) > 1 || abs(dY - sY) > 1))
								iAddDynamicObjectList(iClientH, OWNERTYPE_PLAYER_INDIRECT, DYNAMICOBJECT_FIRE, m_pClientList[iClientH]->m_cMapIndex, dX, dY, (dice(1,7)+3)*1000, 8);

							iExp += calculateAttackEffect(sOwner, cOwnerType, iClientH, OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);
						}
					}
					else{
						iExp += calculateAttackEffect(sOwner, cOwnerType, iClientH, OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);
					}
				}
				else{
					iExp += calculateAttackEffect(sOwner, cOwnerType, iClientH, OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);
				}
			}
			else{
				iExp += calculateAttackEffect(sOwner, cOwnerType, iClientH, OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);
			}
			if (m_pClientList[iClientH] == NULL) return 0;
			m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;
		}
	}
	else _CheckMiningAction(iClientH, dX, dY);


	if (iExp != 0) 	GetExp(iClientH, iExp, TRUE);


	if (bResponse == TRUE) {
		dwp  = (DWORD *)(cData + INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + INDEX2_MSGTYPE);
		*wp  = OBJECTMOTION_ATTACK_CONFIRM;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case XSOCKEVENT_QUENEFULL:
		case XSOCKEVENT_SOCKETERROR:
		case XSOCKEVENT_CRITICALERROR:
		case XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
	}

	return 1;
}




char CGame::cGetNextMoveDir(short sX, short sY, short dstX, short dstY, char cMapIndex, char cTurn, int * pError)
{
	register char  cDir, cTmpDir;
	register int   aX, aY, dX, dY;
	register int   i, iResX, iResY;

	if ((sX == dstX) && (sY == dstY)) return 0;

	dX = sX;
	dY = sY;

	if ((abs(dX - dstX) <= 1) && (abs(dY - dstY) <= 1)) {
		iResX = dstX;
		iResY = dstY;
	}
	else m_Misc.GetPoint(dX, dY, dstX, dstY, &iResX, &iResY, pError);

	cDir = m_Misc.cGetNextMoveDir(dX, dY, iResX, iResY);

	if (cTurn == 0)
		for (i = cDir; i <= cDir + 7;i++) {
			cTmpDir = i;
			if (cTmpDir > 8) cTmpDir -= 8;
			aX = _tmp_cTmpDirX[cTmpDir];
			aY = _tmp_cTmpDirY[cTmpDir];
			if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) == TRUE) return cTmpDir;
		}

	if (cTurn == 1)
		for (i = cDir; i >= cDir - 7;i--) {
			cTmpDir = i;
			if (cTmpDir < 1) cTmpDir += 8;
			aX = _tmp_cTmpDirX[cTmpDir];
			aY = _tmp_cTmpDirY[cTmpDir];
			if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) == TRUE) return cTmpDir;
		}

	return 0;
}


char _tmp_cEmptyPosX[] = { 0, 1, 1, 0, -1, -1, -1, 0 ,1, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1, 2 };
char _tmp_cEmptyPosY[] = { 0, 0, 1, 1, 1, 0, -1, -1, -1, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2 };

bool CGame::bGetEmptyPosition(short * pX, short * pY, char cMapIndex)
{
	register int i;
	short sX, sY;

	for (i = 0; i < 25; i++) 
		if ( (m_pMapList[cMapIndex]->bGetMoveable(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == TRUE) &&
			(m_pMapList[cMapIndex]->bGetIsTeleport(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == FALSE) ) {
				sX = *pX + _tmp_cEmptyPosX[i];
				sY = *pY + _tmp_cEmptyPosY[i];
				*pX = sX;
				*pY = sY;
				return TRUE;
		}

	GetMapInitialPoint(cMapIndex, &sX, &sY);
	*pX = sX;
	*pY = sY;

	return FALSE;
}

void CGame::RemoveFromTarget(short sTargetH, char cTargetType, int iCode)
{
	register int i;
	DWORD dwTime = timeGetTime();

	for (i = 0; i < MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) {

			if ((m_pNpcList[i]->m_iGuildGUID != NULL) && (cTargetType == OWNERTYPE_PLAYER) &&
				(m_pClientList[sTargetH]->m_iGuildGUID == m_pNpcList[i]->m_iGuildGUID)) {

				if (m_pNpcList[i]->m_cActionLimit == 0) {
					m_pNpcList[i]->m_bIsSummoned = TRUE;
					m_pNpcList[i]->m_dwSummonedTime = dwTime;
				}
			}

		if ((m_pNpcList[i]->m_iTargetIndex == sTargetH) && 
			(m_pNpcList[i]->m_cTargetType == cTargetType)) {

			switch (iCode) 
			{
			case MAGICTYPE_INVISIBILITY:
				if (m_pNpcList[i]->m_cSpecialAbility == 1) {
				}
				else {
					m_pNpcList[i]->m_cBehavior = BEHAVIOR_MOVE;
					m_pNpcList[i]->m_iTargetIndex = NULL;
					m_pNpcList[i]->m_cTargetType  = NULL;
				}
				break;

			default:
				m_pNpcList[i]->m_cBehavior = BEHAVIOR_MOVE;
				m_pNpcList[i]->m_iTargetIndex = NULL;
				m_pNpcList[i]->m_cTargetType  = NULL;
				break;
			}
		}
	}
}

void CGame::RemoveFromTarget(Unit * target, int iCode)
{
	register int i;
	DWORD dwTime = timeGetTime();

	for (i = 0; i < MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) {

			if ((m_pNpcList[i]->m_iGuildGUID != NULL) && (target->IsPlayer()) &&
				(target->m_iGuildGUID == m_pNpcList[i]->m_iGuildGUID)) {

					if (m_pNpcList[i]->m_cActionLimit == 0) {
						m_pNpcList[i]->m_bIsSummoned = TRUE;
						m_pNpcList[i]->m_dwSummonedTime = dwTime;
					}
			}

			if ((m_pNpcList[i]->m_iTargetIndex == target->m_handle) && 
				(m_pNpcList[i]->m_cTargetType == target->m_ownerType)) {

					switch (iCode) 
					{
					case MAGICTYPE_INVISIBILITY:
						if (m_pNpcList[i]->m_cSpecialAbility == 1) {
						}
						else {
							m_pNpcList[i]->m_cBehavior = BEHAVIOR_MOVE;
							m_pNpcList[i]->m_iTargetIndex = NULL;
							m_pNpcList[i]->m_cTargetType  = NULL;
						}
						break;

					default:
						m_pNpcList[i]->m_cBehavior = BEHAVIOR_MOVE;
						m_pNpcList[i]->m_iTargetIndex = NULL;
						m_pNpcList[i]->m_cTargetType  = NULL;
						break;
					}
			}
		}
}

void CGame::NpcKilledHandler(short sAttackerH, char cAttackerType, int iNpcH, short sDamage)
{
	short  sAttackerWeapon;
	int    * ip, i, iQuestIndex, iExp, iConstructionPoint, iWarContribution;
	double dTmp1, dTmp2, dTmp3;
	char   * cp, cData[120], cQuestRemain, cTxt[120];

	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

	if(cAttackerType == OWNERTYPE_PLAYER)
		m_pNpcList[iNpcH]->m_killerh = sAttackerH;


	m_pNpcList[iNpcH]->m_bIsKilled = TRUE;
	m_pNpcList[iNpcH]->m_iHP = 0;
	m_pNpcList[iNpcH]->m_iLastDamage = sDamage;

	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject--;

	RemoveFromTarget(iNpcH, OWNERTYPE_NPC);

	ReleaseFollowMode(iNpcH, OWNERTYPE_NPC); 

	m_pNpcList[iNpcH]->m_iTargetIndex = NULL;
	m_pNpcList[iNpcH]->m_cTargetType  = NULL;

	if (cAttackerType == OWNERTYPE_PLAYER) {
		sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
	}
	else sAttackerWeapon = 1;

	SendEventToNearClient_TypeA(iNpcH, OWNERTYPE_NPC, MSGID_EVENT_MOTION, OBJECTDYING, sDamage, sAttackerWeapon, NULL);

	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(/*10,*/ iNpcH, OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);

	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetDeadOwner(iNpcH, OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);

	m_pNpcList[iNpcH]->m_cBehavior = BEHAVIOR_DEAD;

	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;

	m_pNpcList[iNpcH]->m_dwDeadTime = timeGetTime();


	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cType == MAPTYPE_NOPENALTY_NOREWARD) return;


	NpcDeadItemGenerator(iNpcH, sAttackerH, cAttackerType);


	if ( (m_pNpcList[iNpcH]->m_bIsSummoned != TRUE) && (cAttackerType == OWNERTYPE_PLAYER) && 
		(m_pClientList[sAttackerH] != NULL) ) {


			iExp = (m_pNpcList[iNpcH]->m_iExp/3);
			if (m_pNpcList[iNpcH]->m_iNoDieRemainExp > 0)
				iExp += m_pNpcList[iNpcH]->m_iNoDieRemainExp;


			if (m_pClientList[sAttackerH]->m_iAddExp != NULL) {
				dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
				dTmp2 = (double)iExp;
				dTmp3 = (dTmp1/100.0f)*dTmp2;
				iExp += (int)dTmp3;
			}


			if (m_bIsCrusadeMode == TRUE) {
				if (  (strcmp(m_pClientList[sAttackerH]->m_cMapName, sideMap[NEUTRAL]) != 0)  
					|| (strcmp(m_pClientList[sAttackerH]->m_cMapName, "arefarm") != 0)
					|| (strcmp(m_pClientList[sAttackerH]->m_cMapName, "elvfarm") != 0) )
					if (iExp > 10) iExp = iExp/4;
			}

			//m_pClientList[sAttackerH]->m_iExpStock += iExp;

			if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
				switch (m_pNpcList[iNpcH]->m_sType) {
				case NPC_RABBIT:
				case NPC_CAT:
					iExp = 0 ;
					break ;
				default: break;
				}
			}

			GetExp(sAttackerH, iExp);

		iQuestIndex = m_pClientList[sAttackerH]->m_iQuest;
		if (iQuestIndex != NULL) {
			if (m_pQuestConfigList[iQuestIndex] != NULL) {
				switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
				case QUESTTYPE_MONSTERHUNT:
					if ( (m_pClientList[sAttackerH]->m_bQuestMatchFlag_Loc == TRUE) &&
						 (m_pQuestConfigList[iQuestIndex]->m_iTargetType == m_pNpcList[iNpcH]->m_sType) ) {
							m_pClientList[sAttackerH]->m_iCurQuestCount++;
							cQuestRemain = (m_pQuestConfigList[m_pClientList[sAttackerH]->m_iQuest]->m_iMaxCount - m_pClientList[sAttackerH]->m_iCurQuestCount);
							SendNotifyMsg(NULL, sAttackerH, NOTIFY_QUESTCOUNTER, cQuestRemain, NULL, NULL, NULL);
							_bCheckIsQuestCompleted(sAttackerH);
					}
					break;
				}
			}
		}
	}
	if (   (m_bHeldenianMode) 
		&& (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE)) 
	{	if (   (cAttackerType == OWNERTYPE_NPC)
			&& (m_pNpcList[sAttackerH] != NULL)
			&& (m_pNpcList[sAttackerH]->m_bIsSummoned		== TRUE)
			&& (m_pNpcList[sAttackerH]->m_cFollowOwnerType  == OWNERTYPE_PLAYER)
			&& (m_pNpcList[sAttackerH]->m_bIsKilled			== FALSE)	
			&& (m_pClientList[m_pNpcList[sAttackerH]->m_iFollowOwnerIndex] != NULL) 
			&& (m_pClientList[m_pNpcList[sAttackerH]->m_iFollowOwnerIndex]->m_bIsKilled == FALSE)) 
		{	m_pClientList[m_pNpcList[sAttackerH]->m_iFollowOwnerIndex]->m_iWarContribution += m_pNpcList[iNpcH]->m_iHitDice;
	}	}
	/*if (cAttackerType == OWNERTYPE_PLAYER) {
		switch (m_pNpcList[iNpcH]->m_sType) {
		case 32: // Unicorn
			//m_pClientList[sAttackerH]->m_reputation -= 5;
			break;

		case 33: // Demon

			break;
		}
	}*/

	if(m_bIsCrusadeMode)
	{
		iConstructionPoint = 0;
		switch (m_pNpcList[iNpcH]->m_sType) 
		{
		case 1:  iConstructionPoint = 50; iWarContribution = 100; break;
		case 2:  iConstructionPoint = 50; iWarContribution = 100; break;
		case 3:  iConstructionPoint = 50; iWarContribution = 100; break;
		case 4:  iConstructionPoint = 50; iWarContribution = 100; break;
		case 5:  iConstructionPoint = 50; iWarContribution = 100; break;
		case 6:  iConstructionPoint = 50; iWarContribution = 100; break;		
		case 36: iConstructionPoint = 700; iWarContribution = 4000; break;
		case 37: iConstructionPoint = 700; iWarContribution = 4000; break;
		case 38: iConstructionPoint = 500; iWarContribution = 2000; break;		
		case 39: iConstructionPoint = 500; iWarContribution = 2000; break;		
		case 40: iConstructionPoint = 1500; iWarContribution = 5000; break;		
		case 41: iConstructionPoint = 5000; iWarContribution = 10000; break;		
		case 43: iConstructionPoint =  500; iWarContribution = 1000; break;		
		case 44: iConstructionPoint = 1000; iWarContribution = 2000; break;
		case 45: iConstructionPoint = 1500; iWarContribution = 3000; break;
		case 46: iConstructionPoint = 1000; iWarContribution = 2000; break;		
		case 47: iConstructionPoint = 1500; iWarContribution = 3000; break;		
		case 51: iConstructionPoint = 800; iWarContribution = 1500; break;

		case 64:
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCropsTotalSum();
			break;
		}

		if (iConstructionPoint != NULL) {
			switch (cAttackerType) 
			{
			case OWNERTYPE_PLAYER:
				if (m_pClientList[sAttackerH]->m_side != m_pNpcList[iNpcH]->m_side) {

					m_pClientList[sAttackerH]->m_iConstructionPoint += iConstructionPoint;

					if (m_pClientList[sAttackerH]->m_iConstructionPoint > MAXCONSTRUCTIONPOINT) 
						m_pClientList[sAttackerH]->m_iConstructionPoint = MAXCONSTRUCTIONPOINT;

					m_pClientList[sAttackerH]->m_iWarContribution   += iWarContribution;
					if (m_pClientList[sAttackerH]->m_iWarContribution > MAXWARCONTRIBUTION)
						m_pClientList[sAttackerH]->m_iWarContribution = MAXWARCONTRIBUTION;

					SendNotifyMsg(NULL, sAttackerH, NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
				}
				else {

					/*
					m_pClientList[sAttackerH]->m_iWarContribution   -= (iWarContribution*2);
					if (m_pClientList[sAttackerH]->m_iWarContribution < 0)
					m_pClientList[sAttackerH]->m_iWarContribution = 0;
					*/


					m_pClientList[sAttackerH]->m_iWarContribution = 0;

					wsprintf(cTxt, "WarContribution: Friendly Npc Killed by player(%s)! ", m_pClientList[sAttackerH]->m_cAccountName);
					PutLogFileList(cTxt, EVENT_LOGFILE);

					SendNotifyMsg(NULL, sAttackerH, NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
				}
				break;

			case OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_iGuildGUID != NULL) {
					if (m_pNpcList[sAttackerH]->m_side != m_pNpcList[iNpcH]->m_side) {
						for (i = 1; i < MAXCLIENTS; i++)
							if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildGUID == m_pNpcList[sAttackerH]->m_iGuildGUID) &&
								(m_pClientList[i]->m_iCrusadeDuty == 3)) 
							{
								m_pClientList[i]->m_iConstructionPoint += iConstructionPoint;
								if (m_pClientList[i]->m_iConstructionPoint > MAXCONSTRUCTIONPOINT) 
									m_pClientList[i]->m_iConstructionPoint = MAXCONSTRUCTIONPOINT;

								SendNotifyMsg(NULL, i, NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
								goto NKH_GOTOPOINT1;
							}

						ZeroMemory(cData, sizeof(cData));
						cp = (char *)cData;
						*cp = GSM_CONSTRUCTIONPOINT;
						cp++;
						ip = (int*)cp;
						*ip = m_pNpcList[sAttackerH]->m_iGuildGUID;
						cp += 4;
						ip = (int*)cp;
						*ip = iConstructionPoint;
						cp += 4;
						bStockMsgToGateServer(cData, 9);
					}
				}
				break;
			}
		}
	}

NKH_GOTOPOINT1:;

	if (m_pNpcList[iNpcH]->m_cSpecialAbility == 7) {
		m_pNpcList[iNpcH]->m_iMP = 100;
		m_pNpcList[iNpcH]->m_iMagicHitRatio = 100;
		m_pNpcList[iNpcH]->magicHandler(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 30); 
	}
	else if (m_pNpcList[iNpcH]->m_cSpecialAbility == 8) {
		m_pNpcList[iNpcH]->m_iMP = 100;
		m_pNpcList[iNpcH]->m_iMagicHitRatio = 100;
		m_pNpcList[iNpcH]->magicHandler(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 61); 
	}
if (m_bHeldenianMode && (m_iHeldenianType == 1) && m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_bIsHeldenianMap) 
	{	if ((m_pNpcList[iNpcH]->m_sType == NPC_CT) || (m_pNpcList[iNpcH]->m_sType == NPC_AGC)) 
		{	if (m_pNpcList[iNpcH]->m_side == 1) 
			{	m_iHeldenianAresdenLeftTower--;
				wsprintf(cTxt, "Aresden Tower Broken, Left TOWER %d", m_iHeldenianAresdenLeftTower);
				PutLogList(cTxt);
				UpdateHeldenianStatus();
				if (m_iHeldenianAresdenLeftTower == 0)	HeldenianEndWarNow(m_iHeldenianType, ELVINE);				
			}
		else if (m_pNpcList[iNpcH]->m_side == 2) 
			{	m_iHeldenianElvineLeftTower--;
				wsprintf(cTxt, "Elvine Tower Broken, Left TOWER %d", m_iHeldenianElvineLeftTower);
				PutLogList(cTxt);
				UpdateHeldenianStatus();
				if (m_iHeldenianElvineLeftTower == 0)	HeldenianEndWarNow(m_iHeldenianType, ARESDEN);	
	}	}	}
}

void CGame::NpcBehavior_Dead(int iNpcH)			   
{
	DWORD dwTime;

	if (m_pNpcList[iNpcH] == NULL) return; 

	dwTime = timeGetTime();
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 5) {
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
	}

	if ((dwTime - m_pNpcList[iNpcH]->m_dwDeadTime) > m_pNpcList[iNpcH]->m_dwRegenTime)
		DeleteNpc(iNpcH);
}

void CGame::NpcBehavior_Flee(int iNpcH)
{
	char cDir;
	short sX, sY, dX, dY;
	short sTarget;
	char  cTargetType;

	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;


	switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
	case ATTACKAI_EXCHANGEATTACK: 
	case ATTACKAI_TWOBYONEATTACK: 
		if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 2) {

			m_pNpcList[iNpcH]->m_cBehavior          = BEHAVIOR_ATTACK;
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			return;
		}
		break;

	default:
		if (dice(1,2) == 1) NpcRequestAssistance(iNpcH);
		break;
	}

	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 10) {

		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
		m_pNpcList[iNpcH]->m_cBehavior          = BEHAVIOR_MOVE;
		m_pNpcList[iNpcH]->m_tmp_iError         = 0;
		if (m_pNpcList[iNpcH]->m_iHP <= 3) {
			m_pNpcList[iNpcH]->m_iHP += dice(1, m_pNpcList[iNpcH]->m_iHitDice); 
			if (m_pNpcList[iNpcH]->m_iHP <= 0) m_pNpcList[iNpcH]->m_iHP = 1;
		}
		return;
	}

	m_pNpcList[iNpcH]->targetSearch(&sTarget, &cTargetType);
	if (sTarget != NULL) {
		m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
		m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
	}

	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;
	switch (m_pNpcList[iNpcH]->m_cTargetType) {
	case OWNERTYPE_PLAYER:
		dX = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	case OWNERTYPE_NPC:
		dX = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	}
	dX = sX - (dX - sX);
	dY = sY - (dY - sY);

	cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
	if (cDir == 0) {
	}
	else {
		dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
		dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(/*11,*/ iNpcH, OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);

		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, OWNERTYPE_NPC, dX, dY);
		m_pNpcList[iNpcH]->m_sX   = dX;
		m_pNpcList[iNpcH]->m_sY   = dY;
		m_pNpcList[iNpcH]->m_cDir = cDir;
		SendEventToNearClient_TypeA(iNpcH, OWNERTYPE_NPC, MSGID_EVENT_MOTION, OBJECTMOVE, NULL, NULL, NULL);
	}
}


void CGame::MsgProcess()
{
	char   * pData, cFrom, cGSReg[200], cKey, G_cTxt[250];
	DWORD    dwMsgSize, * dwpMsgID, dwMsgTime;
	WORD   * wpMsgType, * wp;
	int      i, iClientH;
	 DWORD  dwTime = timeGetTime();

	if ((m_bF1pressed == TRUE) && (m_bF4pressed == TRUE) && (m_bOnExitProcess == FALSE)) {
		m_cShutDownCode      = 2;
		m_bOnExitProcess     = TRUE;
		m_dwExitProcessTime  = timeGetTime();

		PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Local command)!!!");
		bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);

		if (m_iMiddlelandMapIndex > 0) {
			// Crusade
			SaveOccupyFlagData();
			//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
			//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
		}

		return;
	}

	ZeroMemory(m_pMsgBuffer, MSGBUFFERSIZE+1);
	pData = (char *)m_pMsgBuffer;

	m_iCurMsgs = 0;
	while (bGetMsgQuene(&cFrom, pData, &dwMsgSize, &iClientH, &cKey) == TRUE) {


		m_iCurMsgs++;
		if (m_iCurMsgs > m_iMaxMsgs) m_iMaxMsgs = m_iCurMsgs;

		switch (cFrom) {

		case MSGFROM_CLIENT:
			// 1st: log out corrupted packets from client
			// ici, rajouter un check sur les clients qui viennent juste d'tre ffacs.
			if (m_pClientList[iClientH] == NULL)// Remember erased clients	
			{	if (iClientH != NULL)
				{	for (i = 0; i < MAXCLIENTS; i++) 
					{	if (   (iClientH == m_stOldClientList[i].iClientH)
							&& (dwTime > (m_stOldClientList[i].m_dwDeleteTime - 10*1000))  // give 10 sec to prevent DW overflow
							&& (dwTime < (m_stOldClientList[i].m_dwDeleteTime + 30*1000))) // erased less than 30 sec ago
						{	wsprintf(G_cTxt, "Outdated message:  PC(%s) - PC disconnected %d ms ago."
								, m_stOldClientList[i].m_cCharName
								, dwTime - m_stOldClientList[i].m_dwDeleteTime);
							goto OUTDATED_PROUVED;						
				}	}	}

				wsprintf(G_cTxt, "Corrupt message received! (From unknown client):");	
OUTDATED_PROUVED:		
				PutLogFileList(G_cTxt);
				PutLogFileList(m_pMsgBuffer);
				return;	
			}
			m_pClientList[iClientH]->m_iConnectionCheck++;
			// Delete client if reaching 256+ messages without connection check, 
			// and too much missing connection checks as well
			if (m_pClientList[iClientH]->m_iConnectionCheck == m_iClientConnectionCheckMaxNumber *8)  
			{	if ((dwMsgTime - m_pClientList[iClientH]->dwEventTimeConnectionCheck) > (m_iClientConnectionCheckTime*8))
				{	wsprintf(G_cTxt, "Cn check:  PC(%s) (Gap=%4d) (nb:%3d)            - CCM missing, forbidden task on client's PC? (Disc.) \tIP(%s)"					
						, m_pClientList[iClientH]->m_cCharName
						, dwMsgTime - m_pClientList[iClientH]->dwEventTimeConnectionCheck
						, m_pClientList[iClientH]->m_iConnectionCheck
						, m_pClientList[iClientH]->m_cIPaddress);
					PutLogFileList(G_cTxt);
					//	Show in red on client!
					ZeroMemory(G_cTxt, sizeof(G_cTxt));
					wsprintf(G_cTxt, "HACK SUSPICTION:  CCM missing, forbidden task on PC: %s"
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_cIPaddress);
					DeleteClient(iClientH, TRUE, TRUE);
		
					break;
			}	}

			dwpMsgID = (DWORD *)(pData + INDEX4_MSGID);
			switch (*dwpMsgID) 
			{

			case MSGID_REQUEST_SELLITEMLIST:
				RequestSellItemListHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_RESTART:
				RequestRestartHandler(iClientH);
				break;

			case MSGID_REQUEST_PANNING:
				iRequestPanningMapDataRequest(iClientH, pData);
				break;

			case MSGID_REQUEST_NOTICEMENT:
				RequestNoticementHandler(iClientH, pData);
				break;

			case MSGID_MANAGER_INIT:
				_Manager_Init(iClientH, pData);
				break;

			case MSGID_MANAGER_SHUTDOWN:
				_Manager_Shutdown(iClientH, pData);
				break;

			case MSGID_REQUEST_SETITEMPOS:
					// This one can be sent many times in case of bag reorganisation
				// and risk of counting too many in m_iConnectionCheck
				m_pClientList[iClientH]->m_iConnectionCheck--;
				_SetItemPos(iClientH, pData);
				break;

			case MSGID_REQUEST_FULLOBJECTDATA:
				// This one can be sent many times in case of a GM sumoning lot of creature => Lag
				// and risk of counting too many in m_iConnectionCheck
				m_pClientList[iClientH]->m_iConnectionCheck--;
				m_pClientList[iClientH]->m_cMsgCount[5] +=1;
				RequestFullObjectData(iClientH, pData);
				break;

			case MSGID_REQUEST_RETRIEVEITEM:
				RequestRetrieveItemHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_CIVILRIGHT:
				RequestCivilRightHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_TELEPORT:
				RequestTeleportHandler(iClientH, 4);
				break;

			case MSGID_REQUEST_INITPLAYER:
				RequestInitPlayerHandler(iClientH, pData, cKey);
				break;

			//case MSGID_REQUEST_INITDATA:
				//RequestInitDataHandler(iClientH, pData, cKey);
				//break;

			case MSGID_COMMAND_COMMON:
				ClientCommonHandler(iClientH, pData);
				break;

			case MSGID_COMMAND_MOTION:
				ClientMotionHandler(iClientH, pData);
				break;

			case MSGID_COMMAND_CHECKCONNECTION:
				CheckConnectionHandler(iClientH, pData);
				break;

			case MSGID_COMMAND_CHATMSG:
				ChatMsgHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_CREATENEWGUILD:
				RequestCreateNewGuildHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_DISBANDGUILD:
				RequestDisbandGuildHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_FIGHTZONE_RESERVE:
				FightzoneReserveHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_LEVELUPSETTINGS:
				LevelUpSettingsHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_TELEPORT_LIST:
				RequestTeleportListHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_CHARGED_TELEPORT:
				RequestChargedTeleportHandler(iClientH, pData, dwMsgSize);
				break;
			case MSGID_REQUEST_HELDENIAN_SCROLL:
				RequestHeldenianScroll(iClientH, pData, dwMsgSize);
				break;
			case MSGID_REQUEST_ANGEL:
				GetAngelHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_DKITEM:
				GetDKItemHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_UPDATE_FRIENDS:
				RequestUpdateFriendsHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_RESURRECTPLAYER_YES:
				RequestResurrectPlayer(iClientH, TRUE);
				break;

			case MSGID_REQUEST_RESURRECTPLAYER_NO:
				RequestResurrectPlayer(iClientH, FALSE);
				break;

			case MSGID_STATECHANGEPOINT:
				StateChangeHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_LGNPTS:
				bSendMsgToLS(MSGID_REQUEST_LGNPTS, iClientH);
				break;

			case MSGID_REQUEST_LGNSVC:
				bSendMsgToLS(MSGID_REQUEST_LGNSVC, iClientH, NULL, pData);
				break;

			case MSGID_REQUEST_SETRECALLPNT:
				RequestSetRecallPoint(iClientH, pData, dwMsgSize);
				break;

			default:
				PutLogList("Unknown message received! Delete Client");
				DeleteClient(iClientH, TRUE, TRUE); 
				break;
			}
			break;

		case MSGFROM_LOGSERVER:
			dwpMsgID   = (DWORD *)(pData + INDEX4_MSGID);
			wpMsgType  = (WORD *)(pData + INDEX2_MSGTYPE);

			switch (*dwpMsgID) 
			{
			case MSGID_UPDATECONFIGFILES:
				_iForcePlayerDisconect(MAXCLIENTS);
				for (i = 0; i < MAXITEMTYPES; i++)          SAFEDELETE(m_pItemConfigList[i]);
				for (i = 0; i < MAXBUILDITEMS; i++)         SAFEDELETE(m_pBuildItemList[i]);
				for (i = 0; i < MAXDUPITEMID; i++)          SAFEDELETE(m_pDupItemIDList[i]);
				for (i = 0; i < MAXMAGICTYPE; i++)          SAFEDELETE(m_pMagicConfigList[i]);
				for (i = 0; i < MAXNPCTYPES; i++)           SAFEDELETE(m_npcConfigList[i]);
				for (i = 0; i < MAXPOTIONTYPES; i++)       SAFEDELETE(m_pPotionConfigList[i]);
				for (i = 0; i < MAXCRAFTING; i++)			SAFEDELETE(m_pCraftingConfigList[i]);
				for (i = 0; i < MAXQUESTTYPE; i++)          SAFEDELETE(m_pQuestConfigList[i]);
				for (i = 0; i < MAXSKILLTYPE; i++)          SAFEDELETE(m_pSkillConfigList[i]);
				break;

			case MSGID_REQUEST_CHECKACCOUNTPASSWORD:

				RequestCheckAccountPasswordHandler(pData, dwMsgSize);
				break;

			case MSGID_REQUEST_FORCEDISCONECTACCOUNT:

				wpMsgType  = (WORD *)(pData + INDEX2_MSGTYPE);
				ForceDisconnectAccount((char *)(pData + INDEX2_MSGTYPE + 2), *wpMsgType);
				break;

			case MSGID_RESPONSE_SAVEPLAYERDATA_REPLY:

				ResponseSavePlayerDataReplyHandler(pData, dwMsgSize);
				break;

			case MSGID_GUILDNOTIFY:

				GuildNotifyHandler(pData, dwMsgSize);
				break;

			case MSGID_RESPONSE_DISBANDGUILD:
				ResponseDisbandGuildHandler(pData, dwMsgSize);
				break;

			case MSGID_RESPONSE_CREATENEWGUILD:

				ResponseCreateNewGuildHandler(pData, dwMsgSize);
				break;

			case MSGID_PARTYOPERATION:
				PartyOperationResultHandler(pData);
				break;

			case MSGID_SERVERSTOCKMSG:
				ServerStockMsgHandler(pData);
				break;

			case MSGID_SENDSERVERSHUTDOWNMSG:

				wp = (WORD *)(pData + INDEX2_MSGTYPE + 2);
				switch (*wp) 
				{
				case 1:
					PutLogList("(!) Send server shutdown announcement - 1.");
					for (i = 1; i < MAXCLIENTS; i++)
						if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
							SendNotifyMsg(NULL, i, NOTIFY_SERVERSHUTDOWN, 1, NULL, NULL, NULL);
						}
						break;

				case 2:
					PutLogList("(!) Send server shutdown announcement - 2.");
					for (i = 1; i < MAXCLIENTS; i++)
						if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
							SendNotifyMsg(NULL, i, NOTIFY_SERVERSHUTDOWN, 2, NULL, NULL, NULL);
						}
						break;
				}
				bSendMsgToLS(MSGID_SENDSERVERSHUTDOWNMSG, NULL, NULL); 
				break;

			case MSGID_GAMESERVERSHUTDOWNED:

				m_cShutDownCode      = 1;
				m_bOnExitProcess     = TRUE;
				m_dwExitProcessTime  = timeGetTime();

				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Global command)!!!");
				bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);

				if (m_iMiddlelandMapIndex > 0) {
					// Crusade
					SaveOccupyFlagData();
					//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
					//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
				}
				break;

			case MSGID_TOTALGAMESERVERCLIENTS:
				wp = (WORD *)(pData + INDEX2_MSGTYPE + 2);
				m_iTotalGameServerClients = (int)*wp;
				if (m_iTotalGameServerClients > m_iTotalGameServerMaxClients) 
					m_iTotalGameServerMaxClients = m_iTotalGameServerClients;
				break;

			case MSGID_RESPONSE_REGISTERGAMESERVER:
				switch (*wpMsgType) 
				{
				case MSGTYPE_CONFIRM:
					GSID = bGetOffsetValue(pData, 6);
					ZeroMemory(cGSReg, sizeof(cGSReg));
					//wsprintf(cGSReg,"(*) Game Server registration to Log Server - Success! GSID[%u]",GSID);
					//PutLogList(cGSReg);
					m_bIsGameServerRegistered = TRUE;
					break;

				case MSGTYPE_REJECT:
					PutLogList("(ERROR) Game Server registration to Log Server - Fail!");
					break;
				}
				if(ReceivedAllConfig) break;

				if (m_bIsBuildItemAvailable == FALSE) {
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Build-Item configuration error.");
				}

				if (m_bIsItemAvailable == FALSE) {
					PutLogList(" ");
					PutLogList("(ERROR) STOPPED! Item configuration error.");
				}

				if (m_bIsNpcAvailable == FALSE) {
					PutLogList(" ");
					PutLogList("(ERROR) STOPPED! Npc configuration error.");
				}

				if (m_bIsMagicAvailable == FALSE) {
					PutLogList(" ");
					PutLogList("(ERROR) STOPPED! MAGIC configuration error.");
				}

				if (m_bIsSkillAvailable == FALSE) {
					PutLogList(" ");
					PutLogList("(ERROR) STOPPED! SKILL configuration error.");
				}

				if (m_bIsQuestAvailable == FALSE) {
					PutLogList(" ");
					PutLogList("(ERROR) STOPPED! QUEST configuration error.");
				}

				if (m_bIsPotionAvailable == FALSE) {
					PutLogList(" ");
					PutLogList("(ERROR) STOPPED! POTION configuration error.");
				}

				ReceivedAllConfig = TRUE;
				break;

			case MSGID_RESPONSE_PLAYERDATA:
				ResponsePlayerDataHandler(pData, dwMsgSize);
				break;

			case MSGID_BUILDITEMCONFIGURATIONCONTENTS:
				// Build Item contents
				//PutLogList("(!) BUILD-ITEM configuration contents received. Now decoding...");
				m_bIsBuildItemAvailable = _bDecodeBuildItemConfigFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_ITEMCONFIGURATIONCONTENTS:
				//PutLogList("(!) ITEM configuration contents received. Now decoding...");
				m_bIsItemAvailable = _bDecodeItemConfigFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_NPCCONFIGURATIONCONTENTS:
				//PutLogList("(!) NPC configuration contents received. Now decoding...");
				m_bIsNpcAvailable = _bDecodeNpcConfigFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_MAGICCONFIGURATIONCONTENTS:
				//PutLogList("(!) MAGIC configuration contents received. Now decoding...");
				m_bIsMagicAvailable = _bDecodeMagicConfigFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_SKILLCONFIGURATIONCONTENTS:
				//PutLogList("(!) SKILL configuration contents received. Now decoding...");
				m_bIsSkillAvailable = _bDecodeSkillConfigFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_QUESTCONFIGURATIONCONTENTS:
				//PutLogList("(!) QUEST configuration contents received. Now decoding...");
				m_bIsQuestAvailable = _bDecodeQuestConfigFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_POTIONCONFIGURATIONCONTENTS:
				//PutLogList("(!) POTION configuration contents received. Now decoding...");
				m_bIsPotionAvailable = _bDecodePotionConfigFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_DUPITEMIDFILECONTENTS:
				//PutLogList("(!) DupItemID file contents received. Now decoding...");
				_bDecodeDupItemIDFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_NOTICEMENTFILECONTENTS:
				//PutLogList("(!) Noticement file contents received. Now decoding...");
				_bDecodeNoticementFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_CRAFTINGCONFIGURATIONCONTENTS:
				_bDecodeCraftingConfigFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break; 

			case MSGID_TELEPORTLISTCONTENTS:
				//PutLogList("(!) TeleportListConfig file contents received. Now decoding...");
				_bDecodeTeleportListConfigFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_RESPONSE_LGNPTS:
				SendNotifyMsg(NULL, *(WORD *)(pData+ INDEX2_MSGTYPE + 2), NOTIFY_LGNPTS, 
					*(DWORD *)(pData+ INDEX2_MSGTYPE + 2 + 2), NULL, NULL, NULL);
				break;
			case MSGID_RESPONSE_LGNSVC:
				HandleLegionService(pData);
				break;
			case MSGID_CONFIRMEDIP:
				ConfirmedIP data;
				strcpy(data.ip, pData+ INDEX2_MSGTYPE);
				data.timeReceived = timeGetTime();
				confirmedIPs.push_back(data);
				break;
			}
			break;
		}
	}
}


bool CGame::bPutMsgQuene(char cFrom, char * pData, DWORD dwMsgSize, int iIndex, char cKey)
{
	/*
	HANDLE hMutex;

	hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, m_cServerName);
	if (hMutex != NULL) return FALSE; 
	hMutex = CreateMutex(NULL, FALSE, m_cServerName);
	*/
	if (m_pMsgQuene[m_iQueneTail] != NULL) return FALSE;

	m_pMsgQuene[m_iQueneTail] = new class CMsg;
	if (m_pMsgQuene[m_iQueneTail] == NULL) return FALSE;

	if (m_pMsgQuene[m_iQueneTail]->bPut(cFrom, pData, dwMsgSize, iIndex, cKey) == FALSE) return FALSE;

	m_iQueneTail++;
	if (m_iQueneTail >= MSGQUENESIZE) m_iQueneTail = 0;

	//ReleaseMutex(hMutex);

	return TRUE;
}


bool CGame::bGetMsgQuene(char * pFrom, char * pData, DWORD * pMsgSize, int * pIndex, char * pKey)
{
	/*
	HANDLE hMutex;

	hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, m_cServerName);
	if (hMutex != NULL) return FALSE; 
	hMutex = CreateMutex(NULL, FALSE, m_cServerName);
	*/

	if (m_pMsgQuene[m_iQueneHead] == NULL) return FALSE;

	m_pMsgQuene[m_iQueneHead]->Get(pFrom, pData, pMsgSize, pIndex, pKey);

	delete m_pMsgQuene[m_iQueneHead];
	m_pMsgQuene[m_iQueneHead] = NULL;

	m_iQueneHead++;
	if (m_iQueneHead >= MSGQUENESIZE) m_iQueneHead = 0;

	//ReleaseMutex(hMutex);

	return TRUE;
}


void CGame::ClientCommonHandler(int iClientH, char * pData)
{
	WORD * wp, wCommand;
	short * sp, sX, sY; 
	int   * ip, iV1, iV2, iV3, iV4;
	char  * cp, cDir, * pString;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	wp = (WORD *)(pData + INDEX2_MSGTYPE);
	wCommand = *wp;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	cDir = *cp;
	cp++;

	ip = (int *)cp;
	iV1 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV2 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV3 = *ip;
	cp += 4;

	pString = cp;
	cp += 30;

	ip = (int *)cp;
	iV4 = *ip;
	cp += 4;


	switch (wCommand) {


	case COMMONTYPE_REQ_CREATESLATE:
		ReqCreateSlateHandler(iClientH, pData);
		break;

	case COMMONTYPE_REQGUILDNAME:
		RequestGuildNameHandler(iClientH, iV1, iV2);
		break;

	case COMMONTYPE_UPGRADEITEM:
		RequestItemUpgradeHandler(iClientH, iV1);
		break;

	case COMMONTYPE_REQUEST_ACCEPTJOINPARTY:
		RequestAcceptJoinPartyHandler(iClientH, iV1);
		break;

	case COMMONTYPE_SETGUILDTELEPORTLOC:
		RequestSetGuildTeleportLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, pString);
		break;

	case COMMONTYPE_SETGUILDCONSTRUCTLOC:
		RequestSetGuildConstructLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, pString);
		break;

	case COMMONTYPE_GUILDTELEPORT:
		RequestGuildTeleportHandler(iClientH);
		break;

	case COMMONTYPE_SUMMONWARUNIT:
		RequestSummonWarUnitHandler(iClientH, sX, sY, iV1, iV2, iV3);
		break;

	case COMMONTYPE_REQUEST_HELP:
		RequestHelpHandler(iClientH);
		break;

	case COMMONTYPE_REQUEST_MAPSTATUS:
		MapStatusHandler(iClientH, iV1, pString);
		break;

	case COMMONTYPE_REQUEST_SELECTCRUSADEDUTY:
		SelectCrusadeDutyHandler(iClientH, iV1);
		break;

	case COMMONTYPE_REQUEST_CANCELQUEST:
		CancelQuestHandler(iClientH);
		break;

	case COMMONTYPE_REQUEST_ACTIVATESPECABLTY:
		ActivateSpecialAbilityHandler(iClientH);
		break;

	case COMMONTYPE_REQUEST_JOINPARTY:
		JoinPartyHandler(iClientH, iV1, pString);
		break;

		//case COMMONTYPE_REQUEST_CREATENEWPARTY:
		//	CreateNewPartyHandler(iClientH);
		//	break;

	case COMMONTYPE_GETMAGICABILITY:
		GetMagicAbilityHandler(iClientH);
		break;

	case COMMONTYPE_BUILDITEM:
		BuildItemHandler(iClientH, pData);
		break;

	case COMMONTYPE_QUESTACCEPTED:
		QuestAcceptedHandler(iClientH);
		break;

	case COMMONTYPE_CANCELEXCHANGEITEM:
		CancelExchangeItem(iClientH);
		break;

	case COMMONTYPE_CONFIRMEXCHANGEITEM:
		ConfirmExchangeItem(iClientH);
		break;

	case COMMONTYPE_SETEXCHANGEITEM:
		SetExchangeItem(iClientH, iV1, iV2);
		break;

	case COMMONTYPE_REQ_GETHEROMANTLE:
		GetHeroMantleHandler(iClientH, iV1, pString);
		break;

	case COMMONTYPE_REQ_GETOCCUPYFLAG:
		GetOccupyFlagHandler(iClientH);
		break;

	case COMMONTYPE_REQ_SETDOWNSKILLINDEX:
		SetDownSkillIndexHandler(iClientH, iV1);
		break;

	case COMMONTYPE_TALKTONPC:
		NpcTalkHandler(iClientH, iV1);
		break;

	case COMMONTYPE_REQ_CREATEPOTION:
		ReqCreatePotionHandler(iClientH, pData);
		break;

	case COMMONTYPE_REQ_GETFISHTHISTIME:
		ReqGetFishThisTimeHandler(iClientH);
		break;

	case COMMONTYPE_REQ_REPAIRITEMCONFIRM:
		ReqRepairItemCofirmHandler(iClientH, iV1, pString);
		break;

	case COMMONTYPE_REQ_REPAIRITEM:
		ReqRepairItemHandler(iClientH, iV1, iV2, pString);
		break;

	case COMMONTYPE_REQ_SELLITEMCONFIRM:
		ReqSellItemConfirmHandler(iClientH, iV1, iV2, pString);
		break;

	case COMMONTYPE_REQ_SELLITEM:
		ReqSellItemHandler(iClientH, iV1, iV2, iV3, pString);
		break;

	case COMMONTYPE_REQ_USESKILL:
		UseSkillHandler(iClientH, iV1, iV2, iV3);
		break;

	case COMMONTYPE_REQ_USEITEM:
		UseItemHandler(iClientH, iV1, iV2, iV3, iV4);
		break;

	case COMMONTYPE_REQ_GETREWARDMONEY:
		GetRewardMoneyHandler(iClientH);
		break;

	case COMMONTYPE_ITEMDROP:
		DropItemHandler(iClientH, iV1, iV2, pString, TRUE);
		break;

	case COMMONTYPE_EQUIPITEM:
		bEquipItemHandler(iClientH, iV1);
		break;

	case COMMONTYPE_REQ_PURCHASEITEM:
		RequestPurchaseItemHandler(iClientH, pString, iV1);
		break;

	case COMMONTYPE_REQ_STUDYMAGIC:
		RequestStudyMagicHandler(iClientH, pString);
		break;

	case COMMONTYPE_REQ_TRAINSKILL:
		//RequestTrainSkillHandler(iClientH, pString);
		break;

	case COMMONTYPE_GIVEITEMTOCHAR:
		GiveItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case COMMONTYPE_EXCHANGEITEMTOCHAR:
		ExchangeItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case COMMONTYPE_JOINGUILDAPPROVE:
		JoinGuildApproveHandler(iClientH, pString);
		break;

	case COMMONTYPE_JOINGUILDREJECT:
		JoinGuildRejectHandler(iClientH, pString);
		break;

	case COMMONTYPE_DISMISSGUILDAPPROVE:
		DismissGuildApproveHandler(iClientH, pString);
		break;

	case COMMONTYPE_DISMISSGUILDREJECT:
		DismissGuildRejectHandler(iClientH, pString);
		break;

	case COMMONTYPE_RELEASEITEM:
		ReleaseItemHandler(iClientH, iV1, TRUE);
		break;

	case COMMONTYPE_TOGGLECOMBATMODE:
		ToggleCombatModeHandler(iClientH);
		break;

	case COMMONTYPE_MAGIC:
		if(m_pClientList[iClientH]->m_hasPrecasted || m_pClientList[iClientH]->IsGM())
		PlayerMagicHandler(iClientH, iV1, iV2, (iV3 - 100));
		break;

	case COMMONTYPE_TOGGLESAFEATTACKMODE:
		ToggleSafeAttackModeHandler(iClientH);
		break;

	case COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET:
		GetFightzoneTicketHandler(iClientH);
		break;

	case COMMONTYPE_CRAFTITEM:
		ReqCreateCraftingHandler(iClientH, pData);
		break; 
	}
}


void CGame::DropItemHandler(int iClientH, short sItemIndex, int iAmount, char * pItemName, bool bByPlayer)
{
	CItem * pItem;
	CClient * player = m_pClientList[iClientH];
	if (!player || player->m_bIsOnWaitingProcess || !player->m_bIsInitComplete) return;

	if (sItemIndex < 0 || sItemIndex >= MAXITEMS) return;

	CItem * &itemDrop = player->m_pItemList[sItemIndex];
	if (!itemDrop) return;
	if (iAmount != -1 && iAmount < 0) return;

	if( (itemDrop->m_cItemType == ITEMTYPE_CONSUME || 
		itemDrop->m_cItemType == ITEMTYPE_ARROW) &&
		iAmount == -1) 
		iAmount = itemDrop->m_dwCount;


	if(memcmp(itemDrop->m_cName, pItemName, 20) != 0) return;
	if(m_pMapList[ player->m_cMapIndex ]->iCheckItem(player->m_sX, player->m_sY) == ITEM_RELIC)
		return;

	if ( ( (itemDrop->m_cItemType == ITEMTYPE_CONSUME) ||
		(itemDrop->m_cItemType == ITEMTYPE_ARROW) ) &&
		(((int)itemDrop->m_dwCount - iAmount) > 0) ) {
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, itemDrop->m_cName) == FALSE) {

				delete pItem;
				return;
			}
			else {
				if (iAmount <= 0) {

					delete pItem;
					return;
				}
				pItem->m_dwCount = (DWORD)iAmount;
			}


			if ((DWORD)iAmount > itemDrop->m_dwCount) {
				delete pItem;
				return;
			}

			itemDrop->m_dwCount -= iAmount;

			SetItemCount(iClientH, sItemIndex, itemDrop->m_dwCount);

			m_pMapList[ player->m_cMapIndex ]->bSetItem(player->m_sX,	player->m_sY, pItem);

			if ( bByPlayer == TRUE )
				_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, pItem);
			else 
				_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, pItem, TRUE);

			AddGroundItem(pItem, player->m_sX, player->m_sY, player->m_cMapIndex, TILECLEANTIMEPLAYER);

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, player->m_cMapIndex,
				player->m_sX, player->m_sY,  
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 

			SendNotifyMsg(NULL, iClientH, NOTIFY_DROPITEMFIN_COUNTCHANGED, sItemIndex, iAmount, NULL, NULL);
	}
	else {

		ReleaseItemHandler(iClientH, sItemIndex, TRUE);

		if ( player->m_bIsItemEquipped[sItemIndex] == TRUE)
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, itemDrop->m_cEquipPos, sItemIndex, NULL, NULL);

		if ((itemDrop->m_sItemEffectType == ITEMEFFECTTYPE_ALTERITEMDROP) && 
			(itemDrop->m_wCurLifeSpan == 0)) {
				delete itemDrop;
				itemDrop = NULL;
		}
		else {
			if(itemDrop->m_sIDnum != ITEM_RELIC || (m_astoria.get() &&
				m_astoria->IsRelicGenuine(itemDrop)))
			{
				if(itemDrop->m_sIDnum == ITEM_RELIC)
				{
					m_astoria->PlayerDropRelic(player);		
					UpdateRelicPos();
				}
				else
					AddGroundItem(itemDrop, player->m_sX, player->m_sY, player->m_cMapIndex, TILECLEANTIMEPLAYER);

				m_pMapList[ player->m_cMapIndex ]->bSetItem(player->m_sX, player->m_sY, 
					itemDrop);

				if ( bByPlayer == TRUE )
					_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, itemDrop);
				else 
					_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, itemDrop, TRUE);

				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, player->m_cMapIndex,
					player->m_sX, player->m_sY,  
					itemDrop->m_sSprite, 
					itemDrop->m_sSpriteFrame, 
					itemDrop->m_cItemColor);
			}else{
				// delete the fake relic
				delete itemDrop;
			}
		}

		itemDrop = NULL;
		player->m_bIsItemEquipped[sItemIndex] = FALSE;

		SendNotifyMsg(NULL, iClientH, NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, NULL);

		player->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}

	iCalcTotalWeight(iClientH);
}

int CGame::iClientMotion_GetItem_Handler(int iClientH, short sX, short sY, char cDir)
{
	DWORD * dwp;
	WORD  * wp;
	short sRemainItemSprite, sRemainItemSpriteFrame;
	char  cRemainItemColor, cData[100];
	int   iRet, iEraseReq;
	class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;


	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->IncPlayerActivity(m_pClientList[iClientH]);
	}

	if(m_pClientList[iClientH]->m_bSkillUsingStatus[19]) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(/*0,*/ iClientH, OWNERTYPE_PLAYER, sX, sY);
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, OWNERTYPE_PLAYER, sX, sY);
	}

	ClearSkillUsingStatus(iClientH);

	pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(sX, sY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor); 
	if (pItem != NULL) {

		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {

			if(m_astoria.get() && m_astoria->IsRelicGenuine(pItem))
			{
				m_astoria->PlayerGetRelic(m_pClientList[iClientH]);
			}
			_bItemLog(ITEMLOG_GET, iClientH, (int) -1, pItem);

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor);

			SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);
			if (iEraseReq == 1) delete pItem;
			if (m_pClientList[iClientH] == NULL) return 0;
		}
		else 
		{

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(sX, sY, pItem);

			SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
			if (m_pClientList[iClientH] == NULL) return 0;
		}
	}

	dwp  = (DWORD *)(cData + INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + INDEX2_MSGTYPE);
	*wp  = OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}

bool CGame::_bAddClientItemList(int iClientH, class CItem * pItem, int * pDelReq)
{
	register int i;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (pItem == NULL) return FALSE;


	if ((pItem->m_cItemType == ITEMTYPE_CONSUME) || (pItem->m_cItemType == ITEMTYPE_ARROW)) {
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount)) > _iCalcMaxLoad(iClientH)) 
			return FALSE;
	}
	else {
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, 1)) > _iCalcMaxLoad(iClientH)) 
			return FALSE;
	}

	if ((pItem->m_cItemType == ITEMTYPE_CONSUME) || (pItem->m_cItemType == ITEMTYPE_ARROW)) {
		for (i = 0; i < MAXITEMS; i++)
			if ( (m_pClientList[iClientH]->m_pItemList[i] != NULL) && 
				(memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, pItem->m_cName, 20) == 0) ) {

					m_pClientList[iClientH]->m_pItemList[i]->m_dwCount += pItem->m_dwCount;
					//delete pItem;
					*pDelReq = 1;

					iCalcTotalWeight(iClientH);

					return TRUE;
			}
	}

	for (i = 0; i < MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {

			m_pClientList[iClientH]->m_pItemList[i] = pItem;

			m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
			m_pClientList[iClientH]->m_ItemPosList[i].y = 30;

			*pDelReq = 0;

			if (pItem->m_cItemType == ITEMTYPE_ARROW)
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

			iCalcTotalWeight(iClientH);

			return TRUE;
		}

	return FALSE;
}


bool CGame::bEquipItemHandler(int iClientH, short sItemIndex, bool bNotify)
{
	char  cEquipPos;
	short sSpeed, sTemp;
	int   iTemp;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != ITEMTYPE_EQUIP) return FALSE;


	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0) return FALSE;


	if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) == NULL)  &&
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sLevelLimit > m_pClientList[iClientH]->m_iLevel)) return FALSE;

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 0) {
		switch (m_pClientList[iClientH]->m_sType) {
		case 1:
		case 2:
		case 3:

			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 1) return FALSE;
			break;
		case 4:
		case 5:
		case 6:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 2) return FALSE;
			break;
		}
	}


	if (iGetItemWeight(m_pClientList[iClientH]->m_pItemList[sItemIndex], 1) > m_pClientList[iClientH]->GetStr()*100) return FALSE;

	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;

	if (cEquipPos == EQUIPPOS_LHAND && m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isShieldDisabled == true && !m_pClientList[iClientH]->IsGM()){
		SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
		ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
		return FALSE;
	}

	if ((cEquipPos == EQUIPPOS_BODY) || (cEquipPos == EQUIPPOS_LEGGINGS) || (cEquipPos == EQUIPPOS_ARMS) || (cEquipPos == EQUIPPOS_HEAD)) {
		if(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isArmorDisabled == true && !m_pClientList[iClientH]->IsGM()){
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
			return FALSE;
		}
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4) {
		case 10: 
			if (m_pClientList[iClientH]->GetStr() < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 11: // Dex
			if (m_pClientList[iClientH]->GetDex() < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 12: 
			if (m_pClientList[iClientH]->m_iVit < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 13: // Int
			if (m_pClientList[iClientH]->GetInt() < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 14: // Mag
			if (m_pClientList[iClientH]->GetMag() < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 15: // Chr
			if (m_pClientList[iClientH]->m_iRange < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		}
	}

	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_RESURWAND_MS10) || 
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_RESURWAND_MS20)) {
		if(m_pClientList[iClientH]->GetInt() >= 100 && m_pClientList[iClientH]->GetMag() >= 100 &&  
			m_pClientList[iClientH]->m_iSpecialAbilityTime < 1)
		{
			m_pClientList[iClientH]->m_cMagicMastery[94] = TRUE; //Resurrection
			SendNotifyMsg(NULL, iClientH, NOTIFY_SPELL_SKILL, NULL, NULL, NULL, NULL);
		}
	}

	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == ITEMEFFECTTYPE_ATTACK_SPECABLTY) || 
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == ITEMEFFECTTYPE_DEFENSE_SPECABLTY)) {

			if (m_pClientList[iClientH]->m_iSpecialAbilityType != 0) {
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos != m_pClientList[iClientH]->m_iSpecialAbilityEquipPos) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, m_pClientList[iClientH]->m_sItemEquipmentStatus[ m_pClientList[iClientH]->m_iSpecialAbilityEquipPos ], NULL, NULL);
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ m_pClientList[iClientH]->m_iSpecialAbilityEquipPos ], TRUE);
				}
			}
	}

	if (cEquipPos == EQUIPPOS_NONE) return FALSE;

	if (cEquipPos == EQUIPPOS_TWOHAND) {
		if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
		else {
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_RHAND ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_RHAND ], FALSE);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_LHAND ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_LHAND ], FALSE);
		}
	}
	else {

		if ((cEquipPos == EQUIPPOS_LHAND) || (cEquipPos == EQUIPPOS_RHAND)) {
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_TWOHAND ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_TWOHAND ], FALSE);
		}

		if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
	}

	if(cEquipPos == EQUIPPOS_FULLBODY) {
		if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
		else {
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_HEAD ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_HEAD ], FALSE);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_BODY ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_BODY ], TRUE);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_ARMS ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_ARMS ], FALSE);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_LEGGINGS ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_LEGGINGS ], FALSE);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_PANTS ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_PANTS ], FALSE);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_BACK ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_BACK ], FALSE);

		}
	}
	else
	{
		if ((cEquipPos == EQUIPPOS_HEAD) 
			|| (cEquipPos == EQUIPPOS_BODY)
			|| (cEquipPos == EQUIPPOS_ARMS)
			|| (cEquipPos == EQUIPPOS_LEGGINGS)
			|| (cEquipPos == EQUIPPOS_PANTS)
			|| (cEquipPos == EQUIPPOS_BACK)) {
				if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_FULLBODY ] != -1) 
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_FULLBODY ], FALSE);
		}

		if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);

	}
	m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = sItemIndex;
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = TRUE;


	switch (cEquipPos) {
	case EQUIPPOS_RHAND:
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;			
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); 
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0x0FFFFFFF; 		
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
		m_pClientList[iClientH]->m_iApprColor = iTemp;

		iTemp = m_pClientList[iClientH]->m_iStatus;
		iTemp = iTemp & 0xFFFFFFF0;
		sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);

		//m_pClientList[iClientH]->m_sUsingWeaponSkill = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ;

#ifdef WEAPONSPEEDLIMIT
		sSpeed -= (m_pClientList[iClientH]->GetStr() / 13);
		////switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill) 
		////{
		//////case SKILL_ARCHERY:  if (sSpeed < 1) sSpeed = 1; break; 		
		//////case SKILL_SHORTSWORD:  if (sSpeed < 0) sSpeed = 0; break; 
		//////case SKILL_LONGSWORD:  if (sSpeed < 2) sSpeed = 2; break; 		
		//////case SKILL_FENCING:  if (sSpeed < 1) sSpeed = 1; break; 
		//////case SKILL_AXE: if (sSpeed < 3) sSpeed = 1; break; 		
		////case SKILL_HAMMER: if (sSpeed < 1) sSpeed = 1; break; 		
		////default: if (sSpeed < 0) sSpeed = 0; break; 		
		////}			
#else
		sSpeed -= (m_pClientList[iClientH]->GetStr() / 13);
		if (sSpeed < 0) sSpeed = 0;	
#endif
		sTemp = sTemp | sSpeed;
		m_pClientList[iClientH]->m_iStatus = iTemp;

		m_pClientList[iClientH]->m_iComboAttackCount = 0;
		break;

	case EQUIPPOS_LHAND:
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xFFF0;			
		sTemp = sTemp | (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue); 
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xF0FFFFFF; 		
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 24);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_TWOHAND:

		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;			
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); 
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0x0FFFFFFF; 		
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
		m_pClientList[iClientH]->m_iApprColor = iTemp;

		iTemp = m_pClientList[iClientH]->m_iStatus;
		iTemp = iTemp & 0xFFFFFFF0;
		sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);



	//	m_pClientList[iClientH]->m_sUsingWeaponSkill = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ;


#ifdef WEAPONSPEEDLIMIT
		sSpeed -= (m_pClientList[iClientH]->GetStr() / 13);
		//switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill) 
		//{
		////case SKILL_ARCHERY:  if (sSpeed < 1) sSpeed = 1; break; 		
		////case SKILL_SHORTSWORD:  if (sSpeed < 0) sSpeed = 0; break; 
		////case SKILL_LONGSWORD:  if (sSpeed < 2) sSpeed = 2; break; 		
		////case SKILL_FENCING:  if (sSpeed < 1) sSpeed = 1; break; 
		////case SKILL_AXE: if (sSpeed < 3) sSpeed = 1; break; 		
		//case SKILL_HAMMER: if (sSpeed < 1) sSpeed = 1; break; 		
		//default: if (sSpeed < 0) sSpeed = 0; break; 		
		//}	
#else
		sSpeed -= (m_pClientList[iClientH]->GetStr() / 13);
		if (sSpeed < 0) sSpeed = 0;
#endif

		iTemp = iTemp | sSpeed;
		m_pClientList[iClientH]->m_iStatus = iTemp;

		m_pClientList[iClientH]->m_iComboAttackCount = 0;
		break;

	case EQUIPPOS_BODY:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;

		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue < 100) {
			sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); 
			m_pClientList[iClientH]->m_sAppr3 = sTemp;
		}
		else {
			sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue - 100) << 12); 
			m_pClientList[iClientH]->m_sAppr3 = sTemp;

			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp | 0x080;
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
		}

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFF0FFFFF; 
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 20);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_BACK:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xF0FF;			
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8); 
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFF0FFFF; 		
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 16);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_ARMS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFFF0;			
		sTemp = sTemp | (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue); 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFFF0FFF; 		
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 12);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_PANTS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xF0FF;			
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8); 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFFFF0FF; 		
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 8);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_LEGGINGS:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0x0FFF;
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); 
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFFFFF0F; 
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 4);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_HEAD:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFF0F;			
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFFFFFF0; 		
		iTemp = iTemp | (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_FULLBODY: 
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFF0FFFF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;
	}
	
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == ITEMEFFECTTYPE_ATTACK_SPECABLTY) {

		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;     // 1111111111110011   
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
		case 0: break;
		case 1: 
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0004;	// 0100
			break;

		case 2: 
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x000C;	// 1100
			break;

		case 3: 			
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0008;	// 1000
			break;
		}
	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == ITEMEFFECTTYPE_DEFENSE_SPECABLTY) {
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC; // 1111111111111100
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
		case 0: break;
		case 50: 
		case 51:
		case 52: 
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0002;	// 10
			break;

		default: 
			if (m_pClientList[iClientH]->m_iAdminUserLevel < 1 ) break ;
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0001;	 // 01
			break;
		}
	}

	SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTNULLACTION, NULL, NULL, NULL);

	CalcTotalItemEffect(iClientH, sItemIndex, bNotify);

	sTemp = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum;
	if (sTemp == ITEM_ANGELICPENDANT_DEX ||
		sTemp == ITEM_ANGELICPENDANT_INT ||
		sTemp == ITEM_ANGELICPENDANT_MAG ||
		sTemp == ITEM_ANGELICPENDANT_STR)
		SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);

	return TRUE;
}


void CGame::SendEventToNearClient_TypeB(DWORD dwMsgID, WORD wMsgType, char cMapIndex, short sX, short sY, short sV1, short sV2, short sV3, short sV4)
{
	int i, iRet, iShortCutIndex;
	char  * cp, cData[100];
	DWORD * dwp, dwTime;
	WORD * wp;
	short * sp;
	bool bFlag;
	char  cKey ;

	cKey = (char)(rand() % 255) +1; 

	ZeroMemory(cData, sizeof(cData));

	dwp  = (DWORD *)(cData + INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData + INDEX2_MSGTYPE);
	*wp  = wMsgType;

	cp = (char *)(cData + INDEX2_MSGTYPE + 2);

	sp  = (short *)cp;
	*sp = sX;
	cp += 2;

	sp  = (short *)cp;
	*sp = sY;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV1;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV2;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV3;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV4;
	cp += 2;

	dwTime = timeGetTime();

	bFlag = TRUE;
	iShortCutIndex = 0;

	CClient * pClient;
	while (bFlag == TRUE) {

		i = m_iClientShortCut[iShortCutIndex];
		iShortCutIndex++;
		if (i == 0) bFlag = FALSE;

		pClient = m_pClientList[i];
		if ((bFlag == TRUE) && (pClient != NULL)) {
			if ( (pClient->m_cMapIndex == cMapIndex) &&
				(pClient->m_sX >= sX - 10) &&
				(pClient->m_sX <= sX + 10) &&
				(pClient->m_sY >= sY - 8 ) &&
				(pClient->m_sY <= sY + 8 ) ) {

					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 18,cKey);
			}
		}
	}
}

int CGame::iClientMotion_Stop_Handler(int iClientH, short sX, short sY, char cDir)
{
	char cData[100];
	DWORD * dwp;
	WORD  * wp;
	int     iRet;
	short   sOwnerH;
	char    cOwnerType;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;


	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;


	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, sX, sY);
		if (sOwnerH != NULL) {
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(/*0,*/ iClientH, OWNERTYPE_PLAYER, sX, sY);
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, OWNERTYPE_PLAYER, sX, sY);
	}

	ClearSkillUsingStatus(iClientH);

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->IncPlayerActivity(m_pClientList[iClientH]);
	}

	m_pClientList[iClientH]->m_cDir = cDir;

	dwp  = (DWORD *)(cData + INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + INDEX2_MSGTYPE);
	*wp  = OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}

void CGame::ResponseCreateNewGuildHandler(char * pData, DWORD dwMsgSize)
{
	register int i;
	WORD  * wp, wResult;
	DWORD * dwp;
	char  * cp, cCharName[11], cData[100], cTxt[120];
	int iRet;

	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;

	for (i = 1; i < MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) &&
			(m_pClientList[i]->m_iLevel >= 20) && (m_pClientList[i]->m_iRange >= 20))
		{

			wp = (WORD *)(pData + INDEX2_MSGTYPE);
			switch (*wp) {
			case LOGRESMSGTYPE_CONFIRM:
				wResult = MSGTYPE_CONFIRM;
				m_pClientList[i]->m_iGuildRank = 0;
				wsprintf(cTxt, "(!) New guild(%s) creation success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
				PutLogList(cTxt);

#ifdef TAIWANLOG 
				_bItemLog(ITEMLOG_CREATEGUILD,i, (char *)NULL, NULL) ;
#endif
				break;

			case LOGRESMSGTYPE_REJECT:
				wResult = MSGTYPE_REJECT;
				ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
				memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
				m_pClientList[i]->m_iGuildRank = -1;  
				m_pClientList[i]->m_iGuildGUID = -1;
				wsprintf(cTxt, "(!) New guild(%s) creation Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
				PutLogList(cTxt);
				break;
				}

				dwp  = (DWORD *)(cData + INDEX4_MSGID);
				*dwp = MSGID_RESPONSE_CREATENEWGUILD;
				wp   = (WORD *)(cData + INDEX2_MSGTYPE);
				*wp  = wResult;

				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
			case XSOCKEVENT_QUENEFULL:
			case XSOCKEVENT_SOCKETERROR:
			case XSOCKEVENT_CRITICALERROR:
			case XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(i, TRUE, TRUE);
				return;
			}

			return;
		}

		wsprintf(cTxt, "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
		PutLogList(cTxt);
}

void CGame::RequestCreateNewGuildHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
	char * cp, cGuildName[21], cTxt[120], cData[100];
	DWORD * dwp;
	WORD  * wp;
	int     iRet;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_bIsCrusadeMode == TRUE) return;

	cp = (char *)(pData	+ INDEX2_MSGTYPE + 2);

	cp += 10;
	cp += 10;
	cp += 10;

	ZeroMemory(cGuildName, sizeof(cGuildName));
	memcpy(cGuildName, cp, 20);
	cp += 20;

	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		wsprintf(cTxt, "(!)Cannot create guild! Already guild member.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	}
	else {
		if (m_pClientList[iClientH]->m_iLevel < 20 ||
			m_pClientList[iClientH]->m_iRange < 20 ||
			m_pClientList[iClientH]->IsNeutral()	||
			m_pClientList[iClientH]->m_iIsOnTown == PK ) 
		{

				ZeroMemory(cData, sizeof(cData));

				dwp  = (DWORD *)(cData + INDEX4_MSGID);
				*dwp = MSGID_RESPONSE_CREATENEWGUILD;
				wp   = (WORD *)(cData + INDEX2_MSGTYPE);
				*wp  = MSGTYPE_REJECT;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) 
				{
				case XSOCKEVENT_QUENEFULL:
				case XSOCKEVENT_SOCKETERROR:
				case XSOCKEVENT_CRITICALERROR:
				case XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
		}
		else {
			ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
			strcpy(m_pClientList[iClientH]->m_cGuildName, cGuildName);
			ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
			strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iGuildGUID = (int)(SysTime.wYear + SysTime.wMonth + SysTime.wDay + SysTime.wHour + SysTime.wMinute + timeGetTime());

			bSendMsgToLS(MSGID_REQUEST_CREATENEWGUILD, iClientH);
		}
	}
}


void CGame::RequestDisbandGuildHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
	char * cp, cGuildName[21], cTxt[120];

	if (m_bIsCrusadeMode == TRUE) return;

	cp = (char *)(pData	+ INDEX2_MSGTYPE + 2);
	ZeroMemory(cGuildName, sizeof(cGuildName));

	cp += 10;
	cp += 10;
	cp += 10;

	memcpy(cGuildName, cp, 20);
	cp += 20;

	if ((m_pClientList[iClientH]->m_iGuildRank != 0) || (memcmp(m_pClientList[iClientH]->m_cGuildName, cGuildName, 20) != 0)) {
		wsprintf(cTxt, "(!)Cannot Disband guild! Not guildmaster.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	}
	else {

#ifdef TAIWANLOG 
		_bItemLog(ITEMLOG_GUILDDISMISS,iClientH, cGuildName, NULL) ;
#endif
		bSendMsgToLS(MSGID_REQUEST_DISBANDGUILD, iClientH);
	}
}

void CGame::ResponseDisbandGuildHandler(char * pData, DWORD dwMsgSize)
{
	register int i;
	WORD  * wp, wResult;
	DWORD * dwp;
	char  * cp, cCharName[11], cData[100], cTxt[120];
	int iRet;

	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;

	for (i = 1; i < MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {

			wp = (WORD *)(pData + INDEX2_MSGTYPE);
			switch (*wp) {
		case LOGRESMSGTYPE_CONFIRM:
			wResult = MSGTYPE_CONFIRM;
			wsprintf(cTxt, "(!) Disband guild(%s) success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);

			SendGuildMsg(i,	NOTIFY_GUILDDISBANDED, NULL, NULL, NULL);
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_CLEARGUILDNAME, m_pClientList[i]->m_cMapIndex,m_pClientList[i]->m_sX, m_pClientList[i]->m_sY,0, 0, 0);

			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
			m_pClientList[i]->m_iGuildRank = -1;					
			m_pClientList[i]->m_iGuildGUID = -1;
			break;

		case LOGRESMSGTYPE_REJECT:
			wResult = MSGTYPE_REJECT;
			wsprintf(cTxt, "(!) Disband guild(%s) Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			break;
			}

			dwp  = (DWORD *)(cData + INDEX4_MSGID);
			*dwp = MSGID_RESPONSE_DISBANDGUILD;
			wp   = (WORD *)(cData + INDEX2_MSGTYPE);
			*wp  = wResult;

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
		case XSOCKEVENT_QUENEFULL:
		case XSOCKEVENT_SOCKETERROR:
		case XSOCKEVENT_CRITICALERROR:
		case XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(i, TRUE, TRUE);
			return;
			}
			return;
		}

		wsprintf(cTxt, "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
		PutLogList(cTxt);
}

void CGame::RequestPurchaseItemHandler(int iClientH, char * pItemName, int iNum)
{
	class CItem * pItem;
	char  * cp, cItemName[21], cData[100];
	DWORD * dwp, dwGoldCount, dwItemCount;
	WORD  * wp, wTempPrice;
	int   i, iRet, iEraseReq, iGoldWeight;
	int   iCost,iCost2, iDiscountRatio, iDiscountCost;
	double dTmp1, dTmp2, dTmp3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	//if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) &&
	//	 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, m_pClientList[iClientH]->m_cLocation, 10) != 0) ) return;


	// if (!m_pClientList[iClientH]->IsNeutral() && m_pClientList[iClientH]->m_bIsOnShop == FALSE ) {
	if ( m_pClientList[iClientH]->m_bIsOnShop == FALSE ) {
		return;
	}

	ZeroMemory(cData, sizeof(cData));
	ZeroMemory(cItemName, sizeof(cItemName));

	if (memcmp(pItemName, ITEMNAME_10ARROWS, 8) == 0) {
		strcpy(cItemName, ITEMNAME_ARROW);
		dwItemCount = 10;
	}
	else if (memcmp(pItemName, ITEMNAME_100ARROWS, 9) == 0) {
		strcpy(cItemName, ITEMNAME_ARROW);
		dwItemCount = 100;
	}
	else {
		memcpy(cItemName, pItemName, 20);
		dwItemCount = 1;
	}

	for (i = 1; i <= iNum; i++) {
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {

			delete pItem;
		}
		else {
			if (pItem->m_bIsForSale == FALSE) {
				delete pItem;
				return;
			}

			pItem->m_dwCount = dwItemCount;

			pItem->m_sTouchEffectType   = ITET_ID;
			pItem->m_sTouchEffectValue1 = dice(1,100000);
			pItem->m_sTouchEffectValue2 = dice(1,100000);

#ifdef LOGTIME
			pItem->m_sTouchEffectValue3 = timeGetTime();
#else 
			SYSTEMTIME SysTime;
			char cTemp[20] ;

			GetLocalTime(&SysTime); //
			ZeroMemory(cTemp, sizeof(cTemp));
			//			wsprintf(cTemp, "%d%02d%02d",  (short)SysTime.wMonth, (short)SysTime.wDay,(short) SysTime.wHour);
			wsprintf(cTemp, "%d%02d%",  (short)SysTime.wMonth, (short)SysTime.wDay);
			pItem->m_sTouchEffectValue3 = atoi(cTemp);
#endif

			if(m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_side)
			{
				iCost =(int)((float)(pItem->m_wPrice) * 0.9f + 0.5f) ;
				iCost = iCost * pItem->m_dwCount;
				iCost2 = pItem->m_wPrice * pItem->m_dwCount;
			}
			else
			{
				iCost2 = iCost = pItem->m_wPrice * pItem->m_dwCount;
			}

			dwGoldCount = dwGetItemCount(iClientH, "Gold");

			iDiscountRatio = ((m_pClientList[iClientH]->m_iRange -10)/ 4) ;

			if (m_iCrusadeWinnerSide != m_pClientList[iClientH]->m_side){ // Lost last Crusade +10% prices
				iDiscountRatio += 10;
			}	


			if (iDiscountRatio <  0 ) iDiscountRatio =  0;	 // Never lower prices
			if (iDiscountRatio > 10 ) iDiscountRatio = 10;	 // Sometimes increase them up to 10%

			dTmp1 = (double)(iDiscountRatio);
			dTmp2 = dTmp1 / 100.0f;
			dTmp1 = (double)iCost;
			dTmp3 = dTmp1 * dTmp2;
			iDiscountCost = (int)dTmp3;

			if ((iCost - iDiscountCost) <= (iCost2/2)) {
				iDiscountCost = iCost - (iCost2/2) + 1; 
			}
			if (m_pClientList[iClientH]->IsHeldLoser()) (iCost = iCost *1.5);

			if ( dwGoldCount < (DWORD)(iCost - iDiscountCost) ) {

				delete pItem;

				dwp  = (DWORD *)(cData + INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + INDEX2_MSGTYPE);
				*wp  = NOTIFY_NOTENOUGHGOLD;
				cp   = (char *)(cData + INDEX2_MSGTYPE + 2);
				*cp  = -1; 
				cp++;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
				switch (iRet) {
				case XSOCKEVENT_QUENEFULL:
				case XSOCKEVENT_SOCKETERROR:
				case XSOCKEVENT_CRITICALERROR:
				case XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				return;
			}

			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

				dwp  = (DWORD *)(cData + INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + INDEX2_MSGTYPE);
				*wp  = NOTIFY_ITEMPURCHASED;

				cp = (char *)(cData + INDEX2_MSGTYPE + 2);

				cp += WriteItemData(cp, pItem);

				wp  = (WORD *)cp;
				*wp = (iCost - iDiscountCost);
				wTempPrice = (iCost - iDiscountCost);
				cp += 2;

				if (iEraseReq == 1){
					delete pItem;
					pItem = NULL;
				}


				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 48);


				iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - wTempPrice);
				iCalcTotalWeight(iClientH);


				m_stCityStatus[m_pClientList[iClientH]->m_side].iFunds += wTempPrice;

				switch (iRet) {
				case XSOCKEVENT_QUENEFULL:
				case XSOCKEVENT_SOCKETERROR:
				case XSOCKEVENT_CRITICALERROR:
				case XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);

					return;
				}
			}
			else 
			{
				delete pItem;

				iCalcTotalWeight(iClientH);

				SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
				if (m_pClientList[iClientH] == NULL) return;
			}
		}
	} // for ??

	if ( i <= 1) return ;
#ifdef TAIWANLOG  
	_bItemLog(ITEMLOG_BUY, iClientH, i - 1, pItem);
#endif
}

void CGame::GiveItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, WORD wObjectID, char * pItemName)
{
	int iEraseReq;
	short sOwnerH;
	char  cOwnerType, cCharName[21];
	class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;	//DEBUG
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= MAXITEMS)) return;
	if (iAmount <= 0) return;

	if (wObjectID < MAXCLIENTS) {
		// Player	
		if( m_pClientList[wObjectID] != NULL && m_pClientList[iClientH]->m_cMapIndex != m_pClientList[wObjectID]->m_cMapIndex) return;
	}
	else if ( (wObjectID > 10000) && (wObjectID < (10000 + MAXNPCS)) ) {
		if( m_pNpcList[wObjectID - 10000] != NULL && m_pClientList[iClientH]->m_cMapIndex != m_pNpcList[wObjectID - 10000]->m_cMapIndex) return;
	}

	if (memcmp(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, pItemName, 20) != 0) {
		PutLogList("GiveItemHandler - Not matching Item name");
		return;
	}

	if(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == ITEMTYPE_RELIC)
		return;

	ZeroMemory(cCharName, sizeof(cCharName));

	if ( ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == ITEMTYPE_CONSUME) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == ITEMTYPE_ARROW) ) &&
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount > (DWORD)iAmount) ) {
			

			pItem = new class CItem;
			if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == FALSE) {
				
				delete pItem;
				return;
			}
			else {
				pItem->m_dwCount = iAmount;
			}

			
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;
			
			SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			
			if (wObjectID != NULL) {
				if (wObjectID < 10000) {
					
					if ((wObjectID > 0) && (wObjectID < MAXCLIENTS)) {
						if (m_pClientList[wObjectID] != NULL) {
							if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;
						}
					}
				}
				else {
					// NPC
					if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < MAXNPCS)) {
						if (m_pNpcList[wObjectID - 10000] != NULL) {
							if ((WORD)sOwnerH != (wObjectID - 10000)) sOwnerH = NULL;
						}
					}
				}
			}

			if (sOwnerH == NULL) {
				
				
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

				_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, pItem);
				
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
					pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
			}
			else {
				
				if (cOwnerType == OWNERTYPE_PLAYER) {
					
					memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);

					if (sOwnerH == iClientH) {
						
						delete pItem;
						return;
					}

					if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq) == TRUE) {
						
						_bItemLog(ITEMLOG_GIVE, iClientH, sOwnerH, pItem);
						SendItemNotifyMsg(sOwnerH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);

						if (iEraseReq == 1) delete pItem;
						
						SendNotifyMsg(NULL, iClientH, NOTIFY_GIVEITEMFIN_COUNTCHANGED, sItemIndex, iAmount, NULL, cCharName);
					}
					else {

						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							m_pClientList[iClientH]->m_sY, 
							pItem);

 
						_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, pItem);

						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
							pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);

						
						SendItemNotifyMsg(sOwnerH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);

						SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTGIVEITEM, sItemIndex, iAmount, NULL, cCharName);
					}

				}
				else {
					
					memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);

					if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
						
						if (bSetItemToBankItem(iClientH, pItem) == FALSE) {
							
							SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTITEMTOBANK, NULL, NULL, NULL, NULL);

							
							m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

							_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, pItem);

							SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
								m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
						}
					}
					else {
						
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

						_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, pItem);

						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
							pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
					}
				}
			}
	}
	else {
		

		
		ReleaseItemHandler(iClientH, sItemIndex, TRUE);

		
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == ITEMTYPE_ARROW) 
			m_pClientList[iClientH]->m_cArrowIndex = -1;

		
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY); 

		
		if (wObjectID != NULL) {
			if (wObjectID < 10000) {
				
				if ((wObjectID > 0) && (wObjectID < MAXCLIENTS)) {
					if (m_pClientList[wObjectID] != NULL) {
						if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;
					}
				}
			}
			else {
				// NPC
				if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < MAXNPCS)) {
					if (m_pNpcList[wObjectID - 10000] != NULL) {
						if ((WORD)sOwnerH != (wObjectID - 10000)) sOwnerH = NULL;
					}
				}
			}
		}

		if (sOwnerH == NULL) {
			
			
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
				m_pClientList[iClientH]->m_sY, 
				m_pClientList[iClientH]->m_pItemList[sItemIndex]);

			_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

			
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor);

			
			SendNotifyMsg(NULL, iClientH, NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, NULL);
		}
		else {
			if (cOwnerType == OWNERTYPE_PLAYER) {
				
				memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);
				pItem = m_pClientList[iClientH]->m_pItemList[sItemIndex];

				if (pItem->m_sIDnum == ITEM_GUILDADMISSIONTICKET) {
					if (m_pClientList[iClientH]->m_iGuildRank == -1 && 
						!m_pClientList[iClientH]->IsNeutral() &&
						m_pClientList[iClientH]->m_side == m_pClientList[sOwnerH]->m_side &&
						m_pClientList[sOwnerH]->m_iGuildRank == 0 ) 
					{		
							SendNotifyMsg(iClientH, sOwnerH, NOTIFY_QUERY_JOINGUILDREQPERMISSION, NULL, NULL, NULL, NULL);
							SendNotifyMsg(NULL, iClientH, NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, NULL, cCharName);

							_bItemLog(ITEMLOG_DEPLETE, iClientH,(int) -1, pItem);

							goto REMOVE_ITEM_PROCEDURE;
					}
				}

				if (!m_bIsCrusadeMode && 
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_GUILDSECESSIONTICKET) 
				{
					if ( (memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[sOwnerH]->m_cGuildName, 20) == 0) && 
						(m_pClientList[iClientH]->m_iGuildRank != -1) && 
						(m_pClientList[sOwnerH]->m_iGuildRank == 0) ) 
					{
							SendNotifyMsg(iClientH, sOwnerH, NOTIFY_QUERY_DISMISSGUILDREQPERMISSION, NULL, NULL, NULL, NULL);
							SendNotifyMsg(NULL, iClientH, NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, NULL, cCharName);

							_bItemLog(ITEMLOG_DEPLETE, iClientH,(int) -1, pItem);
							goto REMOVE_ITEM_PROCEDURE;
					}
				}

				if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq) == TRUE) {
					_bItemLog(ITEMLOG_GIVE, iClientH, sOwnerH, pItem);

					SendItemNotifyMsg(sOwnerH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);

					if (iEraseReq == 1) delete pItem;

				}
				else {
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
						m_pClientList[iClientH]->m_sY, 
						m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					
					_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
						m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor);

					SendItemNotifyMsg(sOwnerH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);

					ZeroMemory(cCharName, sizeof(cCharName));
				}
			}
			else {
				
				memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);

				if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
					
					if (bSetItemToBankItem(iClientH, sItemIndex) == FALSE) {
						
						SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTITEMTOBANK, NULL, NULL, NULL, NULL);

						
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							m_pClientList[iClientH]->m_sY, 
							m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						
						_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor);
					}
				}
				else if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Kennedy", 7) == 0) {
					

					
					if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 89)) {
						if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (m_pClientList[iClientH]->m_iGuildRank != -1)) {
							
							bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN, iClientH);
							SendGuildMsg(iClientH, NOTIFY_DISMISSGUILDSMAN, NULL, NULL, NULL);
							SendNotifyMsg(iClientH, iClientH, COMMONTYPE_DISMISSGUILDAPPROVE, NULL, NULL, NULL, NULL);

#ifdef TAIWANLOG
							_bItemLog(ITEMLOG_BANGUILD,iClientH,(char *)NULL,NULL) ;
#endif
							
							ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
							memcpy(m_pClientList[iClientH]->m_cGuildName, "NONE", 4);
							m_pClientList[iClientH]->m_iGuildRank = -1;
							m_pClientList[iClientH]->m_iGuildGUID = -1;

							
							SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTNULLACTION, NULL, NULL, NULL);

							
							m_pClientList[iClientH]->m_iExp -= 300;
							if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
							SendNotifyMsg(NULL, iClientH, NOTIFY_EXP, NULL, NULL, NULL, NULL);
						}

						
						delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
					} 
					else {
						
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							m_pClientList[iClientH]->m_sY, 
							m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						
						_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor);

						
						ZeroMemory(cCharName, sizeof(cCharName));

					}
				}
				else {
					

					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
						m_pClientList[iClientH]->m_sY, 
						m_pClientList[iClientH]->m_pItemList[sItemIndex]);

					
					_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

					
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
						m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor);

					
					ZeroMemory(cCharName, sizeof(cCharName));
				}
			}

			
			SendNotifyMsg(NULL, iClientH, NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, cCharName);
		}

REMOVE_ITEM_PROCEDURE:;

		
		if (m_pClientList[iClientH] == NULL) return;

		
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;

		
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}

	
	iCalcTotalWeight(iClientH);
}

void CGame::SendNotifyMsg(int iFromH, int iToH, WORD wMsgType, DWORD sV1, DWORD sV2, DWORD sV3, const char * pString, 
								  DWORD sV4, DWORD sV5, DWORD sV6, DWORD sV7, DWORD sV8, DWORD sV9, char * pString2) const
{
	char cData[1000];
	DWORD * dwp;
	WORD  * wp;
	char  * cp;
	short * sp;
	int   * ip, iRet, i;

	if (m_pClientList[iToH] == NULL) return;

	ZeroMemory(cData, sizeof(cData));

	dwp  = (DWORD *)(cData + INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (WORD *)(cData + INDEX2_MSGTYPE);			   
	*wp  = wMsgType;

	cp = (char *)(cData	+ INDEX2_MSGTYPE + 2);

	switch (wMsgType) {

	case NOTIFY_HELDENIANVICTORY: //0x0BEB
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case NOTIFY_HELDENIANTELEPORT:	
	case NOTIFY_HELDENIANSTART:
	case NOTIFY_HELDENIANEND:					
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	case NOTIFY_HELDENIANCOUNT:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV4;		
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV5;		
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV6;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV7;		
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV8;		
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
		break;

	case NOTIFY_APOCGATECLOSE:
	case NOTIFY_APOCGATEOPEN:
		ip  = (int *)cp;
		*ip = sV1;
		cp += 4;
		ip  = (int *)cp;
		*ip = sV2;
		cp += 4;
		memcpy(cp,pString,10);
		cp += 10;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
		break;

	case NOTIFY_ABADDONKILLED:
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;

	case NOTIFY_APOCGATESTARTMSG:
	case NOTIFY_APOCGATEENDMSG:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_LGNPTS:
		dwp = (DWORD*)cp;
		*dwp = sV1;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_RESPONSE_HUNTMODE:
		memcpy(cp, pString, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;

	case NOTIFY_REQGUILDNAMEANSWER:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case NOTIFY_TCLOC:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		wp  = (WORD *)cp;
		*wp = (WORD)sV4;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV5;
		cp += 2;

		memcpy(cp, pString2, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
		break;

	case NOTIFY_SLATE_STATUS:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_QUESTCOUNTER:
		ip  = (int *)cp;
		*ip = sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
		break;

	case NOTIFY_SLATE_EXP:
	case NOTIFY_SLATE_MANA:
	case NOTIFY_SLATE_INVINCIBLE:
	case NOTIFY_RESURRECTPLAYER:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_SLATE_CREATEFAIL:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_SLATE_CREATESUCCESS:
		dwp  = (DWORD *)cp;
		*dwp = sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_PARTY:
		switch (sV1) {
		case 4:
		case 6:
			wp  = (WORD *)cp;
			*wp = (WORD)sV1;
			cp += 2;
			wp  = (WORD *)cp;
			*wp = (WORD)sV2;
			cp += 2;
			wp  = (WORD *)cp;
			*wp = (WORD)sV3;
			cp += 2;
			memcpy(cp, pString, 10);
			cp += 10;
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12 + 10);
			break;

		case 5:
			wp  = (WORD *)cp;
			*wp = (WORD)sV1;
			cp += 2;
			wp  = (WORD *)cp;
			*wp = (WORD)sV2;
			cp += 2;
			wp  = (WORD *)cp;
			*wp = (WORD)sV3;
			cp += 2;
			memcpy(cp, pString, sV3*11);
			cp += sV3*11;
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12 + sV3*11);
			break;

		default:
			wp  = (WORD *)cp;
			*wp = (WORD)sV1;
			cp += 2;
			wp  = (WORD *)cp;
			*wp = (WORD)sV2;
			cp += 2;
			wp  = (WORD *)cp;
			*wp = (WORD)sV3;
			cp += 2;
			wp  = (WORD *)cp;
			*wp = (WORD)sV4;
			cp += 2;
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
			break;
		}
		break;

	case NOTIFY_PARTY_COORDS:
		memcpy(cp, pString, 10);
		cp+= 10;
		ip = (int *)cp;
		*ip = (int)sV1;
		cp += 4;
		ip = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;
		ip = (int *)cp;
		*ip = (int)sV5;
		cp += 4;
		ip = (int *)cp;
		*ip = (int)sV6;
		cp += 4;
		ip = (int *)cp;
		*ip = (int)sV7;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 40);
		break;

	case NOTIFY_GRANDMAGICRESULT:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		wp  = (WORD *)cp;
		*wp = (WORD)sV4;
		cp += 2;

		//		sp = (short *)cp;
		//		*sp = (short)sV9;
		//		cp += 2;

		if (sV9 > 0)  {
			memcpy(cp,pString2, (sV9+1)*2) ;
			cp += (sV9+1)*2;
		}
		else 
		{
			sp = (short *)cp;
			*sp = (short)0;
			cp += 2;
		}

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24 + (sV9+1)*2 );
		break;

	case NOTIFY_MAPSTATUSNEXT:
		memcpy(cp, pString, sV1);
		cp += sV1;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6+sV1);
		break;

	case NOTIFY_MAPSTATUSLAST:
		memcpy(cp, pString, sV1);
		cp += sV1;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6+sV1);
		break;

	case NOTIFY_LOCKEDMAP:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 18);
		break;

	case NOTIFY_BUILDITEMSUCCESS:
	case NOTIFY_BUILDITEMFAIL:
		if (sV1 >= 0) {
			sp = (short *)cp;
			*sp = (short)sV1;
			cp += 2;
		}
		else {
			sp = (short *)cp;
			*sp = (short)sV1 + 10000;
			cp += 2;
		}

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_HELP:
	case NOTIFY_QUESTREWARD:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV3;
		cp += 4;

		memcpy(cp, pString, 20);
		cp += 20;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;

	case NOTIFY_CANNOTCONSTRUCT:
	case NOTIFY_METEORSTRIKECOMING:
	case NOTIFY_METEORSTRIKEHIT:
	case NOTIFY_HELPFAILED:
	case NOTIFY_SPECIALABILITYENABLED:
	case NOTIFY_FORCEDISCONN:
	case NOTIFY_OBSERVERMODE:
	case NOTIFY_QUESTCOMPLETED:
	case NOTIFY_QUESTABORTED:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_QUESTCONTENTS:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV9;
		cp += 2;

		if (pString2 != NULL) memcpy(cp, pString2, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 44);
		break;

	case NOTIFY_GIZONITEMUPGRADELEFT:
	case NOTIFY_ITEMATTRIBUTECHANGE:

		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV2;
		cp += 4;

		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV3;
		cp += 4;

		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV4;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 20);
		break; 

	case NOTIFY_ITEMUPGRADEFAIL:

		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);

		break ;

	case NOTIFY_GIZONEITEMCHANGE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		*cp = (char)sV2;
		cp++;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;

		*cp = (char)sV6;
		cp++;

		*cp = (char)sV7;
		cp++;


		dwp  = (DWORD *)cp;
		*dwp = (DWORD)sV8;
		cp += 4;

		memcpy(cp, pString, 20);
		cp += 20;


		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 41);
		break;

	case NOTIFY_ENERGYSPHERECREATED:
	case NOTIFY_ITEMCOLORCHANGE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_NOMOREAGRICULTURE:	   
	case NOTIFY_AGRICULTURESKILLLIMIT: 
	case NOTIFY_AGRICULTURENOAREA:     
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_NOMORECRUSADESTRUCTURE:
	case NOTIFY_EXCHANGEITEMCOMPLETE:
	case NOTIFY_CANCELEXCHANGEITEM:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_SETEXCHANGEITEM:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		*cp = (char)sV5;
		cp++;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;


		dwp  = (DWORD *)cp;
		*dwp = (DWORD)sV9;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 57);
		break;

	case NOTIFY_OPENEXCHANGEWINDOW:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		*cp = (char)sV5;
		cp++;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;


		dwp  = (DWORD *)cp;
		*dwp = (DWORD)sV9;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 57);
		break;

	case NOTIFY_NOTFLAGSPOT:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_ITEMPOSLIST:
		for (i = 0; i < MAXITEMS; i++) {
			sp = (short *)cp;
			*sp = m_pClientList[iToH]->m_ItemPosList[i].x;
			cp += 2;
			sp = (short *)cp;
			*sp = m_pClientList[iToH]->m_ItemPosList[i].y;
			cp += 2;
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + MAXITEMS*4);
		break;

	case NOTIFY_ENEMYKILLS:
		ip  = (int *)cp;
		*ip = (int)sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_CRUSADE:
		ip = (int *)cp;
		*ip = (int)sV1;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV2;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV3;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
		break;

	case NOTIFY_CONSTRUCTIONPOINT:
	case NOTIFY_SPECIALABILITYSTATUS:
	case NOTIFY_DAMAGEMOVE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;

	case NOTIFY_DOWNSKILLINDEXSET:
	case NOTIFY_RESPONSE_CREATENEWPARTY:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_ADMINIFO:
		switch (sV1) {
		case 1:

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iHP;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iDefenseRatio;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_bIsSummoned;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_cActionLimit;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iHitDice;
			cp += 4;

			dwp  = (DWORD *)cp; 
			*dwp = m_pNpcList[sV2]->m_dwDeadTime;
			cp += 4;

			dwp  = (DWORD *)cp; 
			*dwp = m_pNpcList[sV2]->m_dwRegenTime;
			cp += 4;

			ip  = (int *)cp; 
			*ip	= (int)m_pNpcList[sV2]->m_bIsKilled;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 26 + 12);
			break;
		}
		break;

	case NOTIFY_NPCTALK:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV9;
		cp += 2;

		if (pString != NULL) memcpy(cp, pString, 20);
		cp += 20;

		if (pString2 != NULL) memcpy(cp, pString2, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 64);
		break;
	case NOTIFY_EVENTILLUSION:
	case NOTIFY_EVENTTP:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case NOTIFY_EVENTSPELL:
		*cp = sV1;
		cp++;
		*cp = sV2;
		cp++;
		*cp = m_pClientList[iToH]->IsGM();
		cp++;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 9);
		break;

	case NOTIFY_EVENTARMOR:
	case NOTIFY_EVENTSHIELD:
	case NOTIFY_EVENTCHAT:
	case NOTIFY_EVENTPARTY:
		*cp = sV1;
		cp++;
		*cp = m_pClientList[iToH]->IsGM();
		cp++;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_EVENTRESET:
	case NOTIFY_CRAFTING_SUCCESS:
	case NOTIFY_POTIONSUCCESS:
	case NOTIFY_LOWPOTIONSKILL:
	case NOTIFY_POTIONFAIL:
	case NOTIFY_NOMATCHINGPOTION:
	case NOTIFY_CRAFTING_FAIL:
	case NOTIFY_NOMATCHINGCRAFTING:
	case NOTIFY_NO_CRAFT_CONTRIB: 
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_SUPERATTACKLEFT:
		sp = (short *)cp;
		*sp = m_pClientList[iToH]->m_iSuperAttackLeft;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_SAFEATTACKMODE:
		*cp = m_pClientList[iToH]->m_bIsSafeAttackMode;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case NOTIFY_QUERY_JOINPARTY:
	case NOTIFY_IPACCOUNTINFO:
		strcpy(cp, pString);
		cp += strlen(pString);

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + strlen(pString) + 1);
		break;

	case NOTIFY_REWARDGOLD:
		dwp = (DWORD *)cp;
		*dwp = m_pClientList[iToH]->m_iRewardGold;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_SERVERSHUTDOWN:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case NOTIFY_GLOBALATTACKMODE:
	case NOTIFY_WHETHERCHANGE:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case NOTIFY_MONSTEREVENT_POSITION:
		*cp = (char)sV3;
		cp++;

		sp = (short*)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short*)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 11);
		break;


	case NOTIFY_FISHCANCELED:
	case NOTIFY_FISHSUCCESS:
	case NOTIFY_FISHFAIL:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_DEBUGMSG:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_FISHCHANCE:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_ENERGYSPHEREGOALIN:
	case NOTIFY_EVENTFISHMODE:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case NOTIFY_NOTICEMSG:
		memcpy(cp, pString, strlen(pString));
		cp += strlen(pString);

		*cp = NULL;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, strlen(pString) + 7);
		break;

	case NOTIFY_CANNOTRATING:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_RATINGPLAYER:
		*cp = (char)sV1;
		cp++;

		memcpy(cp, pString, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = m_pClientList[iToH]->m_reputation;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
		break;

	case NOTIFY_ADMINUSERLEVELLOW:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_PLAYERSHUTUP:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 19);
		break;

	case NOTIFY_TIMECHANGE:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case NOTIFY_TOBERECALLED:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_HUNGER:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case NOTIFY_PLAYERPROFILE:
		if (strlen(pString) > 100) {
			memcpy(cp, pString, 100);
			cp += 100;
		}
		else {
			memcpy(cp, pString, strlen(pString));
			cp += strlen(pString);
		}
		*cp = NULL;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7 + strlen(pString));
		break;

	case NOTIFY_PLAYERONGAME:
	case NOTIFY_FRIENDONGAME:
		memcpy(cp, pString, 10);
		cp += 10;
		if (pString != NULL) {
			memcpy(cp, pString2, 14);
			cp += 14;
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 31);
		break;

	case NOTIFY_WHISPERMODEON:
	case NOTIFY_WHISPERMODEOFF:
	case NOTIFY_PLAYERNOTONGAME:
		memcpy(cp, pString, 10);
		cp += 10;
		memcpy(cp, "             ", 10);
		cp += 10;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 27);
		break;

	case NOTIFY_ITEMSOLD:
	case NOTIFY_ITEMREPAIRED:
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV1;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV2;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;

	case NOTIFY_REPAIRITEMPRICE:
	case NOTIFY_SELLITEMPRICE:
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV1;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV2;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV3;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV4;
		cp += 4;

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 42);
		break;

	case NOTIFY_CANNOTREPAIRITEM:
	case NOTIFY_CANNOTSELLITEM:
		wp = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 30);

		break;

		//(word)sV1, sV2
	case NOTIFY_SHOWMAP:
		wp  = (WORD *)cp;  
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;  
		*wp = (WORD)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

		//(word)sV1
	case NOTIFY_SKILLUSINGEND:
		wp  = (WORD *)cp;  
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_TOTALUSERS:
		wp  = (WORD *)cp;    
		*wp = (WORD)(m_iTotalGameServerClients + m_onlineCntAdd) ; //_iGetTotalClients();
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

		// (char)sV1
	case NOTIFY_CTRWINNER:
	case NOTIFY_EVENTSTART:
	case NOTIFY_EVENTSTARTING:
	case NOTIFY_EVENTSTARTING2:
	case NOTIFY_EVENTSTARTING3:
	case NOTIFY_RELICINALTAR:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case NOTIFY_CASUALTIES:
		wp  = (WORD *)cp;  
		*wp = (WORD)sV1; // Aresden deaths
		cp += 2;

		wp  = (WORD *)cp;  
		*wp = (WORD)sV2; // Elvine
		cp += 2;

		wp  = (WORD *)cp;  
		*wp = (WORD)sV3; // Istria
		cp += 2;

		wp  = (WORD *)cp;  
		*wp = (WORD)sV4; // Aresden kills
		cp += 2;

		wp  = (WORD *)cp;  
		*wp = (WORD)sV5; // Elvine
		cp += 2;

		wp  = (WORD *)cp;  
		*wp = (WORD)sV6; // Istria
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 18);
		break;

	case NOTIFY_RELICPOSITION:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1; //Relic X
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2; //Relic Y
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_RELICGRABBED:
		memcpy(cp, pString, 10);
		cp += 10;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 17);
		break;

	case NOTIFY_MAGICEFFECTOFF:
	case NOTIFY_MAGICEFFECTON:
		wp  = (WORD *)cp;  
		*wp = (WORD)sV1;
		cp += 2;

		dwp  = (DWORD *)cp;  
		*dwp = (DWORD)sV2;
		cp += 4;

		dwp  = (DWORD *)cp;  
		*dwp = (DWORD)sV3;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;

	case NOTIFY_CANNOTITEMTOBANK:
	case NOTIFY_SETTING_FAILED:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_SERVERCHANGE:
		memcpy(cp, m_pClientList[iToH]->m_cMapName, 10);
		cp += 10;

		//if (m_iGameServerMode == 1) // LAN
		//	memcpy(cp, m_cLogServerAddrExternal, 15);
		//else // INTERNET
		memcpy(cp, m_cLogServerAddrExternal, 15);
		cp += 15;

		ip = (int *)cp;
		*ip = m_iLogServerPort;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16 +19);
		break;

	case NOTIFY_SKILL:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_SETITEMCOUNT:
		wp  = (WORD *)cp;  
		*wp = (WORD)sV1;
		cp += 2;

		dwp  = (DWORD *)cp;  
		*dwp = (DWORD)sV2;
		cp += 4;

		*cp = (char)sV3;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 13);
		break;

	case NOTIFY_ITEMDEPLETED_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_DROPITEMFIN_COUNTCHANGED:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;

	case NOTIFY_DROPITEMFIN_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;

	case NOTIFY_CANNOTGIVEITEM:
	case NOTIFY_GIVEITEMFIN_COUNTCHANGED:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case NOTIFY_GIVEITEMFIN_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case NOTIFY_ENEMYKILLREWARD:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iEnemyKillCount;
		cp += 4;
		memcpy(cp, m_pClientList[sV1]->m_cCharName, 10);
		cp += 10;
		memcpy(cp, m_pClientList[sV1]->m_cGuildName, 20);
		cp += 20;
		sp  = (short *)cp;
		*sp = (short)m_pClientList[sV1]->m_iGuildRank;
		cp += 2;
		sp  = (short *)cp;
		*sp = (short)m_pClientList[iToH]->m_iWarContribution;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 48);
		break;

	case NOTIFY_PKCAPTURED:

		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		memcpy(cp, pString, 10);
		cp += 10;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iRewardGold;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iToH]->m_iExp;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
		break;

	case NOTIFY_PKPENALTY:

		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->GetStr();
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iVit;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->GetDex();
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->GetInt();
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->GetMag();
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iRange;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iPKCount;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;

	case NOTIFY_TRAVELERLIMITEDLEVEL:
	case NOTIFY_LIMITEDLEVEL:

		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_ITEMRELEASED:
	case NOTIFY_ITEMLIFESPANEND:
		sp  = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_KILLED:

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 26);
		break;

	case NOTIFY_EXP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;

		ip = (int *)cp;
		*ip = m_pClientList[iToH]->m_reputation;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;

	case NOTIFY_HP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iHP;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMP; 
		cp += 4;
		if (m_pClientList[iToH]->m_iPartyID != NULL)
		{	
			m_pClientList[iToH]->m_partyHpCount++;
			if(m_pClientList[iToH]->m_partyHpCount >= 4)
			{
				m_pClientList[iToH]->m_partyHpCount = 0;
				for (int p = 0; p < MAXPARTYMEMBERS; p++)
				{	
					int partyMember = m_stPartyInfo[m_pClientList[iToH]->m_iPartyID].iIndex[p];
					if((partyMember != 0) && (m_pClientList[partyMember]->m_cMapIndex == m_pClientList[iToH]->m_cMapIndex))
					{
						SendNotifyMsg(NULL, partyMember, NOTIFY_PARTY_COORDS, m_pClientList[iToH]->m_sX, m_pClientList[iToH]->m_sY, NULL, m_pClientList[iToH]->m_cCharName, m_pClientList[iToH]->m_iHP, m_pClientList[iToH]->m_iMP, m_pClientList[partyMember]->GetMaxHP(), m_pClientList[iToH]->GetMaxMP());
					} 
				}
			}
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;

	case NOTIFY_MP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMP;
		cp += 4;
				if (m_pClientList[iToH]->m_iPartyID != NULL)
		{	
			m_pClientList[iToH]->m_partyMpCount++;
			if(m_pClientList[iToH]->m_partyMpCount >= 7)
			{
				m_pClientList[iToH]->m_partyMpCount = 0;
				for (int p = 0; p < MAXPARTYMEMBERS; p++)
				{	
					int partyMember = m_stPartyInfo[m_pClientList[iToH]->m_iPartyID].iIndex[p];
					if((partyMember != 0) && (m_pClientList[partyMember]->m_cMapIndex == m_pClientList[iToH]->m_cMapIndex))
					{
					SendNotifyMsg(NULL, partyMember, NOTIFY_PARTY_COORDS, m_pClientList[iToH]->m_sX, m_pClientList[iToH]->m_sY, NULL, m_pClientList[iToH]->m_cCharName, m_pClientList[iToH]->m_iHP, m_pClientList[iToH]->m_iMP, m_pClientList[partyMember]->GetMaxHP(), m_pClientList[iToH]->GetMaxMP());
					} 
				}
			}
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_SP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iSP;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_RANGE:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iRange;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_SETTING_SUCCESS:
	case NOTIFY_LEVELUP:
		ip  = (int *)cp;
		*ip = m_pClientList[iToH]->m_iLevel;
		cp += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->GetStr();
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iVit;
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->GetDex();
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->GetInt();
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->GetMag();
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iRange;
		cp  += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
		break;

	case NOTIFY_QUERY_DISMISSGUILDREQPERMISSION:
	case NOTIFY_QUERY_JOINGUILDREQPERMISSION:
	case NOTIFY_CANNOTJOINMOREGUILDSMAN:

		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;

	case COMMONTYPE_JOINGUILDAPPROVE:
		if (m_pClientList[iFromH] != NULL)
			memcpy(cp, m_pClientList[iFromH]->m_cGuildName, 20);
		else memcpy(cp, "?", 1);
		cp += 20;

		sp  = (short *)cp;
		*sp = GUILDSTARTRANK;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
		break;

	case COMMONTYPE_JOINGUILDREJECT:
	case COMMONTYPE_DISMISSGUILDAPPROVE:
	case COMMONTYPE_DISMISSGUILDREJECT:
		if (m_pClientList[iFromH] != NULL)
			memcpy(cp, m_pClientList[iFromH]->m_cGuildName, 20);
		else memcpy(cp, "?", 1);
		cp += 20;

		sp  = (short *)cp;
		*sp = GUILDSTARTRANK;
		cp += 2;

		memcpy(cp, m_pClientList[iToH]->m_cLocation, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;

	case NOTIFY_GUILDDISBANDED:

		memcpy(cp, pString, 20);
		cp += 20;

		memcpy(cp, m_pClientList[iToH]->m_cLocation, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 36);
		break;

	case NOTIFY_FIGHTZONERESERVE:
		ip = (int *)cp;
		*ip = (int )sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break; 

	case NOTIFY_NOGUILDMASTERLEVEL:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_CANNOTBANGUILDMAN:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_CANNOTRECALL:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_FORCERECALLTIME:
		sp = (short *)cp ;
		*sp = (short )sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_TELEPORT_REJECTED:
		sp  = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_SPELL_SKILL:
		for (i = 0; i < MAXMAGICTYPE; i++) {
			*cp = m_pClientList[iToH]->m_cMagicMastery[i];
			cp++;
		}

		for (i = 0; i < MAXSKILLTYPE; i++) {
			*cp = m_pClientList[iToH]->m_cSkillMastery[i];
			cp++;
		}

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + MAXMAGICTYPE + MAXSKILLTYPE);
		break;
	}

	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:

		//DeleteClient(iToH, TRUE, TRUE);
		return;
	}
}

void CGame::JoinGuildApproveHandler(int iClientH, char * pName)
{
	register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	for (i = 1; i < MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {

			if (m_pClientList[i]->m_side != m_pClientList[iClientH]->m_side ) return;

			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName);

			m_pClientList[i]->m_iGuildGUID = m_pClientList[iClientH]->m_iGuildGUID;

			ZeroMemory(m_pClientList[i]->m_cLocation, sizeof(m_pClientList[i]->m_cLocation));
			strcpy(m_pClientList[i]->m_cLocation, m_pClientList[iClientH]->m_cLocation);

			m_pClientList[i]->m_iGuildRank = GUILDSTARTRANK; 


			SendNotifyMsg(iClientH, i, COMMONTYPE_JOINGUILDAPPROVE, NULL, NULL, NULL, NULL);

#ifdef TAIWANLOG
			_bItemLog(ITEMLOG_JOINGUILD,i,(char *)NULL,NULL) ;
#endif

			SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTNULLACTION, NULL, NULL, NULL);
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_CLEARGUILDNAME, m_pClientList[i]->m_cMapIndex,m_pClientList[i]->m_sX, m_pClientList[i]->m_sY,0, 0, 0);

			SendGuildMsg(i, NOTIFY_NEWGUILDSMAN, NULL, NULL, NULL);

			bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN, i);
			return;
		}
}

void CGame::JoinGuildRejectHandler(int iClientH, char * pName)
{
	register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	for (i = 1; i < MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
			SendNotifyMsg(iClientH, i, COMMONTYPE_JOINGUILDREJECT, NULL, NULL, NULL, NULL);
			return;
		}
}

void CGame::DismissGuildApproveHandler(int iClientH, char * pName)
{
	register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	for (i = 1; i < MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {

			bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN, i);

#ifdef TAIWANLOG
			_bItemLog(ITEMLOG_BANGUILD,i,(char *)NULL,NULL) ;
#endif


			SendGuildMsg(i, NOTIFY_DISMISSGUILDSMAN, NULL, NULL, NULL);

			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, "NONE");
			m_pClientList[i]->m_iGuildRank = -1; 
			m_pClientList[i]->m_iGuildGUID = -1;

			SendNotifyMsg(iClientH, i, COMMONTYPE_DISMISSGUILDAPPROVE, NULL, NULL, NULL, NULL);

			SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTNULLACTION, NULL, NULL, NULL);
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_CLEARGUILDNAME, m_pClientList[i]->m_cMapIndex,m_pClientList[i]->m_sX, m_pClientList[i]->m_sY,0, 0, 0);
			return;
		}

}

void CGame::DismissGuildRejectHandler(int iClientH, char * pName)
{
	register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	for (i = 1; i < MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {


			SendNotifyMsg(iClientH, i, COMMONTYPE_DISMISSGUILDREJECT, NULL, NULL, NULL, NULL);
			return;
		}
}


DWORD CGame::dwGetItemCount(int iClientH, char * pName)
{
	register int i;
	char cTmpName[21];

	if (m_pClientList[iClientH] == NULL) return NULL;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pName);

	for (i = 0; i < MAXITEMS; i++)
		if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {
			return m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
		}

	return 0;
}

int CGame::SetItemCount(int iClientH, char * pItemName, DWORD dwCount)
{
	register int i;
	char cTmpName[21];
	WORD wWeight;

	if (m_pClientList[iClientH] == NULL) return -1;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	for (i = 0; i < MAXITEMS; i++)
		if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {

			wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], 1);// m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;

			if (dwCount == 0) {
				ItemDepleteHandler(iClientH, i, FALSE);
			}
			else {
				m_pClientList[iClientH]->m_pItemList[i]->m_dwCount = dwCount;
				SendNotifyMsg(NULL, iClientH, NOTIFY_SETITEMCOUNT, i, dwCount, (char)TRUE, NULL);
			}

			return wWeight;
		}

		return -1;
}


int CGame::SetItemCount(int iClientH, int iItemIndex, DWORD dwCount)
{
	WORD wWeight;

	if (m_pClientList[iClientH] == NULL) return -1;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return -1;

	wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[iItemIndex], 1);//m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wWeight;


	if (dwCount == 0) {
		ItemDepleteHandler(iClientH, iItemIndex, FALSE);
	}
	else {

		m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = dwCount;
		SendNotifyMsg(NULL, iClientH, NOTIFY_SETITEMCOUNT, iItemIndex, dwCount, (char)TRUE, NULL);
	}

	return wWeight;
}

void CGame::ReleaseItemHandler(int iClientH, short sItemIndex, bool bNotice)
{
	char cEquipPos;
	short sTemp;
	int   iTemp;

	if (m_pClientList[iClientH] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != ITEMTYPE_EQUIP) return;

	if (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == FALSE) return;

	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;

	switch (cEquipPos) {
	case EQUIPPOS_RHAND:
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;			
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0x0FFFFFFF; 		
		m_pClientList[iClientH]->m_iApprColor = iTemp;


		iTemp = m_pClientList[iClientH]->m_iStatus;
		iTemp = iTemp & 0xFFFFFFF0;
		m_pClientList[iClientH]->m_iStatus = iTemp;
		break;

	case EQUIPPOS_LHAND:
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xFFF0;			
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xF0FFFFFF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_TWOHAND:

		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;			
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0x0FFFFFFF; 		
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_BODY:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;
		m_pClientList[iClientH]->m_sAppr3 = sTemp;


		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xFF7F;
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFF0FFFFF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_BACK:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xF0FF;			
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFF0FFFF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_ARMS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFFF0;
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFFF0FFF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_PANTS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xF0FF;
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFFFF0FF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_LEGGINGS:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0x0FFF;
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFFFFF0F; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_HEAD:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFF0F;			
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFFFFFF0; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;
	case EQUIPPOS_FULLBODY: 
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;
		//		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFF0FFFF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;
	case EQUIPPOS_LFINGER:
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != NULL) {
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_ANGELICPENDANT_STR) {//AngelicPendant(STR)
				m_pClientList[iClientH]->SetAngelStr(0);
				SetAngel(iClientH, OWNERTYPE_PLAYER, 0);
				SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
			}
			else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_ANGELICPENDANT_DEX) {//AngelicPendant(DEX)
				m_pClientList[iClientH]->SetAngelDex(0);
				SetAngel(iClientH, OWNERTYPE_PLAYER, 0);
				SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
			}
			else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_ANGELICPENDANT_INT) {//AngelicPendant(INT)
				m_pClientList[iClientH]->SetAngelInt(0);
				SetAngel(iClientH, OWNERTYPE_PLAYER, 0);
				SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
			}
			else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_ANGELICPENDANT_MAG) {//AngelicPendant(MAG)
				m_pClientList[iClientH]->SetAngelMag(0);
				SetAngel(iClientH, OWNERTYPE_PLAYER, 0);
				SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
			}
		}
		break;
	}


	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == ITEMEFFECTTYPE_ATTACK_SPECABLTY) {
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;
	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == ITEMEFFECTTYPE_DEFENSE_SPECABLTY) {
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC;
	}

	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
	m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = -1;

	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_RESURWAND_MS10) || 
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_RESURWAND_MS20)) {
			m_pClientList[iClientH]->m_cMagicMastery[94] = FALSE; //Resurrection
			SendNotifyMsg(NULL, iClientH, NOTIFY_SPELL_SKILL, NULL, NULL, NULL, NULL);
	}

	if (bNotice == TRUE)
		SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTNULLACTION, NULL, NULL, NULL);

	CalcTotalItemEffect(iClientH, sItemIndex, TRUE);
}


bool CGame::_bDecodeNpcConfigFileContents(char * pData, DWORD dwMsgSize)
{
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iNpcConfigListIndex = 0;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
			case 1:
				// NPC Name
				if (strlen(token) > 20) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Too long Npc name.");
					delete[] pContents;
					return FALSE;
				}
				ZeroMemory(m_npcConfigList[iNpcConfigListIndex]->m_cNpcName, sizeof(m_npcConfigList[iNpcConfigListIndex]->m_cNpcName));
				memcpy(m_npcConfigList[iNpcConfigListIndex]->m_cNpcName, token, strlen(token));
				cReadModeB++;
				break;
			case 2:
				// NPC Type
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_sType = atoi(token);
				cReadModeB++;
				break;
			case 3:
				// Hit Dice (Health)
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_iHitDice = atoi(token);
				cReadModeB++;
				break;
			case 4:
				// Defense Ratio
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_iDefenseRatio = atoi(token);
				cReadModeB++;
				break;
			case 5:
				// Hit Ratio
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_iHitRatio = atoi(token);
				cReadModeB++;
				break;
			case 6:
				// NPC Bravery
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_iMinBravery = atoi(token);
				cReadModeB++;
				break;
			case 7:
				// Exp Dice
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_iExpDice = atoi(token) * 100000;
				cReadModeB++;
				break;

			case 8:
				// Attack Dice Throw
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_cAttackDiceThrow = atoi(token);
				cReadModeB++;
				break;

			case 9:
				// Attack Dice Range
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_cAttackDiceRange = atoi(token);
				cReadModeB++;
				break;

			case 10:
				// Size
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_cSize = atoi(token);
				cReadModeB++;
				break;

			case 11:
				// NPC Side
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_side = atoi(token);
				cReadModeB++;
				break;

			case 12:
				// Action Limit 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_cActionLimit = atoi(token);
				cReadModeB++;
				break;

			case 13:
				// Action Time
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_dwActionTime = atoi(token);
				cReadModeB++;
				break;

			case 14:
				// Resist Magic
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_cResistMagic = atoi(token);
				cReadModeB++;
				break;

			case 15:
				// Magic Level
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_cMagicLevel = atoi(token);
				cReadModeB++;
				break;

			case 16:
				// Generate Day/Week
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_cDayOfWeekLimit = atoi(token);
				cReadModeB++;
				break;

			case 17:
				// Chat Message Preference
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence = atoi(token);

				if (m_npcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence == 1) {


				}
				cReadModeB++;
				break;

			case 18:
				// Target Search Range
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_cTargetSearchRange = atoi(token);

				cReadModeB++;
				break;

			case 19:
				// Regeneration Time
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_dwRegenTime = atoi(token);

				cReadModeB++;
				break;

			case 20:
				// Attribute
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_cAttribute = atoi(token);

				cReadModeB++;
				break;

			case 21:
				// Absorb Magic Damage
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_iAbsDamage = atoi(token);

				cReadModeB++;
				break;

			case 22:
				// Maximum Mana Point
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_iMaxMana = atoi(token);

				cReadModeB++;
				break;

			case 23:
				// Magic Hit Ratio
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_iMagicHitRatio = atoi(token);

				cReadModeB++;
				break;

			case 24:
				// Attack Range
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_iAttackRange = atoi(token);

				cReadModeA = 0;
				cReadModeB = 0;
				iNpcConfigListIndex++;
				break;

			//case 25:
			//	// Gold drop value
			//	if (_bGetIsStringIsNumber(token) == FALSE) {
			//		PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
			//		delete[] pContents;
			//		return FALSE;
			//	}
			//	m_npcConfigList[iNpcConfigListIndex]->dwGoldDropValue = atoi(token) * GOLDDROPMULTIPLIER;

			//	cReadModeA = 0;
			//	cReadModeB = 0;
			//	iNpcConfigListIndex++;
			//	break;

				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "Npc", 3) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
				m_npcConfigList[iNpcConfigListIndex] = new class CNpc(" ", iNpcConfigListIndex);
			}
		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(ERROR) CRITICAL ERROR! NPC configuration file contents error!");
		return FALSE;
	}

	//wsprintf(cTxt, "(!) NPC(Total:%d) configuration - success!", iNpcConfigListIndex);
	//PutLogList(cTxt);

	return TRUE;
}

void CGame::OnStartGameSignal()
{
	int i;

	for (i = 0; i < MAXMAPS; i++)
		if (m_pMapList[i] != NULL) 
			_bReadMapInfoFiles(i);


	bReadCrusadeStructureConfigFile("..\\configs\\Crusade.cfg");

	_LinkStrikePointMapIndex();

	bReadCrusadeGUIDFile("GameData\\CrusadeGUID.txt");
	bReadHeldenianGUIDFile("GameData\\HeldenianGUID.txt");	
	
	bReadSchedulerConfigFile("..\\configs\\Schedule.cfg");

	PutLogList("");
	PutLogList("(!) Game Server Activated.");

	m_pGold = new class CItem;
	_bInitItemAttr(m_pGold, "Gold");

}

void CGame::CalculateGuildEffect(int iVictimH, char cVictimType, short sAttackerH)
{
	int ix, iy, iExp;
	short sOwnerH;
	char cOwnerType;

	return;

	if (m_pClientList[sAttackerH] == NULL) return;

	switch (cVictimType) {

	case OWNERTYPE_NPC:
		if (m_pNpcList[iVictimH] == NULL) return;

		for (ix = m_pNpcList[iVictimH]->m_sX-2; ix <= m_pNpcList[iVictimH]->m_sX+2; ix++)
			for (iy = m_pNpcList[iVictimH]->m_sY-2; iy <= m_pNpcList[iVictimH]->m_sY+2; iy++) {

				m_pMapList[m_pNpcList[iVictimH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);

				if ( (cOwnerType == OWNERTYPE_PLAYER) && (sOwnerH != NULL) && (sOwnerH != sAttackerH) &&
					(memcmp(m_pClientList[sAttackerH]->m_cGuildName, m_pClientList[sOwnerH]->m_cGuildName, 20) == 0) &&
					(m_pClientList[sAttackerH]->m_iLevel >= m_pClientList[sOwnerH]->m_iLevel) ) {

						if (dice(1,3) == 2) {
							iExp = (m_pNpcList[iVictimH]->m_iExp / 3);

							//				if (m_pClientList[sAttackerH]->m_iLevel >= ) iExp = 0;

							if (iExp > 0) {

								m_pClientList[sOwnerH]->m_iExp += iExp;
								if (bCheckLimitedUser(sOwnerH) == FALSE) {

									SendNotifyMsg(NULL, sOwnerH, NOTIFY_EXP, NULL, NULL, NULL, NULL);
								}
								bCheckLevelUp(sOwnerH);
							}
						}
				}
			}												     
			break;
	}
}

void CGame::TimeHitPointsUp(int iClientH)
{
	register int iMaxHP, iTemp, iTotal;
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return; 

	//iMaxHP = (3*m_pClientList[iClientH]->m_iVit) + (2*m_pClientList[iClientH]->m_iLevel) + (m_pClientList[iClientH]->GetStr()/2); 
	iMaxHP = m_pClientList[iClientH]->GetMaxHP();

	if (m_pClientList[iClientH]->m_iHP < iMaxHP) {


		iTemp = dice(3, (m_pClientList[iClientH]->m_iVit/3));
		if (iTemp < (m_pClientList[iClientH]->m_iVit/2)) iTemp = (m_pClientList[iClientH]->m_iVit/2);


		if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0)
			iTemp = iTemp - (iTemp/m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);

		iTotal = iTemp + m_pClientList[iClientH]->m_iHPstock;


		iTotal +=  m_pClientList[iClientH]->m_iHPStatic_stock;

		if (m_pClientList[iClientH]->m_iAddHP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddHP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}

		m_pClientList[iClientH]->AddHP(iTotal); 
	}

	m_pClientList[iClientH]->m_iHPstock = 0;
}

void CGame::TimeManaPointsUp(int iClientH)
{
	register int iMaxMP, iTotal;
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return;

	iMaxMP = m_pClientList[iClientH]->GetMaxMP();

	if (m_pClientList[iClientH]->m_iMP < iMaxMP) {

		iTotal = dice(3, (m_pClientList[iClientH]->GetMag()/3));
		if (m_pClientList[iClientH]->m_iAddMP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddMP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}

		m_pClientList[iClientH]->m_iMP += iTotal;

		if (m_pClientList[iClientH]->m_iMP > iMaxMP) 
			m_pClientList[iClientH]->m_iMP = iMaxMP;

		SendNotifyMsg(NULL, iClientH, NOTIFY_MP, NULL, NULL, NULL, NULL);
	}
}


void CGame::TimeStaminarPointsUp(int iClientH)
{
	register int iMaxSP, iTotal;
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return; 

	iMaxSP = m_pClientList[iClientH]->GetMaxSP();
	if (m_pClientList[iClientH]->m_iSP < iMaxSP) {

		iTotal = 10 + dice(4, (m_pClientList[iClientH]->m_iVit/17)); 
		if (m_pClientList[iClientH]->m_iAddSP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddSP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}


		if (m_pClientList[iClientH]->m_iLevel <= 20) {
			iTotal += 15;
		} else if ( m_pClientList[iClientH]->m_iLevel <= 40) {
			iTotal += 10;
		}  else if ( m_pClientList[iClientH]->m_iLevel <= 60) {
			iTotal += 5;
		}

		m_pClientList[iClientH]->m_iSP += iTotal;
		if (m_pClientList[iClientH]->m_iSP > iMaxSP) 
			m_pClientList[iClientH]->m_iSP = iMaxSP;

		SendNotifyMsg(NULL, iClientH, NOTIFY_SP, NULL, NULL, NULL, NULL);
	}
}

void CGame::SendGuildMsg(int iClientH, WORD wNotifyMsgType, short sV1, short sV2, char * pString)
{
	char cData[500];
	DWORD * dwp;
	WORD  * wp;
	char  * cp;
	register int i, iRet;


	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	for (i = 1; i < MAXCLIENTS; i++)
		if ( (m_pClientList[i] != NULL) && 
			(memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0) ) {


				ZeroMemory(cData, sizeof(cData));

				dwp  = (DWORD *)(cData + INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + INDEX2_MSGTYPE);
				*wp  = wNotifyMsgType;

				cp = (char *)(cData	+ INDEX2_MSGTYPE + 2);


				switch (wNotifyMsgType) {
				case NOTIFY_GUILDDISBANDED:
					if (i == iClientH) break; 
					memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
					cp += 20;

					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 26);
					ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
					strcpy(m_pClientList[i]->m_cGuildName, "NONE");
					m_pClientList[i]->m_iGuildRank = -1;
					m_pClientList[i]->m_iGuildGUID = -1;
					break;

				case NOTIFY_EVENTMSGSTRING:
					strcpy(cp, pString);
					cp += strlen(pString);

					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + strlen(pString) + 1);
					break;

				case NOTIFY_NEWGUILDSMAN:
					memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
					cp += 10;

					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + 10 + 1);
					break;

				case NOTIFY_DISMISSGUILDSMAN:
					memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
					cp += 10;

					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + 10 + 1);
					break;
				}

				switch (iRet) {
				case XSOCKEVENT_QUENEFULL:
				case XSOCKEVENT_SOCKETERROR:
				case XSOCKEVENT_CRITICALERROR:
				case XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(i, TRUE, TRUE);
					return;
				}
		}

}

void CGame::GuildNotifyHandler(char * pData, DWORD dwMsgSize)
{

	char * cp, cCharName[11], cGuildName[21];

	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cGuildName, sizeof(cGuildName));

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	memcpy(cGuildName, cp, 20);
	cp += 20;


}



void CGame::ToggleCombatModeHandler(int iClientH)
{
	short sAppr2;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return;

	sAppr2 = (short)((m_pClientList[iClientH]->m_sAppr2 & 0xF000) >> 12);

	m_pClientList[iClientH]->m_bIsAttackModeChange = TRUE; 

	if (sAppr2 == 0) {
		m_pClientList[iClientH]->m_sAppr2 = (0xF000 | m_pClientList[iClientH]->m_sAppr2);
	}
	else {
		m_pClientList[iClientH]->m_sAppr2 = (0x0FFF & m_pClientList[iClientH]->m_sAppr2);
	}

	SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTNULLACTION, NULL, NULL, NULL);
}

int CGame::iClientMotion_Magic_Handler(int iClientH, short sX, short sY, char cDir)
{
	char cData[100];
	DWORD * dwp;
	WORD  * wp;
	int     iRet;

	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->IncPlayerActivity(m_pClientList[iClientH]);
	}

	if(m_pClientList[iClientH]->m_bSkillUsingStatus[19]) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(/*0,*/ iClientH, OWNERTYPE_PLAYER, sX, sY);
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, OWNERTYPE_PLAYER, sX, sY);
	}

	ClearSkillUsingStatus(iClientH);

	m_pClientList[iClientH]->RemoveMagicEffect(MAGICTYPE_INVISIBILITY);

	m_pClientList[iClientH]->m_cDir = cDir;

	dwp  = (DWORD *)(cData + INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + INDEX2_MSGTYPE);
	*wp  = OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}


int  _tmp_iMCProb[]        = {0, 300, 250, 200, 150, 100, 80, 70, 60, 50, 40};
int  _tmp_iMLevelPenalty[] = {0,   5,   5,   8,   8,  10, 14, 28, 32, 36, 40};
void CGame::PlayerMagicHandler(int iClientH, int dX, int dY, short sType, bool bItemEffect, int iV1)
{
	short sX, sY, sOwnerH, sMagicCircle, rx, ry, sRemainItemSprite, sRemainItemSpriteFrame, sLevelMagic;
	char   cData[120], cDir, cOwnerType, cName[11], cNpcWaypoint[11], cName_Master[11], cNpcName[21], cRemainItemColor;
	double dV1, dV2, dV3, dV4;
	int    i, iErr, ix, iy, iResult, diceRes, iNamingValue, iFollowersNum, iEraseReq, iWhetherBonus, pNo;
	int    tX, tY, iManaCost, iMagicAttr, iItemID;
	const int crossPnts[5][2] = {{0,0},{-1,0},{1,0},{0,-1},{0,1}};
	class  CItem * pItem;
	DWORD  dwTime = timeGetTime();
	WORD  wWeaponType;
	CMagic * spell = NULL;
	Unit * target = NULL;
	CClient * caster = m_pClientList[iClientH];

#ifdef GUILDWARMODE 
	switch (sType) {
	case 31:
	case 40:
	case 41:
	case 46:
	case 54:
	case 55:
	case 73:
		return;
	}
#endif

	if (!caster || !caster->m_bIsInitComplete) return;

	// ### BUG POINT!!!  	caster->m_cMapIndex == -1 ???
	if (caster->m_cMapIndex < 0) return;
	if (m_pMapList[caster->m_cMapIndex] == NULL) return;

	if ((dX < 0) || (dX >= m_pMapList[caster->m_cMapIndex]->m_sSizeX) ||
		(dY < 0) || (dY >= m_pMapList[caster->m_cMapIndex]->m_sSizeY)) return;

	caster->m_hasPrecasted = false;

	if (abs(dX - caster->m_sX) > 11 || abs(dY - caster->m_sY) > 11) {
		wsprintf(cData, "Player (%s) casted further than maximum range (%d,%d)->(%d,%d)", 
			caster->m_cCharName, caster->m_sX, caster->m_sY, dX, dY);
		PutLogList(cData);
		PutLogFileList(cData, HACK_LOGFILE);
		return;
	}

	if ((sType < 0) || (sType >= 100))     return;
	if (m_pMagicConfigList[sType] == NULL) return;
	spell =	m_pMagicConfigList[sType];

	if ((bItemEffect == FALSE) && (caster->m_cMagicMastery[sType] != 1)) return;

	if (m_pMapList[ caster->m_cMapIndex ]->m_bIsAttackEnabled == FALSE 
		&& spell->m_sType != MAGICTYPE_CREATE
		&& spell->m_sType != MAGICTYPE_TELEPORT
		&& !caster->IsGM()) return;

	if (m_pMapList[ caster->m_cMapIndex ]->m_magicLimited[sType] == true && !caster->IsGM()) return;

	if (caster->m_cMagicEffectStatus[MAGICTYPE_INHIBITION] != 0) return;

	if (caster->m_sItemEquipmentStatus[ EQUIPPOS_RHAND ] != -1) {
		wWeaponType = ((caster->m_sAppr2 & 0x0FF0) >> 4);
		if(wWeaponType < 34 || wWeaponType > 39) return;
	}

	if ((caster->m_sItemEquipmentStatus[ EQUIPPOS_LHAND ]   != -1) ||
		(caster->m_sItemEquipmentStatus[ EQUIPPOS_TWOHAND ] != -1)) return;


	if ((dwTime - caster->m_dwRecentAttackTime) < 100) return; 
	caster->m_dwRecentAttackTime = dwTime;
	caster->m_dwLastActionTime = dwTime;

	sX = caster->m_sX;
	sY = caster->m_sY;

	//         1      2     3     4     5	 6     7	 8	  9    10
	sMagicCircle = (sType / 10) + 1;
//	if (caster->m_cSkillMastery[SKILL_MAGIC] == 0)
	//	dV1 = 1.0f;
	//else 
		//dV1 = (double)caster->m_cSkillMastery[SKILL_MAGIC];


	 dV1 = (double)100.0f;

	dV2 = (double)(dV1 / 100.0f);
	dV3 = (double)_tmp_iMCProb[sMagicCircle];

	dV1 = dV2 * dV3;
	iResult = (int)dV1;


	if (caster->GetInt() > 50)
		iResult += (caster->GetInt() - 50)/2;


	sLevelMagic = (caster->m_iLevel / 10);
	if (sMagicCircle != sLevelMagic) {
		if (sMagicCircle > sLevelMagic) {
			dV1 = (double)(caster->m_iLevel - sLevelMagic*10);
			dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double)abs(sMagicCircle - sLevelMagic)*10;
			dV4 = (dV1 / dV3)*dV2;

			iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
		}
		else {
			iResult += 5*abs(sMagicCircle - sLevelMagic); 
		}
	}

	switch (m_pMapList[caster->m_cMapIndex]->m_cWhetherStatus) 
	{
	case 0: break;
	case 1: iResult = iResult - (iResult / 24); break; 
	case 2:	iResult = iResult - (iResult / 12); break;
	case 3: iResult = iResult - (iResult / 5);  break;
	}

	if (caster->m_iSpecialWeaponEffectType == ITEMSTAT_CASTPROB) {
		dV1 = (double)iResult;
		dV2 = (double)(caster->m_iSpecialWeaponEffectValue * 3);
		dV3 = dV1 + dV2;
		iResult = (int)dV3;
	}

	if (iResult <= 0) iResult = 1;

	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[caster->m_cMapIndex]->m_cWhetherStatus);

	iManaCost = spell->m_manaCost;
	if ((caster->m_bIsSafeAttackMode == TRUE) && 
		(m_pMapList[caster->m_cMapIndex]->m_bIsFightZone == FALSE)) {

			iManaCost *= 1.1;
	}

	if (caster->m_iMPSaveRatio > 0) {
		dV1 = (double)caster->m_iMPSaveRatio;
		dV2 = (double)(dV1 / 100.0f);
		dV3 = (double)iManaCost;
		dV1 = dV2 * dV3; 		
		dV2 = dV3 - dV1; 
		iManaCost = (int)dV2;

		if (iManaCost <= 0) iManaCost = 1;
	}

	if (iResult < 100) {

		diceRes = dice(1,100);
		if (iResult < diceRes) {
			SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTDAMAGE, 0, -1, NULL);
			return;
		}
	}

	if (((caster->m_iHungerStatus <= 10) || (caster->m_iSP <= 0)) && (dice(1,1000) <= 100)) {
		SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTDAMAGE, 0, -1, NULL);
		return;
	}


	if (caster->m_iMP < iManaCost) {
		return;
	}

//	iResult = caster->m_cSkillMastery[SKILL_MAGIC];

	if (caster->GetMag() > 50) iResult += (caster->GetMag() - 50); 


	sLevelMagic = (caster->m_iLevel / 10);
	if (sMagicCircle != sLevelMagic) {
		if (sMagicCircle > sLevelMagic) {
			dV1 = (double)(caster->m_iLevel - sLevelMagic*10);
			dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double)abs(sMagicCircle - sLevelMagic)*10;
			dV4 = (dV1 / dV3)*dV2;

			iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
		}
		else {
			iResult += 5*abs(sMagicCircle - sLevelMagic);
		}
	}


	iResult += caster->m_iAddAR;

	if (iResult <= 0) iResult = 1;
	if (sType >= 80) iResult += 10000;


	if (spell->m_cCategory == 1) {
		if (m_pMapList[caster->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000005) != 0) return;
	}


	iMagicAttr = spell->m_iAttribute;


	caster->RemoveMagicEffect(MAGICTYPE_INVISIBILITY);

	target = m_pMapList[caster->m_cMapIndex]->GetOwner(dX, dY);

	if (spell->m_dwDelayTime == 0) {

		switch (spell->m_sType) 
		{
		case MAGICTYPE_RESURRECTION: 
			//if(!target) goto MAGIC_NOEFFECT;
			target = m_pMapList[caster->m_cMapIndex]->GetDeadOwner(dX, dY); 
			if(target && target->IsPlayer())
			{
				if (!target->IsDead()) goto MAGIC_NOEFFECT; 
				if (!caster->IsGM()){
					if (caster->m_side != target->m_side) goto MAGIC_NOEFFECT;
					if (caster->m_iSpecialAbilityTime != 0) goto MAGIC_NOEFFECT;
					caster->m_iSpecialAbilityTime = SPECABLTYTIMESEC;
					m_pClientList[iClientH]->m_cMagicMastery[94] = FALSE; //Resurrection
					SendNotifyMsg(NULL, iClientH, NOTIFY_SPELL_SKILL, NULL, NULL, NULL, NULL);
					SendNotifyMsg(NULL, iClientH, NOTIFY_SPECIALABILITYSTATUS, 1,  55, caster->m_iSpecialAbilityTime, NULL);
				}
				//target->m_bIsKilled = FALSE; 
				m_pClientList[target->m_handle]->m_bIsBeingResurrected = TRUE;
				SendNotifyMsg(NULL, target->m_handle, NOTIFY_RESURRECTPLAYER, NULL, NULL, NULL, NULL);
			} 
			break;

		case MAGICTYPE_SCAN:
			if(!target) break;
			if (CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE) {
				if(target->IsPlayer()){
					wsprintf(g_msg, " Player: %s HP:%d MP:%d.", m_pClientList[target->m_handle]->m_cCharName, target->m_iHP, target->m_iMP);
					ShowClientMsg(iClientH, g_msg);
				}else if(target->IsNPC()){
					wsprintf(g_msg, " NPC: %s HP:%d MP:%d", m_pNpcList[target->m_handle]->m_cNpcName, target->m_iHP, target->m_iMP);
					ShowClientMsg(iClientH, g_msg);
				}
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_MAGIC, caster->m_cMapIndex,
					caster->m_sX, caster->m_sY, dX, dY, 10, 10);
			}
			break;

		case MAGICTYPE_POLYMORPH:
			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (1) { // CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
				switch (cOwnerType) 
				{
				case OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_POLYMORPH ] != 0) goto MAGIC_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_POLYMORPH ] = (char)spell->m_sValue[MAGICV_TYPE];
					m_pClientList[sOwnerH]->m_sOriginalType = m_pClientList[sOwnerH]->m_sType;
					m_pClientList[sOwnerH]->m_sType = 18;
					SendEventToNearClient_TypeA(sOwnerH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTNULLACTION, NULL, NULL, NULL);
					break;

				case OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_POLYMORPH ] != 0) goto MAGIC_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_POLYMORPH ] = (char)spell->m_sValue[MAGICV_TYPE];
					m_pNpcList[sOwnerH]->m_sOriginalType = m_pNpcList[sOwnerH]->m_sType;
					m_pNpcList[sOwnerH]->m_sType = 18;
					SendEventToNearClient_TypeA(sOwnerH, OWNERTYPE_NPC, MSGID_EVENT_MOTION, OBJECTNULLACTION, NULL, NULL, NULL);
					break;
				}


				RegisterDelayEvent(DELAYEVENTTYPE_MAGICRELEASE, MAGICTYPE_POLYMORPH, dwTime + (spell->m_dwLastTime*1000), 
					sOwnerH, cOwnerType, NULL, NULL, NULL, spell->m_sValue[MAGICV_TYPE], NULL, NULL);

				if (cOwnerType == OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTON, MAGICTYPE_POLYMORPH, spell->m_sValue[MAGICV_TYPE], NULL, NULL);
			}
			break;



		case MAGICTYPE_DAMAGE_SPOT:
			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr);

			m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
				(m_pClientList[sOwnerH]->m_iHP > 0) ) {

					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr);
			}
			break;

		case MAGICTYPE_DAMAGE_SPOT_SPDOWN:
			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
				Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr);
				Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
			}

			m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
				(m_pClientList[sOwnerH]->m_iHP > 0) ) {

					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
					}
			}
			break;

		case MAGICTYPE_DAMAGE_LINEAR_SPDOWN:
			sX = caster->m_sX;
			sY = caster->m_sY;

			for (i = 2; i < 10; i++) {
				iErr = 0;
				m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
				for(pNo = 0; pNo < 5; pNo++){
					target = g_mapList[caster->m_cMapIndex]->GetOwner(tX+crossPnts[pNo][0], tY+crossPnts[pNo][1]);
					if (target && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE) {
						
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, sX, sY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, FALSE, iMagicAttr);
						if (target && !target->IsDead() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE) {
							Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr);
							Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
						}
					}
				
					target = g_mapList[caster->m_cMapIndex]->GetDeadOwner(tX+crossPnts[pNo][0], tY+crossPnts[pNo][1]);
					if (target && !target->IsDead() && target->IsPlayer() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE){

						Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, FALSE, iMagicAttr);
						if (target && !target->IsDead() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE) {
							Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr);
							Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
						}
					}
				}
				if ((abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}


			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
					target = g_mapList[caster->m_cMapIndex]->GetOwner(ix, iy);
					if (target && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE) {
						
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, FALSE, iMagicAttr);
						if (target && !target->IsDead() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE) {
							Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr);
							Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
						}
					}

					target = g_mapList[caster->m_cMapIndex]->GetDeadOwner(ix, iy);
					if (target && !target->IsDead() && target->IsPlayer() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE){
						
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, FALSE, iMagicAttr);
						if (target && !target->IsDead() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE) {
							Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER,  target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr);
							Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER,  target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
						}
					}
				}

			target = g_mapList[caster->m_cMapIndex]->GetOwner(dX, dY);
			if (target && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE) {
				Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
		
				if (target && !target->IsDead() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE) {
					Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr);
					Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER,  target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
				}
			}

			target = g_mapList[caster->m_cMapIndex]->GetDeadOwner(dX, dY);
			if (target && !target->IsDead() && target->IsPlayer() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE){

				Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, FALSE, iMagicAttr);
				if (target && !target->IsDead() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE) {
					Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr);
					Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
				}
			}

			break;

		case MAGICTYPE_CANCELLATION:
			if(target){
				target->RemoveMagicEffect(MAGICTYPE_INVISIBILITY);
				target->RemoveMagicEffect(MAGICTYPE_PROTECT);
				target->RemoveMagicEffect(MAGICTYPE_HOLDOBJECT);
				target->RemoveMagicEffect(MAGICTYPE_CONFUSE);
				target->RemoveMagicEffect(MAGICTYPE_BERSERK);
				target->RemoveMagicEffect(MAGICTYPE_ICE);
				target->RemoveMagicEffect(MAGICTYPE_POLYMORPH);
				target->RemoveMagicEffect(MAGICTYPE_INHIBITION);
			}
			break;

		case MAGICTYPE_INHIBITION:
			if(target && target->IsPlayer() && !m_pClientList[target->m_handle]->IsInvincible()){
				target->AddMagicEffect(spell->m_sType, spell->m_dwLastTime);
			}
			break;

		case MAGICTYPE_DAMAGE_LINEAR:
			sX = caster->m_sX;
			sY = caster->m_sY;

			for (i = 2; i < 10; i++) {
				iErr = 0;
				m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

				for(int pNo=0; pNo < 5; pNo++){
					m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+crossPnts[pNo][0], tY+crossPnts[pNo][1]);
					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, FALSE, iMagicAttr);

					m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+crossPnts[pNo][0], tY+crossPnts[pNo][1]);
					if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {

							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, FALSE, iMagicAttr);
					}
				}

				if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}


			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
					m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, FALSE, iMagicAttr);

					m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {

							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, FALSE, iMagicAttr);
					}
				}

				// dX, dY
				m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr); 

				m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
					(m_pClientList[sOwnerH]->m_iHP > 0) ) {

						if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr); 
				}
				break;


		case MAGICTYPE_ICE_LINEAR:
			sX = caster->m_sX;
			sY = caster->m_sY;

			for (i = 2; i < 10; i++) {
				iErr = 0;
				m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

				for(pNo = 0; pNo < 5; pNo++) {
					target = m_pMapList[caster->m_cMapIndex]->GetOwner(tX+crossPnts[pNo][0], tY+crossPnts[pNo][1]);
					if (target && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE) {
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, sX, sY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, FALSE, iMagicAttr);

						if (target && !target->IsDead() && checkResistingIceSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE) 
							target->AddMagicEffect(spell->m_sType, spell->m_sValue[MAGICV_ICEDURATION]);
					}

					target = g_mapList[caster->m_cMapIndex]->GetDeadOwner(tX+crossPnts[pNo][0], tY+crossPnts[pNo][1]);
					if (target && !target->IsDead() && target->IsPlayer() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE){
						Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, FALSE, iMagicAttr);

						if (target && !target->IsDead() && checkResistingIceSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE) 
							target->AddMagicEffect(spell->m_sType, spell->m_sValue[MAGICV_ICEDURATION]);
					}
				}
				if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}


			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
					target = m_pMapList[caster->m_cMapIndex]->GetOwner(ix, iy);
					if (target && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE) {
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, FALSE, iMagicAttr);

						if (target && !target->IsDead() && checkResistingIceSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE) 
							target->AddMagicEffect(spell->m_sType, spell->m_sValue[MAGICV_ICEDURATION]);
					}

					target = m_pMapList[caster->m_cMapIndex]->GetDeadOwner(ix, iy);
					if (target && !target->IsDead() && target->IsPlayer() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE){
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, FALSE, iMagicAttr);
						
						if (target && !target->IsDead() && checkResistingIceSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE) 
							target->AddMagicEffect(spell->m_sType, spell->m_sValue[MAGICV_ICEDURATION]);
					}
				}


			target = m_pMapList[caster->m_cMapIndex]->GetOwner(dX, dY);
			if (target && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE) {
				Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr); 

				if (target && !target->IsDead() && checkResistingIceSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE) 
					target->AddMagicEffect(spell->m_sType, spell->m_sValue[MAGICV_ICEDURATION]);
			}

			target = m_pMapList[caster->m_cMapIndex]->GetDeadOwner(dX, dY);
			if (target && !target->IsDead() && target->IsPlayer() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE){
				Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr); 

				if (target && !target->IsDead() && checkResistingIceSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == FALSE) 
					target->AddMagicEffect(spell->m_sType, spell->m_sValue[MAGICV_ICEDURATION]);
			}
			break;

		case MAGICTYPE_HPUP_SPOT:
			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			Effect_HpUp_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS]);
			break;

		case MAGICTYPE_TREMOR: 
			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr);

			m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
				(m_pClientList[sOwnerH]->m_iHP > 0) ) {

					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr);
			}


			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
					m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, FALSE, iMagicAttr);

					m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {

							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, FALSE, iMagicAttr);
					}
				}
				break;

		case MAGICTYPE_DAMAGE_AREA:
			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr);

			m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
				(m_pClientList[sOwnerH]->m_iHP > 0) ) {

					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr);
			}


			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
					m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, FALSE, iMagicAttr);

					m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {

							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, FALSE, iMagicAttr);
					}
				}
				break;

		case MAGICTYPE_DAMAGE_AREA_NOSPOT:
			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
					m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, FALSE, iMagicAttr);

					m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {

							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, FALSE, iMagicAttr);
					}
				}
				break;
		case MAGICTYPE_DAMAGE_AREA_MOVE:
			if ((dX >= sX) && (dY >= sY))
				{	for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) 
					for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
					{	m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, TRUE, iMagicAttr);
					}					
				}else if ((dX >= sX) && (dY < sY)) 
				{	for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) 
					for (iy = dY + spell->m_vRange; iy >= dY - spell->m_vRange; iy--)
					{	m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, TRUE, iMagicAttr);
					}	
				}else if((dX < sX) && (dY >= sY))  
				{	for (ix = dX + spell->m_hRange; ix >= dX - spell->m_hRange; ix--) 
					for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
					{	m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, TRUE, iMagicAttr);
					}	
				}else //if((dX < sX) && (dY < sY)) 
				{	for (ix = dX + spell->m_hRange; ix >= dX - spell->m_hRange; ix--) 
					for (iy = dY + spell->m_vRange; iy >= dY - spell->m_vRange; iy--)
					{	m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, TRUE, iMagicAttr);
					}
				}
				for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) 
				{	m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (   (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
						&& (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, TRUE, iMagicAttr);
					}
				}
			break;	

		case MAGICTYPE_DAMAGE_AREA_NOSPOT_SPDOWN:
			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
					m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, FALSE, iMagicAttr);
						Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
					}

					m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {

							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, FALSE, iMagicAttr);
								Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
							}
					}
				}
				break;

		case MAGICTYPE_SPDOWN_AREA:

			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS]);

			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
					m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
				}
				break;

		case MAGICTYPE_SPUP_AREA:
			spell->Effect_RecSP(caster, target, spell->m_sValue[MAGICV_THROW], 
				spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS]);

			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
			{
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
					target = g_mapList[caster->m_cMapIndex]->GetOwner(ix, iy);
					spell->Effect_RecSP(caster, target, spell->m_sValue[MAGICV_LINEARTHROW], 
						spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
				}
			}
			break;

		case MAGICTYPE_TELEPORT:
			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

			switch (spell->m_sValue[MAGICV_TYPE]) {
			case 1:
				if ( (cOwnerType == OWNERTYPE_PLAYER) && (sOwnerH == iClientH) )
					if((dwTime - caster->m_lastDamageTime) > 10000 || caster->IsGM()){
						if (caster->m_nextRecallPoint != 0 && strcmp(caster->m_cMapName, sideMap[ caster->m_side ]) == 0){
							RequestTeleportHandler(iClientH, 3, caster->m_cMapName,
								m_pMapList[caster->m_cMapIndex]->m_pInitialPoint[caster->m_nextRecallPoint].x,
								m_pMapList[caster->m_cMapIndex]->m_pInitialPoint[caster->m_nextRecallPoint].y);
						}
						else {
						RequestTeleportHandler(iClientH, 1);
					} 
						
					} 
					else {
						SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTRECALL, NULL, NULL, NULL, NULL);
						goto MAGIC_NOEFFECT;
					}
				break;
			}
			break; 

		case MAGICTYPE_SUMMON:
			if (m_pMapList[caster->m_cMapIndex]->m_bIsFightZone == TRUE) return;
if ((m_bHeldenianMode) && (m_pMapList[caster->m_cMapIndex]->m_bIsHeldenianMap == TRUE)) return;

			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

			if ((sOwnerH != NULL) && (cOwnerType == OWNERTYPE_PLAYER) && (
				caster->m_side == m_pClientList[sOwnerH]->m_side)) 
			{
				iFollowersNum = iGetFollowerNumber(sOwnerH, cOwnerType);

//				if (iFollowersNum >= (caster->m_cSkillMastery[SKILL_MAGIC]/20) && !caster->IsGM()) break;

				iNamingValue = m_pMapList[caster->m_cMapIndex]->iGetEmptyNamingValue();
				if (iNamingValue == -1) {

				}
				else {
					ZeroMemory(cName, sizeof(cName));
					wsprintf(cName, "XX%d", iNamingValue);
					cName[0] = '_';
					cName[1] = caster->m_cMapIndex+65;

					ZeroMemory(cNpcName, sizeof(cNpcName));

					switch (iV1) {
					case NULL: 						
						///*iResult = dice(1, caster->m_cSkillMastery[SKILL_MAGIC] / 10);

						//if (iResult < caster->m_cSkillMastery[SKILL_MAGIC] / 20) 
						//	iResult = caster->m_cSkillMastery[SKILL_MAGIC] / 20;

						//switch (iResult) {
						//case 1: strcpy(cNpcName, "Slime"); break;
						//case 2: strcpy(cNpcName, "Giant-Ant"); break;
						//case 3: strcpy(cNpcName, "Amphis"); break;
						//case 4: strcpy(cNpcName, "Orc"); break;
						//case 5: strcpy(cNpcName, "Skeleton"); break;
						//case 6: strcpy(cNpcName, "Clay-Golem"); break;
						//case 7: strcpy(cNpcName, "Stone-Golem"); break;
						//case 8: strcpy(cNpcName, "Orc-Mage"); break;
						//case 9: strcpy(cNpcName, "Hellbound"); break;
						//case 10:strcpy(cNpcName, "Cyclops"); break;
						//}
						//break;*/

					case 1: strcpy(cNpcName, "Orc"); break;
					case 2: strcpy(cNpcName, "Skeleton"); break;
					case 3: strcpy(cNpcName, "Clay-Golem"); break;
					case 4: strcpy(cNpcName, "Stone-Golem"); break;
					case 5: strcpy(cNpcName, "Hellbound"); break;
					case 6: strcpy(cNpcName, "Cyclops"); break;
					case 7: strcpy(cNpcName, "Troll"); break;
					case 8: strcpy(cNpcName, "Orge"); break;
					}

					if (!bCreateNewNpc(cNpcName, cName, m_pMapList[caster->m_cMapIndex]->m_cName, 0, 
						MOVETYPE_RANDOM, &dX, &dY, cNpcWaypoint, NULL, NULL, caster->m_side, FALSE, TRUE)) 
					{
						m_pMapList[caster->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
					}
					else {

						ZeroMemory(cName_Master, sizeof(cName_Master));
						switch (cOwnerType) {
						case OWNERTYPE_PLAYER:
							memcpy(cName_Master, m_pClientList[sOwnerH]->m_cCharName, 10);
							break;
						case OWNERTYPE_NPC:
							memcpy(cName_Master, m_pNpcList[sOwnerH]->m_cName, 5);
							break;
						}
						bSetNpcFollowMode(cName, cName_Master, cOwnerType);
#ifdef TAIWANLOG
						_bItemLog(ITEMLOG_SUMMONMONSTER,iClientH,cNpcName,NULL) ;
#endif
					}
				}
			}
			break;

		case MAGICTYPE_CREATE:
			if ( m_pMapList[caster->m_cMapIndex]->bGetIsMoveAllowedTile(dX, dY) == FALSE )
				goto MAGIC_NOEFFECT;

			pItem = new class CItem;

			switch (spell->m_sValue[MAGICV_TYPE]) {
			case 1:
				if (dice(1,2) == 1)
					iItemID = ITEM_MEAT ;
				else iItemID = ITEM_BAGUETTE ;
				break;
			}

			_bInitItemAttr(pItem, iItemID);


			pItem->m_sTouchEffectType   = ITET_ID;
			pItem->m_sTouchEffectValue1 = dice(1,100000);
			pItem->m_sTouchEffectValue2 = dice(1,100000);
			pItem->m_sTouchEffectValue3 = timeGetTime();


			if(m_pMapList[caster->m_cMapIndex]->bSetItem(dX, dY, pItem))
			{
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, caster->m_cMapIndex,
					dX, dY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 
				_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, pItem);
			}
			break;

		case MAGICTYPE_PROTECT:
			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

			switch (cOwnerType) 
			{
			case OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
				if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[MAGICTYPE_PROTECT]) goto MAGIC_NOEFFECT;

				//	if (caster->IsNeutral()) goto MAGIC_NOEFFECT;

				m_pClientList[sOwnerH]->m_cMagicEffectStatus[MAGICTYPE_PROTECT] = (char)spell->m_sValue[MAGICV_TYPE];
				switch (spell->m_sValue[MAGICV_TYPE]){
				case MAGICPROTECT_PFA:
					m_pClientList[sOwnerH]->SetStatusFlag(STATUS_PFA, TRUE);
					break;
				case MAGICPROTECT_PFM:
				case MAGICPROTECT_AMP:
					m_pClientList[sOwnerH]->SetStatusFlag(STATUS_PFM,  TRUE);
					break;
				case MAGICPROTECT_DS:
				case MAGICPROTECT_GDS:
					m_pClientList[sOwnerH]->SetStatusFlag(STATUS_DEFENSESHIELD, TRUE);
					break;
				}
				break;

			case OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
				if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[MAGICTYPE_PROTECT]) goto MAGIC_NOEFFECT;

				if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
				m_pNpcList[sOwnerH]->m_cMagicEffectStatus[MAGICTYPE_PROTECT] = (char)spell->m_sValue[MAGICV_TYPE];
				switch (spell->m_sValue[MAGICV_TYPE]){
				case MAGICPROTECT_PFA:
					m_pNpcList[sOwnerH]->SetStatusFlag(STATUS_PFA, TRUE);
					break;
				case MAGICPROTECT_PFM:
				case MAGICPROTECT_AMP:
					m_pNpcList[sOwnerH]->SetStatusFlag(STATUS_PFM, TRUE);
					break;
				case MAGICPROTECT_DS:
				case MAGICPROTECT_GDS:
					m_pNpcList[sOwnerH]->SetStatusFlag(STATUS_DEFENSESHIELD, TRUE);
					break;
				}
				break;
			}


			RegisterDelayEvent(DELAYEVENTTYPE_MAGICRELEASE, MAGICTYPE_PROTECT, dwTime + (spell->m_dwLastTime*1000), 
				sOwnerH, cOwnerType, NULL, NULL, NULL, spell->m_sValue[MAGICV_TYPE], NULL, NULL);

			if (cOwnerType == OWNERTYPE_PLAYER)
				SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTON, MAGICTYPE_PROTECT, spell->m_sValue[MAGICV_TYPE], NULL, NULL);
			break;

		case MAGICTYPE_HOLDOBJECT:
			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {

				switch (cOwnerType) 
				{
				case OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;

					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) goto MAGIC_NOEFFECT;

					if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
					if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
					
					if (caster->m_iPartyID != 0 && m_pClientList[sOwnerH]->m_iPartyID == caster->m_iPartyID) goto MAGIC_NOEFFECT;

					if (m_pClientList[sOwnerH]->m_iAddPR >= 500) goto MAGIC_NOEFFECT;

					if( caster->m_side == m_pClientList[sOwnerH]->m_side && 
						m_bIsCrusadeMode == FALSE && caster->m_iAdminUserLevel == 0 &&
						(
						strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMap[ARESDEN]) == 0 ||
						strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMap[ELVINE]) == 0 ||
						strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMap[ISTRIA]) == 0 ||
						strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMap[NEUTRAL]) == 0 ||
						strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMapFarm[ARESDEN]) == 0 ||
						strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMapFarm[ELVINE]) == 0 ||
						strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMapFarm[ISTRIA]) == 0
						))
					{
						goto MAGIC_NOEFFECT; 
					}

					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = (char)spell->m_sValue[MAGICV_TYPE];
					break;

				case OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6) goto MAGIC_NOEFFECT; 
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) goto MAGIC_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = (char)spell->m_sValue[MAGICV_TYPE];
					break;
				}

				RegisterDelayEvent(DELAYEVENTTYPE_MAGICRELEASE, MAGICTYPE_HOLDOBJECT, dwTime + (spell->m_dwLastTime*1000), 
					sOwnerH, cOwnerType, NULL, NULL, NULL, spell->m_sValue[MAGICV_TYPE], NULL, NULL);

				if (cOwnerType == OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTON, MAGICTYPE_HOLDOBJECT, spell->m_sValue[MAGICV_TYPE], NULL, NULL);
			}
			break;

		case MAGICTYPE_INVISIBILITY:
			switch (spell->m_sValue[MAGICV_TYPE]) 
			{
			case 1:

				m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				switch (cOwnerType) {
				case OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->IsInvisible()) goto MAGIC_NOEFFECT;
					if (m_astoria.get() && m_astoria->GetRelicHolder() == m_pClientList[sOwnerH]) goto MAGIC_NOEFFECT;

					//	if (caster->IsNeutral()) goto MAGIC_NOEFFECT;

					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_INVISIBILITY ] = (char)spell->m_sValue[MAGICV_TYPE];
					m_pClientList[sOwnerH]->SetStatusFlag(STATUS_INVISIBILITY, TRUE);
					RemoveFromTarget(sOwnerH, OWNERTYPE_PLAYER, MAGICTYPE_INVISIBILITY);
					break;

				case OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->IsInvisible()) goto MAGIC_NOEFFECT;

					if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) {
						m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_INVISIBILITY ] = (char)spell->m_sValue[MAGICV_TYPE];
						m_pNpcList[sOwnerH]->SetStatusFlag(STATUS_INVISIBILITY, TRUE);
						RemoveFromTarget(sOwnerH, OWNERTYPE_NPC, MAGICTYPE_INVISIBILITY);
					}
					break;
				}

				RegisterDelayEvent(DELAYEVENTTYPE_MAGICRELEASE, MAGICTYPE_INVISIBILITY, dwTime + (spell->m_dwLastTime*1000), 
					sOwnerH, cOwnerType, NULL, NULL, NULL, spell->m_sValue[MAGICV_TYPE], NULL, NULL);

				if (cOwnerType == OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTON, MAGICTYPE_INVISIBILITY, spell->m_sValue[MAGICV_TYPE], NULL, NULL);
				break;

			case 2:

				//	if (caster->IsNeutral()) goto MAGIC_NOEFFECT;

				for (ix = dX - 8; ix <= dX + 8; ix++)
					for (iy = dY - 8; iy <= dY + 8; iy++) {
						m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (sOwnerH != NULL) {
							switch (cOwnerType) 
							{
							case OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;

								if (m_pClientList[sOwnerH]->IsInvisible()) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_INVISIBILITY ] = NULL;
									m_pClientList[sOwnerH]->SetStatusFlag(STATUS_INVISIBILITY, FALSE);
									RemoveFromDelayEventList(sOwnerH, cOwnerType, MAGICTYPE_INVISIBILITY);
								}
								break;

							case OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pNpcList[sOwnerH]->IsInvisible()) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_INVISIBILITY ] = NULL;
									m_pNpcList[sOwnerH]->SetStatusFlag(STATUS_INVISIBILITY, FALSE);
									RemoveFromDelayEventList(sOwnerH, cOwnerType, MAGICTYPE_INVISIBILITY);
								}
								break;
							}
						}
					}
					break;
			}
			break;

		case MAGICTYPE_CREATE_DYNAMIC:
			if (!m_bIsCrusadeMode) {
				if (strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMap[ARESDEN]) == 0) return;
				if (strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMap[ELVINE]) == 0) return;
				if (strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMap[ISTRIA]) == 0) return;
				if (strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMapFarm[ARESDEN]) == 0) return;
				if (strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMapFarm[ELVINE]) == 0) return;
				if (strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMapFarm[ISTRIA]) == 0) return;
			}

			switch (spell->m_sValue[MAGICV_DYNAMICOBJ])
			{
			case DYNAMICOBJECT_PCLOUD_BEGIN: 
			case DYNAMICOBJECT_FIRE:   
			case DYNAMICOBJECT_SPIKE:  
				switch (spell->m_sValue[MAGICV_DYNAMICTYPE]) 
				{
				case 1: 
					// wall - type
					cDir = m_Misc.cGetNextMoveDir(caster->m_sX, caster->m_sY, dX, dY);
					switch (cDir) 
					{
					case 1:	rx = 1; ry = 0;   break;
					case 2: rx = 1; ry = 1;   break;
					case 3: rx = 0; ry = 1;   break;
					case 4: rx = -1; ry = 1;  break;
					case 5: rx = 1; ry = 0;   break;
					case 6: rx = -1; ry = -1; break;
					case 7: rx = 0; ry = -1;  break;
					case 8: rx = 1; ry = -1;  break;
					}

					iAddDynamicObjectList(iClientH, OWNERTYPE_PLAYER_INDIRECT, spell->m_sValue[MAGICV_DYNAMICOBJ], caster->m_cMapIndex, 
						dX, dY, spell->m_dwLastTime*1000);

					bAnalyzeCriminalAction(iClientH, dX, dY);

					for (i = 1; i <= spell->m_hRange; i++) {
						iAddDynamicObjectList(iClientH, OWNERTYPE_PLAYER_INDIRECT, spell->m_sValue[MAGICV_DYNAMICOBJ], caster->m_cMapIndex, 
							dX + i*rx, dY + i*ry, spell->m_dwLastTime*1000);
						bAnalyzeCriminalAction(iClientH, dX + i*rx, dY + i*ry);

						iAddDynamicObjectList(iClientH, OWNERTYPE_PLAYER_INDIRECT, spell->m_sValue[MAGICV_DYNAMICOBJ], caster->m_cMapIndex, 
							dX - i*rx, dY - i*ry, spell->m_dwLastTime*1000);
						bAnalyzeCriminalAction(iClientH, dX - i*rx, dY - i*ry);
					}
					break;

				case 2:
					// Field - Type
					bool bFlag = FALSE;
					int cx, cy;
					for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++) {
						for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++)
							iAddDynamicObjectList(iClientH, OWNERTYPE_PLAYER_INDIRECT, spell->m_sValue[MAGICV_DYNAMICOBJ], caster->m_cMapIndex, 
							ix, iy, spell->m_dwLastTime*1000, spell->m_sValue[MAGICV_THROW]);

						if (bAnalyzeCriminalAction(iClientH, ix, iy, TRUE) == TRUE) {
							bFlag = TRUE;
							cx = ix;
							cy = iy;
						}
					}
					if (bFlag == TRUE) bAnalyzeCriminalAction(iClientH, cx, cy);
					break;
				}
				break;

			case DYNAMICOBJECT_ICESTORM:
				iAddDynamicObjectList(iClientH, OWNERTYPE_PLAYER_INDIRECT, spell->m_sValue[MAGICV_DYNAMICOBJ], caster->m_cMapIndex, 
					dX, dY, spell->m_dwLastTime*1000, 100);
					//caster->m_cSkillMastery[SKILL_MAGIC]);
				break;

			default:
				break;
			}
			break;

		case MAGICTYPE_POSSESSION:

			if (getPlayerNum(caster->m_cMapIndex, dX, dY, 1) != 0) break ;

			pItem = m_pMapList[caster->m_cMapIndex]->pGetItem(dX, dY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);
			
			if (!pItem) break;

			if (_bAddClientItemList(iClientH, pItem, &iEraseReq))
			{
				if(m_astoria.get() && m_astoria->IsRelicGenuine(pItem))
					m_astoria->PlayerGetRelic(caster);

				_bItemLog(ITEMLOG_GET, iClientH, (int) -1, pItem);

				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_SETITEM, caster->m_cMapIndex,
					dX, dY,	sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor);

				SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);
				if (iEraseReq == 1) delete pItem;

			}
			else 
			{
				m_pMapList[caster->m_cMapIndex]->bSetItem(dX, dY, pItem);

				SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
			}
			break;

		case MAGICTYPE_CONFUSE:
			switch (spell->m_sValue[MAGICV_TYPE]) {
			case 1: 
			case 2: // Confusion, Mass Confusion 
				for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
					for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
						m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (cOwnerType == OWNERTYPE_PLAYER) {
							if (m_pClientList[sOwnerH] == NULL) continue; 
							if (m_pClientList[sOwnerH]->m_side == caster->m_side) continue; 
							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ] != 0) continue; 
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ] = (char)spell->m_sValue[MAGICV_TYPE];

								RegisterDelayEvent(DELAYEVENTTYPE_MAGICRELEASE, MAGICTYPE_CONFUSE, dwTime + (spell->m_dwLastTime*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, spell->m_sValue[MAGICV_TYPE], NULL, NULL);

								SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTON, MAGICTYPE_CONFUSE, spell->m_sValue[MAGICV_TYPE], NULL, NULL);
							}
						}
				}
				break;

			case 3: // Ilusion, Mass-Ilusion
				for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
					for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
						m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (cOwnerType == OWNERTYPE_PLAYER) {
							if (m_pClientList[sOwnerH] == NULL) continue;
							if (m_pClientList[sOwnerH]->m_side == caster->m_side) continue; 
							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ] != 0) continue; 
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ] = (char)spell->m_sValue[MAGICV_TYPE];
								m_pClientList[sOwnerH]->SetStatusFlag(STATUS_ILLUSION, TRUE);
								RegisterDelayEvent(DELAYEVENTTYPE_MAGICRELEASE, MAGICTYPE_CONFUSE, dwTime + (spell->m_dwLastTime*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, spell->m_sValue[MAGICV_TYPE], NULL, NULL);

								SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTON, MAGICTYPE_CONFUSE, spell->m_sValue[MAGICV_TYPE], iClientH, NULL);
							}
						}
					}
				break;
			case 4:
				for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
					for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) 
					{	
						m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (cOwnerType == OWNERTYPE_PLAYER) 
						{	
							if (m_pClientList[sOwnerH] == NULL) continue;
							if (m_pClientList[sOwnerH]->m_side == caster->m_side) continue; 
							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ] != 0) continue;
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ] = (char)spell->m_sValue[MAGICV_TYPE];
								m_pClientList[sOwnerH]->SetStatusFlag(STATUS_ILLUSIONMOVEMENT, TRUE);

								RegisterDelayEvent(DELAYEVENTTYPE_MAGICRELEASE, MAGICTYPE_CONFUSE, dwTime + (spell->m_dwLastTime*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, spell->m_sValue[MAGICV_TYPE], NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTON, MAGICTYPE_CONFUSE, spell->m_sValue[MAGICV_TYPE], iClientH, NULL);
							}
						}							
					}
				break;	

			}
			break;

		case MAGICTYPE_POISON:
			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

			if (spell->m_sValue[MAGICV_TYPE] == 1) {

				switch (cOwnerType) {
				case OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;

					bAnalyzeCriminalAction(iClientH, dX, dY);

					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						if (checkResistingPoisonSuccess(sOwnerH, cOwnerType) == FALSE) {

							m_pClientList[sOwnerH]->m_bIsPoisoned  = TRUE;
							m_pClientList[sOwnerH]->m_iPoisonLevel = spell->m_sValue[MAGICV_POISONLVL];
							m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
							m_pClientList[sOwnerH]->SetStatusFlag(STATUS_POISON, TRUE);

							SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTON, MAGICTYPE_POISON, spell->m_sValue[MAGICV_POISONLVL], NULL, NULL);
#ifdef TAIWANLOG
							_bItemLog(ITEMLOG_POISONED,sOwnerH,(char *) NULL,NULL) ;
#endif
						}
					}
				break;

				case OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						if (checkResistingPoisonSuccess(sOwnerH, cOwnerType) == FALSE) {

						}
					}
			break;
				}
			}
			else if (spell->m_sValue[MAGICV_TYPE] == 0) {
				switch (cOwnerType) {
				case OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;

					if (m_pClientList[sOwnerH]->m_bIsPoisoned == TRUE) {
						m_pClientList[sOwnerH]->m_bIsPoisoned = FALSE;
						m_pClientList[sOwnerH]->SetStatusFlag(STATUS_POISON, FALSE);
						SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_POISON, NULL, NULL, NULL);
					}
					break;

				case OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					break;
				}
			}
			break;

		case MAGICTYPE_BERSERK:
			switch (spell->m_sValue[MAGICV_TYPE]) {
			case 1:
				m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				switch (cOwnerType) {
				case OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_BERSERK ] != 0) goto MAGIC_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_BERSERK ] = (char)spell->m_sValue[MAGICV_TYPE];
					m_pClientList[sOwnerH]->SetStatusFlag(STATUS_BERSERK, TRUE);
					break;

				case OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_BERSERK ] != 0) goto MAGIC_NOEFFECT;

					if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;

					if ( caster->m_side != m_pNpcList[sOwnerH]->m_side ) goto MAGIC_NOEFFECT;

					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_BERSERK ] = (char)spell->m_sValue[MAGICV_TYPE];
					m_pNpcList[sOwnerH]->SetStatusFlag(STATUS_BERSERK, TRUE);
					break;
				}

			RegisterDelayEvent(DELAYEVENTTYPE_MAGICRELEASE, MAGICTYPE_BERSERK, dwTime + (spell->m_dwLastTime*1000), 
				sOwnerH, cOwnerType, NULL, NULL, NULL, spell->m_sValue[MAGICV_TYPE], NULL, NULL);

			if (cOwnerType == OWNERTYPE_PLAYER)
				SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTON, MAGICTYPE_BERSERK, spell->m_sValue[MAGICV_TYPE], NULL, NULL);
				break;
			}
		break;

		case MAGICTYPE_DAMAGE_AREA_ARMOR_BREAK:

			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
					m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, FALSE, iMagicAttr);
						ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, spell->m_sValue[MAGICV_ARMORDEC]);
					}

					m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {

							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWhetherBonus, FALSE, iMagicAttr);
								ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, spell->m_sValue[MAGICV_ARMORDEC]);
							}
					}
				}
				break;

		case MAGICTYPE_ICE:
			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {

					m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						//Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue4, spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr);
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr);

						switch (cOwnerType) 
						{
						case OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;

							if (m_pClientList[sOwnerH]->IsNeutral()) goto MAGIC_NOEFFECT;

							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (checkResistingIceSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								m_pClientList[sOwnerH]->AddMagicEffect(spell->m_sType, spell->m_sValue[MAGICV_ICEDURATION]);
							}
							break;

						case OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (checkResistingIceSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								m_pNpcList[sOwnerH]->AddMagicEffect(spell->m_sType, spell->m_sValue[MAGICV_ICEDURATION]);
							}
							break;
						}

					}

					m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {

							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {

								//Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue4, spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr);
								Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWhetherBonus, TRUE, iMagicAttr);

								if ((m_pClientList[sOwnerH]->m_iHP > 0) && (checkResistingIceSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_ICE ] == 0) {
										m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_ICE ] = 1;
										m_pClientList[sOwnerH]->SetStatusFlag(STATUS_FROZEN, TRUE);
										RegisterDelayEvent(DELAYEVENTTYPE_MAGICRELEASE, MAGICTYPE_ICE, dwTime + (spell->m_sValue[MAGICV_ICEDURATION]*1000), 
											sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);

										SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTON, MAGICTYPE_ICE, 1, NULL, NULL);
									}
								}
							}
					}
				}
				break;

		default:
			break;
		}
	}
	else {


	}

MAGIC_NOEFFECT:;

	if (caster == NULL) return;

	//Mana Slate
	if ((caster->m_iStatus & STATUS_BLUESLATE) != 0) {
		iManaCost = 0;
	}


	caster->m_iMP -= iManaCost; 
	if (caster->m_iMP < 0) 
		caster->m_iMP = 0;

	//CalculateSSN_SkillIndex(iClientH, SKILL_MAGIC, 1 );

	SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_MAGIC, caster->m_cMapIndex,
		caster->m_sX, caster->m_sY, dX, dY, (sType+100), caster->m_sType);

	SendNotifyMsg(NULL, iClientH, NOTIFY_MP, NULL, NULL, NULL, NULL);
}


void CGame::RequestTeleportHandler(int iClientH, char teleportType, char * cMapName, int dX, int dY)
{
	char  cTempMapName[21];
	char  cDestMapName[11], cDir, cMapIndex;
	short sX, sY;
	int   i, iDestX, iDestY, iExH, iMapSide;
	BOOL    bRet, bIsLockedMapNotify;
	bool setRecallTime = TRUE;

	CClient * player = m_pClientList[iClientH];

	if (!player) return;
	if (player->m_bIsInitComplete == FALSE) return;
	if (player->m_bIsKilled == TRUE) return;
	if (player->m_bIsOnWaitingProcess == TRUE) return;

	if((teleportType == 1 || teleportType == 3) &&
		player->m_iAdminUserLevel == 0 &&
		player->IsInFoeMap())
			return;

	sX = player->m_sX;
	sY = player->m_sY;

	ZeroMemory(cDestMapName, sizeof(cDestMapName));
	bRet = m_pMapList[player->m_cMapIndex]->bSearchTeleportDest(sX, sY, cDestMapName, &iDestX, &iDestY, &cDir);

	if(!bRet && teleportType == 4){
		/*SendObjectMotionRejectMsg(iClientH);
		SendNotifyMsg(NULL, iClientH, NOTIFY_TELEPORT_REJECTED,sX,sY,NULL,NULL);
		return;*/ //Leave commented out till next client
	}
	
	if(player->m_cMapIndex == m_iAstoriaMapIndex	&& m_astoria.get())
	{
		int index = player->HasItem(ITEM_RELIC);
		if(index != ITEM_NONE)
		{
			DropItemHandler(player->m_handle, index, 1, player->m_pItemList[index]->m_cName, FALSE);
		}
	}

	bIsLockedMapNotify = FALSE;

	if (player->m_isExchangeMode == TRUE) {
		iExH = player->m_exchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
	}

	RemoveFromTarget(iClientH, OWNERTYPE_PLAYER);

	m_pMapList[player->m_cMapIndex]->ClearOwner(/*13,*/ iClientH, OWNERTYPE_PLAYER, sX, sY);

	SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_LOG, MSGTYPE_REJECT, NULL, NULL, NULL);

	iMapSide = iGetMapLocationSide(cDestMapName);
	if ((strcmp(player->m_cLockedMapName, "NONE") != 0) && (player->m_iLockedMapTime > 0)) {

		int tmp_mapSide = iMapSide;
		if (tmp_mapSide >= 11) tmp_mapSide -= 10 ;

		if (tmp_mapSide == 0 || player->m_side != tmp_mapSide) {
			iDestX = -1;
			iDestY = -1;
			bIsLockedMapNotify = TRUE;
			ZeroMemory(cDestMapName, sizeof(cDestMapName));
			strcpy(cDestMapName, player->m_cLockedMapName);
		}
	}

	if(player->IsNeutral() && memcmp(player->m_cMapName, "default2", 8) == 0)
	{
		int tmp_mapSide = iMapSide;
		if (tmp_mapSide >= 11) tmp_mapSide -= 10 ;
		if((Side)tmp_mapSide != NEUTRAL)
		{
			ChangeNation(player->m_handle, (Side)tmp_mapSide);
			wsprintf(g_cTxt, "Istrian %s chose %s!", player->m_cCharName, sideName[tmp_mapSide]);
			PutLogList(g_cTxt);
		}
		else
		{
			bRet = TRUE;
			memcpy(cDestMapName, "default2", 10);
			iDestX = iDestY = -1;
			cDir = SOUTH;
		}
	}

	cMapIndex = iGetMapIndex(cDestMapName);
	
	if(player->m_cMapIndex == m_iAstoriaMapIndex && memcmp(cDestMapName, "astoria", 7) == 0)
	{
		uint32 baseNumber = cDestMapName[7] - '0';
		ZeroMemory(cDestMapName, sizeof(cDestMapName));
		if(player->m_side == m_astoriaBasePos[baseNumber])
		{
			ZeroMemory(cDestMapName, sizeof(cDestMapName));
			strcpy(cDestMapName, sideMap[ m_astoriaBasePos[baseNumber] ]);
		}else
		{
			ZeroMemory(cDestMapName, sizeof(cDestMapName));
			strcpy(cDestMapName, player->m_cMapName);
			iDestX = player->m_sX;
			iDestY = player->m_sY;
			setRecallTime = FALSE;
		}
	}
		// Logging in enemy shops => Set recall time if Crusade or Standard Map settings
	if ( (m_bIsCrusadeMode == TRUE)
		&& (m_pClientList[iClientH]->m_side == iGetMapLocationForbiddenSide(cDestMapName)) 
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0))  // Not in own town
	{	m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
	}

	// Locked maps, such as bisle, jails, cities in Crusade
	if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) 
	{	int iSideMapCdt = iGetMapLocationForbiddenSide(cDestMapName) + m_pClientList[iClientH]->m_side;
		if ((iSideMapCdt == 3) || (strcmp(m_pClientList[iClientH]->m_cLockedMapName, cDestMapName) == 0))
		{}else // 3 allows city buildings when blocked in city
		{	iDestX = -1;
			iDestY = -1;
			bIsLockedMapNotify = TRUE;
			ZeroMemory(cDestMapName, sizeof(cDestMapName));
			strcpy(cDestMapName, m_pClientList[iClientH]->m_cLockedMapName);

	}	}
	//if (bRet && !cMapName) {
	//	for (i = 0; i < MAXMAPS; i++)
	//	{
	//		if (m_pMapList[i] != NULL) {
	//			if (memcmp(m_pMapList[i]->m_cName, cDestMapName, 10) == 0) {
	//				player->m_sX   = iDestX;	  
	//				player->m_sY   = iDestY;
	//				player->m_cDir = cDir;
	//				player->m_cMapIndex = i; 
	//				ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));
	//				memcpy(player->m_cMapName, m_pMapList[i]->m_cName, 10);  
	//				goto RTH_NEXTSTEP;
	//			}
	//		}
	//	}

	//	player->m_sX   = iDestX;	  
	//	player->m_sY   = iDestY;
	//	player->m_cDir = cDir;
	//	ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));
	//	memcpy(player->m_cMapName, cDestMapName, 10);

	//	// Slate
	//	SendNotifyMsg(NULL, iClientH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_CONFUSE,
	//		player->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ], NULL, NULL);
	//	SetSlateFlag(iClientH, NOTIFY_SLATECLEAR, FALSE);

	//	bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE);  

	//	player->m_bIsOnServerChange = TRUE;
	//	player->m_bIsOnWaitingProcess = TRUE;
	//	return;

		if ((bRet == TRUE) && (cMapName == NULL))  // Parse TP command from client.
	{	// bRet=> found a location on current map, cMapName==NULL => no map parsed to this function
		for (i = 0; i < MAXMAPS; i++)
		{	if (m_pMapList[i] != NULL) 
			{	if (memcmp(m_pMapList[i]->m_cName, cDestMapName, 10) == 0) 
				{	m_pClientList[iClientH]->m_sX   = iDestX;	  
					m_pClientList[iClientH]->m_sY   = iDestY;
					m_pClientList[iClientH]->m_cDir = cDir;
					m_pClientList[iClientH]->m_cMapIndex = i; 
					ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
					memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);  // 
					goto RTH_NEXTSTEP;			
		}	}	}
		// teleport on another server 
		m_pClientList[iClientH]->m_sX   = iDestX;
		m_pClientList[iClientH]->m_sY   = iDestY;
		m_pClientList[iClientH]->m_cDir = cDir;
		ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
		memcpy(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10);  
		// New 18/05/2004
		SendNotifyMsg(NULL, iClientH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_CONFUSE,
			m_pClientList[iClientH]->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ], NULL, NULL);
		SetSlateFlag(iClientH, NOTIFY_SLATECLEAR, FALSE);
		bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); 
		m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
		return;
	}
	else {
		switch (teleportType) {
		case 0: // Forced Recall. 
		case 1: // Normal Recall 
			//if (memcmp(m_pMapList[ player->m_cMapIndex ]->m_cName, "resurr", 6) == 0) return;
			ZeroMemory(cTempMapName, sizeof(cTempMapName));

			if (player->m_iLevel > 80)
				strcpy(cTempMapName, sideMap[ player->m_side ]);
			else
				strcpy(cTempMapName, sideMapFarm[ player->m_side ]);

			// Crusade
			if ((strcmp(player->m_cLockedMapName, "NONE") != 0) && (player->m_iLockedMapTime > 0)) {

				bIsLockedMapNotify = TRUE;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, player->m_cLockedMapName);
			}
			
			for (i = 0; i < MAXMAPS; i++)
			{
				if (m_pMapList[i] != NULL) {
					if (memcmp(m_pMapList[i]->m_cName, cTempMapName, 10) == 0) {

						GetMapInitialPoint(i, &player->m_sX, &player->m_sY, player->m_cLocation);

						player->m_cMapIndex = i; 
						ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));
						memcpy(player->m_cMapName, m_pMapList[i]->m_cName, 10);  
						goto RTH_NEXTSTEP;
					}
				}
			}

			player->m_sX   = -1;	  
			player->m_sY   = -1;	  

			ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));
			memcpy(player->m_cMapName, cTempMapName, 10);  
			// Slate
			SendNotifyMsg(NULL, iClientH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_CONFUSE,
				player->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ], NULL, NULL);
			SetSlateFlag(iClientH, NOTIFY_SLATECLEAR, FALSE);

			bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); 

			player->m_bIsOnServerChange   = TRUE;
			player->m_bIsOnWaitingProcess = TRUE;
			return;

		case 2: // Forced teleport  
		case 3: // Player requested teleport 
			if ((strcmp(player->m_cLockedMapName, "NONE") != 0) && (player->m_iLockedMapTime > 0) && (memcmp(cMapName, "resurr", 6) != 0)) {
				dX = -1;
				dY = -1;
				bIsLockedMapNotify = TRUE;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, player->m_cLockedMapName);
			}
			else {
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, cMapName);
			}

			cMapIndex = iGetMapIndex(cTempMapName);
			if (cMapIndex == -1) {
				player->m_sX   = dX; //-1;	  			
				player->m_sY   = dY; //-1;	  

				ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));
				memcpy(player->m_cMapName, cTempMapName, 10);  
				// Slate
				SendNotifyMsg(NULL, iClientH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_CONFUSE,
					player->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ], NULL, NULL);
				SetSlateFlag(iClientH, NOTIFY_SLATECLEAR, FALSE);

				bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); 

				player->m_bIsOnServerChange   = TRUE;
				player->m_bIsOnWaitingProcess = TRUE;
				return;
			}

			player->m_cMapIndex = cMapIndex;

			if (dX == -1 || dY == -1)
				GetMapInitialPoint(cMapIndex, &player->m_sX, &player->m_sY, player->m_cLocation);
			else 
			{
				player->m_sX   = dX;
				player->m_sY   = dY;
			}

				ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));
			memcpy(player->m_cMapName, m_pMapList[cMapIndex]->m_cName, 10);  
			break;
		}
	}

RTH_NEXTSTEP:;


	PlayerMapEntry(iClientH, setRecallTime);
	Notify_ApocalypseGateState(iClientH);	
	if (m_bHeldenianMode) UpdateHeldenianStatus();
	if (bIsLockedMapNotify == TRUE) SendNotifyMsg(NULL, iClientH, NOTIFY_LOCKEDMAP, player->m_iLockedMapTime, NULL, NULL, player->m_cLockedMapName);

	}
int CGame::iGetMapLocationForbiddenSide(char *pMapName)
{// SNOOPY: Inverted this function, not used if EQUILIBRIUM map-mode	
 // Returns forbidden side
 // But if Side + ForbidenSide = 3, means map is good side....
	if (strcmp(pMapName, "wrhus_1") == 0)	return 2;
	if (strcmp(pMapName, "wrhus_2") == 0)	return 1;
	if (strcmp(pMapName, "bsmith_1") == 0)	return 2;
	if (strcmp(pMapName, "bsmith_2") == 0)	return 1;
	if (strcmp(pMapName, "gshop_1") == 0)	return 2;
	if (strcmp(pMapName, "gshop_2") == 0)	return 1;
	if (strcmp(pMapName, "arefarm") == 0)	return 2;
	if (strcmp(pMapName, "elvfarm") == 0)	return 1;
	if (strcmp(pMapName, "arewrhus") == 0) return 2;
	if (strcmp(pMapName, "elvwrhus") == 0) return 1;
	if (strcmp(pMapName, "cityhall_1") == 0) return 2;
	if (strcmp(pMapName, "cityhall_2") == 0) return 1;
	if (strcmp(pMapName, "cath_1") == 0)	return 2;
	if (strcmp(pMapName, "cath_2") == 0)	return 1;
	if (strcmp(pMapName, "gldhall_1") == 0) return 2;
	if (strcmp(pMapName, "gldhall_2") == 0) return 1;
	if (strcmp(pMapName, "cmdhall_1") == 0) return 2;
	if (strcmp(pMapName, "Cmdhall_2") == 0) return 1;
	if (strcmp(pMapName, "wzdtwr_1") == 0) return 2;
	if (strcmp(pMapName, "wzdtwr_2") == 0) return 1;
	return -99;
}


void CGame::RequestTeleportListHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;

	char	*cp, cData[512];
	int		iRet;
	DWORD	*dwp;
	WORD	*wp;
	int		iMapSide = -1;
	int		*listCount;
	char	cNpcName[21];
	int		*ip;

	if( strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, sideMap[ARESDEN]) == 0)
		iMapSide = ARESDEN;
	else if( strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, sideMap[ELVINE]) == 0)
		iMapSide = ELVINE;
	else if( strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, sideMap[ISTRIA]) == 0)
		iMapSide = ISTRIA;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	ZeroMemory(cNpcName, sizeof(cNpcName));
	strncpy(cNpcName, cp, 20);
	cp += 20;

	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(cData + INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_TELEPORT_LIST;
	wp   = (WORD *)(cData + INDEX2_MSGTYPE);
	*wp  = MSGTYPE_CONFIRM;

	cp = cData + 6;

	listCount = (int*) cp; 
	*listCount = 0;
	cp += 4; // sizeof(int)

	int	index;
	for(index = 0; index < MAXTELEPORTLIST; index++)
	{
		if( m_pTeleportConfigList[index] == NULL ) continue;


		if( strncmp( m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName,
			m_pTeleportConfigList[index]->m_cSourceMap, 10) != 0 )
			continue;

		if( strncmp( m_pTeleportConfigList[index]->m_cNpcname, cNpcName, 20) != 0 )
			continue;

		if( m_pTeleportConfigList[index]->m_iMinLvl > m_pClientList[iClientH]->m_iLevel ||
			m_pTeleportConfigList[index]->m_iMaxLvl < m_pClientList[iClientH]->m_iLevel)
			continue;

		if(!m_pTeleportConfigList[index]->m_bNetural &&	m_pClientList[iClientH]->IsNeutral())
			continue;

		if(!m_pTeleportConfigList[index]->m_bCriminal && m_pClientList[iClientH]->m_iPKCount > 0 )
			continue;

		SYSTEMTIME currTime;
		GetLocalTime(&currTime);
		if(!m_astoria.get() && strcmp(m_pTeleportConfigList[index]->m_cTargetMap, "astoria") == 0 &&
			(currTime.wDayOfWeek == FRIDAY || 
			currTime.wDayOfWeek == SATURDAY ||
			currTime.wDayOfWeek == SUNDAY))
		{
			continue;
		}

		if(strcmp(m_pTeleportConfigList[index]->m_cTargetMap, "middleland") == 0 && 
			m_eventWinner[ET_CAPTURE] != m_pClientList[iClientH]->m_side)
		{
			continue;
		}
		if (!m_bHeldenianMode && strcmp(m_pTeleportConfigList[index]->m_cTargetMap, "BtField") == 0 && 
			m_iHeldenianType1Winner != m_pClientList[iClientH]->m_side)
		{
			continue;
		}
		if( (
			m_pClientList[iClientH]->IsNeutral() &&
			( m_pTeleportConfigList[index]->m_iSide == ALLSIDES ||
			m_pTeleportConfigList[index]->m_iSide == iMapSide )
			) || (
			m_pTeleportConfigList[index]->m_iSide == ALLSIDES ||
			m_pTeleportConfigList[index]->m_iSide == m_pClientList[iClientH]->m_side
			)
			)
		{
			ip = (int*) cp;
			*ip = index;
			cp += 4;

			memcpy(cp, m_pTeleportConfigList[index]->m_cTargetMap, 10);
			cp += 10;

			ip = (int*) cp;
			*ip = m_pTeleportConfigList[index]->m_iX;
			cp += 4;

			ip = (int*) cp;
			*ip = m_pTeleportConfigList[index]->m_iY;
			cp += 4;

			ip = (int*) cp;
			if((m_astoria.get() && strcmp(m_pTeleportConfigList[index]->m_cTargetMap, "astoria") == 0) ||
				(m_bHeldenianMode && 
					(strcmp(m_pTeleportConfigList[index]->m_cTargetMap, "BtField") == 0 ||
					strcmp(m_pTeleportConfigList[index]->m_cTargetMap, "HRampart") == 0))
					)
				*ip = 0;
			else
				*ip = m_pTeleportConfigList[index]->m_cost;
			cp += 4;
		}
		else continue;

		(*listCount) ++;
	} // for


	if ( (*listCount) == 0 )
		*wp  = MSGTYPE_REJECT;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10 + (*listCount) * 26 );

	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
} // RequestTeleportListHandler


void CGame::RequestChargedTeleportHandler(int iClientH, char *pData, DWORD dwMsgSize)
{
	CClient * player = m_pClientList[iClientH];
	if (!player) return;
	if (player->m_bIsInitComplete == FALSE) return;
	if (player->m_bIsKilled == TRUE) return;
	if (player->m_bIsOnWaitingProcess == TRUE) return;

	char	*cp, cData[64];
	int		iRet;
	DWORD	*dwp;
	WORD	*wp;
	int		iMapSide = -1;
	int		index;
	WORD	wConfirm = MSGTYPE_CONFIRM;
	short	sError = 0;


	if( strcmp(m_pMapList[player->m_cMapIndex]->m_cLocationName, sideMap[ARESDEN]) == 0)
		iMapSide = ARESDEN;
	else if( strcmp(m_pMapList[player->m_cMapIndex]->m_cLocationName, sideMap[ELVINE]) == 0)
		iMapSide = ELVINE;
	else if( strcmp(m_pMapList[player->m_cMapIndex]->m_cLocationName, sideMap[ISTRIA]) == 0)
		iMapSide = ISTRIA;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	index = (int) (*cp);
	cp += 4;

	if( index < 0 || index >= MAXTELEPORTLIST)
		return;

	if( m_pTeleportConfigList[index] == NULL )
		return;


	if( strncmp( m_pMapList[player->m_cMapIndex]->m_cName,
		m_pTeleportConfigList[index]->m_cSourceMap, 10) != 0 )
		return;

	if( m_pTeleportConfigList[index]->m_iMinLvl > player->m_iLevel ||
		m_pTeleportConfigList[index]->m_iMaxLvl < player->m_iLevel)
	{
		wConfirm = MSGTYPE_REJECT;
		sError = 1;
	}

	if( wConfirm == MSGTYPE_CONFIRM &&
		m_pTeleportConfigList[index]->m_bNetural == FALSE &&
		player->IsNeutral())
	{
		wConfirm = MSGTYPE_REJECT;
		sError = 3;
	}

	if( wConfirm == MSGTYPE_CONFIRM &&
		m_pTeleportConfigList[index]->m_bCriminal == FALSE &&
		player->m_iPKCount > 0 )
	{
		wConfirm = MSGTYPE_REJECT;
		sError = 4;
	}


	if( wConfirm == MSGTYPE_CONFIRM &&
		player->IsNeutral() &&
		( 
		m_pTeleportConfigList[index]->m_iSide != ALLSIDES && 
		m_pTeleportConfigList[index]->m_iSide != iMapSide 
		) )
	{
		wConfirm = MSGTYPE_REJECT;
		sError = 5;
	}
	else if (wConfirm == MSGTYPE_CONFIRM &&
		m_pTeleportConfigList[index]->m_iSide != ALLSIDES &&
		m_pTeleportConfigList[index]->m_iSide != player->m_side )
	{
		wConfirm = MSGTYPE_REJECT;
		sError = 5;
	}

	if( wConfirm == MSGTYPE_CONFIRM )
	{

		DWORD cost, dwGoldCount = dwGetItemCount(iClientH, "Gold");

		if((m_astoria.get() && strcmp(m_pTeleportConfigList[index]->m_cTargetMap, "astoria") == 0) ||
			(m_bHeldenianMode && 
				(strcmp(m_pTeleportConfigList[index]->m_cTargetMap, "BtField") == 0 ||
				strcmp(m_pTeleportConfigList[index]->m_cTargetMap, "HRampart") == 0))
			)
			cost = 0;
		else
			cost = m_pTeleportConfigList[index]->m_cost;

		if( dwGoldCount >= cost )
		{
			int iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - cost);

			iCalcTotalWeight(iClientH);
			m_stCityStatus[player->m_side].iFunds += cost;
		} else {
			wConfirm = MSGTYPE_REJECT;
			sError = 6;			
		}
	}

	// Invalid Charged-teleport
	if ( wConfirm == MSGTYPE_REJECT )
	{
		ZeroMemory(cData, sizeof(cData));
		dwp  = (DWORD *)(cData + INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_CHARGED_TELEPORT;
		wp   = (WORD *)(cData + INDEX2_MSGTYPE);
		*wp  = wConfirm;

		cp = cData + INDEX2_MSGTYPE + 2;

		short	*sp;
		sp	= (short*) cp;
		*sp	= sError;
		cp += 2;


		iRet = player->m_pXSock->iSendMsg(cData, 6 + 2 );

		switch (iRet) 
		{
		case XSOCKEVENT_QUENEFULL:
		case XSOCKEVENT_SOCKETERROR:
		case XSOCKEVENT_CRITICALERROR:
		case XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
		return;
	}

	uint32 x,y;

	if(strcmp(m_pTeleportConfigList[index]->m_cTargetMap, "astoria") == 0)
	{
		uint32 i;
		for(i=0; i < MAXALTARS; i++)
		{
			if(player->m_side == m_astoriaBasePos[i])
				break;
		}
		x = astoriaStartPos[i].x;
		y = astoriaStartPos[i].y;

		if (m_astoria.get()) 
			SetSlateFlag(iClientH, NOTIFY_SLATECLEAR, FALSE);
	}
	else
	{
		x = m_pTeleportConfigList[index]->m_iX;
		y = m_pTeleportConfigList[index]->m_iY;
	}

	RequestTeleportHandler(iClientH, 2,
		m_pTeleportConfigList[index]->m_cTargetMap, x, y);

} // RequestChargedTeleportHandler


void CGame::ReleaseFollowMode(short sOwnerH, char cOwnerType)
{
	register int i;

	for (i = 0; i < MAXNPCS; i++)
		if ((i != sOwnerH) && (m_pNpcList[i] != NULL)) {
			if ((m_pNpcList[i]->m_cMoveType == MOVETYPE_FOLLOW) &&
				(m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH) &&
				(m_pNpcList[i]->m_cFollowOwnerType == cOwnerType)) {

					m_pNpcList[i]->m_cMoveType = MOVETYPE_RANDOMWAYPOINT;
			}
		}
}

void CGame::RequestUpdateFriendsHandler(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = ", ";
	char   * token, friendName[11], cBuff[256], nameBuff[256];
	register int i;
	bool friendFound;
	char *cp;
	WORD *wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (dwMsgSize <= 0) return;

	StrTok pStrTok(new CStrTok(pData+6, seps));
	token = pStrTok->pGet();

	ZeroMemory(nameBuff, sizeof(nameBuff));
	for (int j = 0;token != NULL && j < 13; j++) {
		friendFound = false;
		if(strlen(token) == 0) continue;
		ZeroMemory(friendName, sizeof(friendName));
		if (strlen(token) > 10)	memcpy(friendName, token, 10);
		else memcpy(friendName, token, strlen(token));
		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, friendName, 10) == 0)) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_FRIENDONGAME, NULL, NULL, NULL, m_pClientList[i]->m_cCharName, NULL, NULL, NULL, NULL, NULL, NULL, "");
				friendFound = true;
				break;
			}
			if(!friendFound){
				strcat(nameBuff,token);
				strcat(nameBuff," ");
			}
			token = pStrTok->pGet();
	}

	if(strlen(nameBuff) > 0){
		ZeroMemory(cBuff, sizeof(cBuff));
		cp = (char *)cBuff;
		*cp = GSM_REQUEST_FINDFRIEND;
		cp++;

		wp = (WORD *)cp;
		*wp = GSID;
		cp += 2;

		wp = (WORD *)cp;
		*wp = iClientH;
		cp += 2;

		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;

		wp  = (WORD *)cp;
		*wp = (WORD)strlen(nameBuff);
		cp += 2;

		strcpy(cp, nameBuff);
		cp += strlen(nameBuff);

		bStockMsgToGateServer(cBuff, 17 + strlen(nameBuff));
	}


}

bool CGame::_bDecodeMagicConfigFileContents(char * pData, DWORD dwMsgSize)
{
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iMagicConfigListIndex = 0;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) 
			{
			case 1:
				switch (cReadModeB) 
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}

					if (m_pMagicConfigList[atoi(token)] != NULL) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Duplicate magic number.");
						delete[] pContents;
						return FALSE;
					}
					m_pMagicConfigList[atoi(token)] = new class CMagic;
					iMagicConfigListIndex = atoi(token);

					cReadModeB++;
					break;

				case 2:
					ZeroMemory(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, sizeof(m_pMagicConfigList[iMagicConfigListIndex]->m_cName));
					memcpy(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB++;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sType = atoi(token);
					cReadModeB++;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_dwDelayTime = atoi(token);
					cReadModeB++;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_dwLastTime = atoi(token);
					cReadModeB++;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_manaCost = atoi(token);
					cReadModeB++;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_hRange = atoi(token)/2;
					cReadModeB++;
					break;

				case 8:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_vRange = atoi(token)/2;
					cReadModeB++;
					break;

				case 9:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue[0] = atoi(token);
					cReadModeB++;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue[1] = atoi(token);
					cReadModeB++;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue[2] = atoi(token);
					cReadModeB++;
					break;

				case 12:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue[3] = atoi(token);
					cReadModeB++;
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue[4] = atoi(token);
					cReadModeB++;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue[5] = atoi(token);
					cReadModeB++;
					break;

				case 15:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue[6] = atoi(token);
					cReadModeB++;
					break;

				case 16:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue[7] = atoi(token);
					cReadModeB++;
					break;

				case 17:
					// m_sIntLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sIntLimit = atoi(token);
					cReadModeB++;
					break;

				case 18:
					// m_iGoldCost
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_iGoldCost = atoi(token);

					cReadModeB++;
					break;

				case 19:
					// m_cCategory
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_cCategory = atoi(token);
					cReadModeB++;
					break;

				case 20:
					// m_iAttribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_iAttribute = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "magic", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}

		}
		token = pStrTok->pGet();
	}

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(ERROR) CRITICAL ERROR! MAGIC configuration file contents error!");
		return FALSE;
	}

	//wsprintf(cTxt, "(!) MAGIC(Total:%d) configuration - success!", iMagicConfigListIndex);
	//PutLogList(cTxt);

	return TRUE;

}



bool CGame::_bDecodeSkillConfigFileContents(char * pData, DWORD dwMsgSize)
{
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iSkillConfigListIndex = 0;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
			case 1:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				if (m_pSkillConfigList[atoi(token)] != NULL) {
					PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Duplicate magic number.");
					delete[] pContents;
					return FALSE;
				}
				m_pSkillConfigList[atoi(token)] = new class CSkill;
				iSkillConfigListIndex = atoi(token);

				cReadModeB++;
				break;

			case 2:
				ZeroMemory(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, sizeof(m_pSkillConfigList[iSkillConfigListIndex]->m_cName));
				memcpy(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, token, strlen(token));
				cReadModeB++;
				break;

			case 3:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pSkillConfigList[iSkillConfigListIndex]->m_sType = atoi(token);
				cReadModeB++;
				break;

			case 4:
				// m_sValue1
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pSkillConfigList[iSkillConfigListIndex]->m_sValue1 = atoi(token);
				cReadModeB++;
				break;

			case 5:
				// m_sValue2
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pSkillConfigList[iSkillConfigListIndex]->m_sValue2 = atoi(token);
				cReadModeB++;
				break;

			case 6:
				// m_sValue3
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pSkillConfigList[iSkillConfigListIndex]->m_sValue3 = atoi(token);
				cReadModeB++;
				break;

			case 7:
				// m_sValue4
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pSkillConfigList[iSkillConfigListIndex]->m_sValue4 = atoi(token);
				cReadModeB++;
				break;

			case 8:
				// m_sValue5
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pSkillConfigList[iSkillConfigListIndex]->m_sValue5 = atoi(token);
				cReadModeB++;
				break;

			case 9:
				// m_sValue6
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pSkillConfigList[iSkillConfigListIndex]->m_sValue6 = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "skill", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}

		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(ERROR) CRITICAL ERROR! SKILL configuration file contents error!");
		return FALSE;
	}

	//wsprintf(cTxt, "(!) SKILL(Total:%d) configuration - success!", iSkillConfigListIndex);
	//PutLogList(cTxt);

	return TRUE;
}



bool CGame::_bDecodeTeleportListConfigFileContents(char * pData, DWORD dwMsgSize)
{
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();

	uint32 count = 0;

	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) 
			{
			case 1:
				switch (cReadModeB) 
				{
				case 1: 
					m_pTeleportConfigList[count] = new class CTeleport;
					memcpy(m_pTeleportConfigList[count]->m_cNpcname, token, strlen(token));
					cReadModeB++;
					break;

				case 2: // SOURCE MAP
					memcpy(m_pTeleportConfigList[count]->m_cSourceMap, token, strlen(token));
					cReadModeB++;
					break;

				case 3: // TARGET MAP
					memcpy(m_pTeleportConfigList[count]->m_cTargetMap, token, strlen(token));
					cReadModeB++;
					break;

				case 4: // TARGET MAP X
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pTeleportConfigList[count]->m_iX = atoi(token);
					cReadModeB++;
					break;

				case 5: // TARGET MAP Y
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pTeleportConfigList[count]->m_iY = atoi(token);
					cReadModeB++;
					break;

				case 6: // COST
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pTeleportConfigList[count]->m_cost = atoul(token);
					cReadModeB++;
					break;

				case 7: // Minimum Level
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pTeleportConfigList[count]->m_iMinLvl = atoi(token);
					cReadModeB++;
					break;

				case 8: // Maximum Level
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pTeleportConfigList[count]->m_iMaxLvl = atoi(token);
					cReadModeB++;
					break;

				case 9: // Side (aresden, elvine, istria)
					if( strcmp(token, sideMap[ARESDEN]) == 0 )
					{
						m_pTeleportConfigList[count]->m_iSide = ARESDEN;
					}
					else if( strcmp(token, sideMap[ELVINE]) == 0 )
					{
						m_pTeleportConfigList[count]->m_iSide = ELVINE;
					}
					else if( strcmp(token, sideMap[ISTRIA]) == 0 )
					{
						m_pTeleportConfigList[count]->m_iSide = ISTRIA;
					}
					else if( strcmp(token, "all") == 0 )
					{
						m_pTeleportConfigList[count]->m_iSide = ALLSIDES;
					}
					else if( strcmp(token, "attacker") == 0 )
					{
						m_pTeleportConfigList[count]->m_iSide = ATTACKER;
					}
					else if( strcmp(token, "defender") == 0 )
					{
						m_pTeleportConfigList[count]->m_iSide = DEFENDER;
					}
					else
					{
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					cReadModeB++;
					break;

				case 10: // Netural
					if( strcmp(token,"FALSE") == 0 )
						m_pTeleportConfigList[count]->m_bNetural = FALSE;
					else if( strcmp(token,"TRUE") == 0 )
						m_pTeleportConfigList[count]->m_bNetural = TRUE;
					else
					{
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					cReadModeB++;
					break;

				case 11: // Criminal
					if( strcmp(token,"FALSE") == 0 )
						m_pTeleportConfigList[count]->m_bCriminal = FALSE;
					else if( strcmp(token,"TRUE") == 0 )
						m_pTeleportConfigList[count]->m_bCriminal = TRUE;
					else
					{
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					cReadModeA = 0;
					cReadModeB = 0;
					count++;
					break;
				}
				break;
			default:
				break;
			}
		}
		else
		{
			if (memcmp(token, "teleport", 8) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			else if (memcmp(token, "[END]", 5) == 0)
			{
				cReadModeA = 0;
				cReadModeB = 0;
				break; // Stop While Loop
			}
		}

		token = pStrTok->pGet();

	} // while

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(ERROR) CRITICAL ERROR! TELEPORT-LIST configuration file contents error!");
		return FALSE;
	}

	//wsprintf(cTxt, "(!) TELEPORT-LIST(Total:%d) configuration - success!", count);
	//PutLogList(cTxt);

	return TRUE;
} // _bDecodeTeleportListConfigFileContents



void CGame::RequestStudyMagicHandler(int iClientH, char * pName, bool bIsPurchase)
{
	char  * cp, cMagicName[31], cData[100];
	DWORD * dwp, dwGoldCount;
	WORD  * wp;
	int   * ip, iReqInt, iCost, iRet;
	bool bMagic = TRUE ;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	ZeroMemory(cData, sizeof(cData));

	ZeroMemory(cMagicName, sizeof(cMagicName));
	memcpy(cMagicName, pName, 30);

	iRet = _iGetMagicNumber(cMagicName, &iReqInt, &iCost);
	if (iRet == -1) {

	}
	else {
		if (bIsPurchase == TRUE) {
			if (m_pMagicConfigList[iRet]->m_iGoldCost < 0) bMagic = FALSE ; 
			dwGoldCount = dwGetItemCount(iClientH, "Gold");
			if ((DWORD)iCost > dwGoldCount)  bMagic = FALSE ; 
			if (!m_pClientList[iClientH]->m_bIsOnTower && 
				(!m_pClientList[iClientH]->IsNeutral() && !m_pClientList[iClientH]->m_bIsOnShop)
				) bMagic = FALSE ;
		}

		if (m_pClientList[iClientH]->m_cMagicMastery[iRet] != 0) return;

		if ((iReqInt <= m_pClientList[iClientH]->GetInt()) && (bMagic == TRUE) ) {

			if (bIsPurchase == TRUE) SetItemCount(iClientH, "Gold", dwGoldCount - iCost);

			iCalcTotalWeight(iClientH);

			m_pClientList[iClientH]->m_cMagicMastery[iRet] = 1;

			dwp  = (DWORD *)(cData + INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + INDEX2_MSGTYPE);
			*wp  = NOTIFY_MAGICSTUDYSUCCESS;

			cp = (char *)(cData + INDEX2_MSGTYPE + 2);

			*cp = iRet;
			cp++;

			memcpy(cp, cMagicName, 30);
			cp += 30;


			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 37);

#ifdef TAIWANLOG 
			_bItemLog(ITEMLOG_MAGICLEARN,iClientH, cMagicName, NULL);
#endif
			switch (iRet) {
			case XSOCKEVENT_QUENEFULL:
			case XSOCKEVENT_SOCKETERROR:
			case XSOCKEVENT_CRITICALERROR:
			case XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
		else {

			dwp  = (DWORD *)(cData + INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + INDEX2_MSGTYPE);
			*wp  = NOTIFY_MAGICSTUDYFAIL;

			cp = (char *)(cData + INDEX2_MSGTYPE + 2);
			*cp = 1;
			cp++;

			*cp = iRet;
			cp++;

			memcpy(cp, cMagicName, 30);
			cp += 30;

			ip = (int *)cp;
			*ip = iCost;
			cp += 4;

			ip = (int *)cp;
			*ip = iReqInt;
			cp += 4;


			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 46);
			switch (iRet) {
			case XSOCKEVENT_QUENEFULL:
			case XSOCKEVENT_SOCKETERROR:
			case XSOCKEVENT_CRITICALERROR:
			case XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
	}
}

int CGame::_iGetMagicNumber(char * pMagicName, int * pReqInt, int * pCost)
{
	register int i;
	char cTmpName[31];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMagicName);

	for (i = 0; i < MAXMAGICTYPE; i++) 
		if (m_pMagicConfigList[i] != NULL) {
			if (memcmp(cTmpName, m_pMagicConfigList[i]->m_cName, 30) == 0) {

				*pReqInt = (int)m_pMagicConfigList[i]->m_sIntLimit;
				*pCost   = (int)m_pMagicConfigList[i]->m_iGoldCost;

				return i;
			}
		}

	return -1;
}

void CGame::TrainSkillResponse(bool bSuccess, int iClientH, int iSkillNum, int iSkillLevel)
{
	char  * cp, cData[100];
	DWORD * dwp;
	WORD  * wp;
	int   iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((iSkillNum < 0)	|| (iSkillNum >= MAXSKILLTYPE)) return;
	if ((iSkillLevel < 0) || (iSkillLevel > 100)) return;

	if (bSuccess == TRUE) {
		if (m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] >= iSkillLevel) return;

		m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] = iSkillLevel;
		m_pClientList[iClientH]->CheckTotalSkillMasteryPoints(iSkillNum);

		dwp  = (DWORD *)(cData + INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + INDEX2_MSGTYPE);
		*wp  = NOTIFY_SKILLTRAINSUCCESS;

		cp = (char *)(cData + INDEX2_MSGTYPE + 2);

		*cp = iSkillNum;
		cp++;

		*cp = iSkillLevel;
		cp++;

#ifdef TAIWANLOG
		if (m_pSkillConfigList[iSkillNum]->m_cName != NULL) 
			_bItemLog(ITEMLOG_SKILLLEARN,iClientH,m_pSkillConfigList[iSkillNum]->m_cName,NULL) ;
#endif


		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 8);
		switch (iRet) {
		case XSOCKEVENT_QUENEFULL:
		case XSOCKEVENT_SOCKETERROR:
		case XSOCKEVENT_CRITICALERROR:
		case XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}
	else {


	}

	/*
	ZeroMemory(cData, sizeof(cData));

	ZeroMemory(cSkillName, sizeof(cSkillName));
	memcpy(cSkillName, pName, 20);

	iRet = _iGetSkillNumber(cSkillName);
	if (iRet == 0) {

	}
	else {

	if (1) {

	m_pClientList[iClientH]->m_cSkillMastery[iRet]++;

	dwp  = (DWORD *)(cData + INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (WORD *)(cData + INDEX2_MSGTYPE);
	*wp  = NOTIFY_SKILLTRAINSUCCESS;

	cp = (char *)(cData + INDEX2_MSGTYPE + 2);
	*cp = m_pClientList[iClientH]->m_cSkillMastery[iRet];
	cp++;

	*cp = iRet;
	cp++;

	memcpy(cp, cSkillName, 20);
	cp += 20;


	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 28);
	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
	DeleteClient(iClientH, TRUE, TRUE);
	return;
	}
	}
	else {

	dwp  = (DWORD *)(cData + INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (WORD *)(cData + INDEX2_MSGTYPE);
	*wp  = NOTIFY_SKILLTRAINFAIL;

	cp = (char *)(cData + INDEX2_MSGTYPE + 2);
	*cp = 1;
	cp++;

	*cp = iRet;
	cp++;

	memcpy(cp, cSkillName, 20);
	cp += 20;


	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 28);
	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
	DeleteClient(iClientH, TRUE, TRUE);
	return;
	}
	}
	}
	*/
}


int CGame::_iGetSkillNumber(char * pSkillName)
{
	register int i;
	char cTmpName[21];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pSkillName);

	for (i = 1; i < MAXSKILLTYPE; i++) 
		if (m_pSkillConfigList[i] != NULL) {
			if (memcmp(cTmpName, m_pSkillConfigList[i]->m_cName, 20) == 0) {

				return i;
			}
		}

	return 0;
}



bool CGame::_bReadMapInfoFiles(int iMapIndex)
{
	char * pContents, * token, cTxt[250], cFn[255];	 
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iTeleportLocIndex  = 0;
	int  iWayPointCfgIndex  = 0;
	int  iTotalNpcSetting   = 0;
	int  iMGARCfgIndex      = 0;
	int  iSMGRCfgIndex      = 0;
	int  iNMRCfgIndex       = 0;
	int  iFishPointIndex 	 = 0;
	int  iMineralPointIndex = 0;
	int  iStrategicPointIndex = 0;
	int  iIndex = 0;
	int  iNumMob = 0;

	int  iNamingValue;
	HANDLE hFile;
	DWORD  dwFileSize, dwReadSize;
	FILE * pFile;

	char cName[6], cNpcName[21], cNpcMoveType, cNpcWaypointIndex[10], cNamePrefix;
	short sIPindex;
	SYSTEMTIME SysTime;


	if (memcmp(m_pMapList[iMapIndex]->m_cName, "fight", 5) == 0) 
		m_pMapList[iMapIndex]->m_bIsFightZone = TRUE;

	if (memcmp(m_pMapList[iMapIndex]->m_cName, "icebound", 8) == 0) 
		m_pMapList[iMapIndex]->m_bIsFixedSnowMode = TRUE;

	GetLocalTime(&SysTime);
	if( SysTime.wYear == 2002 && SysTime.wMonth == 12 && SysTime.wDay == 25 ) {
		m_pMapList[iMapIndex]->m_bIsFixedSnowMode = TRUE;
	}

	ZeroMemory(cFn, sizeof(cFn));
	strcat(cFn, "mapdata\\");
	strcat(cFn, m_pMapList[iMapIndex]->m_cName);
	strcat(cFn, ".txt");

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) return FALSE;
	dwFileSize = GetFileSize(hFile, NULL);
	CloseHandle(hFile);


	pContents = new char[dwFileSize+1];
	ZeroMemory(pContents, dwFileSize+1);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		wsprintf(cTxt, "(ERROR) Cannot open file : %s", cFn);
		PutLogList(cTxt);
		return FALSE;
	}
	else {
		//wsprintf(cTxt, "(*) Reading Map info file : %s", cFn);
		//PutLogList(cTxt);
		dwReadSize = fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) 
			{
			case 1:
				switch (cReadModeB) 
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 1 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}

					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcX = atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 2 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}

					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcY = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					ZeroMemory(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, 
						sizeof(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName));
					strcpy(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 3 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}

					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestX = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 4 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}

					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestY = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 5 - Wrong Data format.");
						delete[] pContents;

						return FALSE;
					}

					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDir = atoi(token);
					iTeleportLocIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 2:
				switch (cReadModeB) 
				{
				case 1:

					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 6 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					iWayPointCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x != -1) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 7 - Duplicated waypoint");
						delete[] pContents;
						return FALSE;
					}
					cReadModeB = 2;
					break;

				case 2:

					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 8 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:

					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 9 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 3:

				switch (cReadModeB) 
				{
				case 1:

					ZeroMemory(cNpcName, sizeof(cNpcName));
					strcpy(cNpcName, token);
					cReadModeB = 2;
					break;
				case 2:
					// NpcMoveType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 10 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					cNpcMoveType = atoi(token);
					cReadModeB = 3;
					break;
				default:
					// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 11 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					cNpcWaypointIndex[cReadModeB-3] = atoi(token);
					cReadModeB++;
					break;
				case 13:
					// cNamePrefix
					cNamePrefix = token[0];

					iNamingValue = m_pMapList[iMapIndex]->iGetEmptyNamingValue();
					if (iNamingValue == -1) {

					}
					else {

						ZeroMemory(cName, sizeof(cName));
						wsprintf(cName, "XX%d", iNamingValue);
						cName[0] = cNamePrefix;
						cName[1] = iMapIndex+65;

						if (bCreateNewNpc(cNpcName, cName, m_pMapList[iMapIndex]->m_cName, 0, cNpcMoveType, NULL, NULL, cNpcWaypointIndex, NULL, NULL, -1, FALSE) == FALSE) {
							m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
						} 
					}
					cReadModeA = 0;
					cReadModeB = 0;
					iTotalNpcSetting++;
					break;
				}
				break;

			case 4:
				switch (cReadModeB) 
				{
				case 1:

					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 12 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_bRandomMobGenerator = atoi(token) ? TRUE : FALSE;
					cReadModeB = 2;
					break;

				case 2:
					// Mob- Level
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 13 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 5:
				// Maximum object
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 14 - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				m_pMapList[iMapIndex]->m_iMaximumObject = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 6:

				switch (cReadModeB) 
				{
				case 1:

					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 15 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return FALSE;
					}
					iMGARCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left != -1) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 16 - Duplicated Mob Gen Rect Number!");
						delete[] pContents;
						return FALSE;
					}

					cReadModeB = 2;
					break;

				case 2:
					// left
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 17 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// top
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 18 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].top = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// right
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 19 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].right = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// bottom
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 20 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 7:

				switch (cReadModeB) 
				{
				case 1:

					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 21 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return FALSE;
					}
					iSMGRCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined == TRUE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error - ");
						delete[] pContents;
						return FALSE;
					}
					cReadModeB = 2;
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined = TRUE;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 22 - Wrong Data format(SMGAR num).");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType = atoi(token);

					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 1)
						cReadModeB = 3;
					else if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 2)
						cReadModeB = 9;  
					break;

				case 3:
					// left
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 23 - Wrong Data format(SMGAR num).");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.left = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// top
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 24 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.top = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// right
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 25 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.right = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// bottom
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 26 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.bottom = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// spot mob type
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 27 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// Max Mobs
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 28 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs	= 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				default:
					// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 29 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cWaypoint[cReadModeB - 9] = atoi(token);
					cReadModeB++;
					break;

				case 19:
					// spot mob type
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 30 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 31 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs	= 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 8:
				ZeroMemory(m_pMapList[iMapIndex]->m_cLocationName, sizeof(m_pMapList[iMapIndex]->m_cLocationName));
				memcpy(m_pMapList[iMapIndex]->m_cLocationName, token, 10);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 9:
				switch (cReadModeB) 
				{
				case 1:
					// Initial-Point Index
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32:1 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					sIPindex = atoi(token);
					if (m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x != -1) {
						PutLogList("(!!!) CRITICAL ERROR! Duplicate Initial Point Index!");
						delete[] pContents;
						return FALSE;
					}
					cReadModeB = 2;
					break;

				case 2:
					// Initial-Point X
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// Initial-Point Y
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 33 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 10:

				switch (cReadModeB) 
				{
				case 1:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 34 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					iNMRCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top != -1) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 35 - Duplicate No-Magic-Rect number");
						delete[] pContents;
						return FALSE;
					}
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 36 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].left = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 37 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 38 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].right = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 39 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 11:
				m_pMapList[iMapIndex]->m_bIsFixedDayMode = atoi(token) ? TRUE : FALSE;


				if (m_pMapList[iMapIndex]->m_bIsFixedDayMode == TRUE)
					m_pMapList[iMapIndex]->m_bIsFixedSnowMode = FALSE;
				cReadModeA = 0;
				break;

			case 12:
				switch (cReadModeB) 
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 40 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					iFishPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x != -1) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 41 - Duplicate FishPoint number");
						delete[] pContents;
						return FALSE;
					}

					m_pMapList[iMapIndex]->m_iTotalFishPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 42 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 43 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 13:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 44 - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iMaxFish = atoi(token);

				cReadModeA = 0;
				break;

			case 14:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 45 - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_cType = atoi(token);

				cReadModeA = 0;
				break;

			case 15:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 46 - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 16:
				switch (cReadModeB)
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 47 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_bMineralGenerator = atoi(token) ? TRUE : FALSE;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 48 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_cMineralGeneratorLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 17:
				switch (cReadModeB) 
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 49 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					iMineralPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x != -1) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 50 - Duplicate MineralPoint number");
						delete[] pContents;
						return FALSE;
					}

					m_pMapList[iMapIndex]->m_iTotalMineralPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 51 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 52 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 18:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 53 - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iMaxMineral = atoi(token);

				cReadModeA = 0;
				break;

			case 19:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 54 - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iUpperLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 20:
				switch (cReadModeB) 
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 55 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					iStrategicPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] != NULL) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 56 - Duplicate Strategic Point number");
						delete[] pContents;
						return FALSE;
					}

					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] = new class CStrategicPoint;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 57 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iSide = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 58 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iValue = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 59 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iX = atoi(token);

					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 60 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 21:
				switch (cReadModeB) 
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 61 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					iIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType != NULL) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 62 - Duplicate EnergySphereCreation number");
						delete[] pContents;
						return FALSE;
					}

					m_pMapList[iMapIndex]->m_iTotalEnergySphereCreationPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 63 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 64 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sX = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 65 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 22:
				switch (cReadModeB) 
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 66 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					iIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult != NULL) {
						wsprintf(g_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 67 - Duplicate EnergySphereGoal number(%d:%d)", iIndex, m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult);
						PutLogList(g_cTxt);
						delete[] pContents;
						return FALSE;
					}

					m_pMapList[iMapIndex]->m_iTotalEnergySphereGoalPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 68 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 69 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenX = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 70 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenY = atoi(token);

					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 71 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineX = atoi(token);

					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 72 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 23:
				switch (cReadModeB) 
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 73 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					iIndex = atoi(token);

					if (strlen(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName) != NULL) {
						wsprintf(g_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 74 - Duplicate Strike Point number(%d)", iIndex);
						PutLogList(g_cTxt);
						delete[] pContents;
						return FALSE;
					}

					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 75 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dX = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 76 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dY = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iHP = atoi(token);
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iInitHP = atoi(token);
					cReadModeB = 5;
					break;


				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[0] = atoi(token);

					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[0] = atoi(token);

					cReadModeB = 7;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[1] = atoi(token);

					cReadModeB = 8;
					break;

				case 8:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[1] = atoi(token);

					cReadModeB = 9;
					break;

				case 9:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[2] = atoi(token);

					cReadModeB = 10;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[2] = atoi(token);

					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[3] = atoi(token);

					cReadModeB = 12;
					break;

				case 12:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[3] = atoi(token);

					cReadModeB = 13;
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[4] = atoi(token);

					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[4] = atoi(token);

					cReadModeB = 15;
					break;

				case 15:
					ZeroMemory(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, sizeof(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName));
					strcpy(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, token);

					m_pMapList[iMapIndex]->m_iTotalStrikePoints++;

					cReadModeA = 0;
					cReadModeB = 0;
					break;

				}
				break;

			case 24: // item event
				/*
				; mapdata  
				;item-event = index	item_name	amount	TotalNumber	month	day	type	mob_list[Max:5]
				;	type = 0 :       .
				;	       1 : Item Event       .

				item-event = 	1		1	10		11	1	0	Cannibal-Plant Ettin EOL
				item-event = 	2		1	10		11	1	0	Giant-Frog Scorpion EOL
				*/
				switch (cReadModeB) 
				{
				case 1: //  index
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					iIndex = atoi(token);

					if (strlen(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName) != NULL) {
						wsprintf(g_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 79 - Duplicate Item-Event number(%d:%s)", iIndex, m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName);
						PutLogList(g_cTxt);
						delete[] pContents;
						return FALSE;
					}

					m_pMapList[iMapIndex]->m_iTotalItemEvents++;
					cReadModeB = 2;
					break;

				case 2: // item_name
					strcpy(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName, token);
					cReadModeB = 3;
					break;

				case 3: // amount
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 81 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iAmount = atoi(token);

					cReadModeB = 4;
					break;

				case 4: // total number
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 82 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iTotalNum = atoi(token);

					cReadModeB = 5;
					break;

				case 5: // month
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iMonth = atoi(token);

					cReadModeB = 6;
					break;

				case 6: // day
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iDay = atoi(token);

					cReadModeB = 7;
					break;

				case 7: // type
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iType = atoi(token);

					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iNumMob = 0;

					cReadModeB = 8;
					break;

				case 8: // monster list
					if( strcmp(token, "EOL") == 0 ) {
						cReadModeA = 0;
						cReadModeB = 0;
					} else {
						iNumMob = m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iNumMob;

						if( iNumMob >= 5 ) {
							cReadModeA = 0;
							cReadModeB = 0;
							PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
							break;
						}

						m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNumMob] = new char[21];

						ZeroMemory(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNumMob],
							sizeof(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNumMob]) );

						strcpy(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNumMob], token);

						m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iNumMob ++;

						cReadModeB = 8;
					}
					break;
				}
				break;
			case 25:
				switch (cReadModeB) 
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->sMobEventAmount = atoi(token);
					cReadModeB = 0;
					break;
				}
				break;

case 26: 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMobGenType - Wrong Data format.");
				delete[] pContents;
						return FALSE;
				}
				m_pMapList[iMapIndex]->m_iApocalypseMobGenType = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 27: 
				switch (cReadModeB) {
				case 1: 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_iApocalypseBossMobNpcID = atoi(token);
					cReadModeB = 2;					
					break;
				case 2: 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.left = atoi(token);
					cReadModeB = 3;					
					break;
				case 3: 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.top = atoi(token);
					cReadModeB = 4;					
					break;
				case 4: 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.right = atoi(token);
					cReadModeB = 5;					
					break;
				case 5: 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;					
					break;
				}
				break;

			case 28: 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateType - Wrong Data format.");
					delete[] pContents;
					return FALSE;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_cDynamicGateType = atoi(token);
				// DynamicGateType = 1: Opens Gate when Apoc begins
				// DynamicGateType = 2: Open the gate when map is empty
				// DynamicGateType = 3: Gate stays closed will change to 4 value to open it, along with a boss spawn.
				// DynamicGateType = 4: Gate is openned. (set by server when Abaddon is spawning)
				// DynamicGateType = 5: Gate is used by GM command
				cReadModeA = 0;
				cReadModeB = 0;
				break;
								
			case 29: 
				switch (cReadModeB) {
				case 1: 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 = atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 = atoi(token);
					cReadModeB = 3;
					break;

				case 3: 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2 = atoi(token);
					cReadModeB = 4;
					break;

				case 4: 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2 = atoi(token);
					cReadModeB = 5;
					break;

				case 5: 
					ZeroMemory(m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap, sizeof(m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap));
					memcpy(m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap, token, strlen(token));
					cReadModeB = 6;
					break;

				case 6: 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtX = atoi(token);
					cReadModeB = 7;
					break;

				case 7: 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtY = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
			
			case 30: 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMap -  Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_bIsApocalypseMap = (BOOL) atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
			case 31: 
				if (_bGetIsStringIsNumber(token) == FALSE) 
				{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error CitizenLimit -  Wrong Data format.");
				delete[] pContents;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_bIsHeldenianMap = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 32: 
				switch (cReadModeB) {
				case 1: // NpcID
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian tower type id - Wrong Data format.");
						delete[] pContents;
					return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].sTypeID = atoi(token);
					cReadModeB = 2;
					break;
				case 2: // side 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Side - Wrong Data format.");
						delete[] pContents;
					return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].cSide = atoi(token);
					cReadModeB = 3;
					break;
				case 3: // sX
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower X pos - Wrong Data format.");
						delete[] pContents;
					return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].dX = atoi(token);
					cReadModeB = 4;
					break;
				case 4: // sY
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Y pos - Wrong Data format.");
						delete[] pContents;
					return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].dY = atoi(token);
					iIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 33: 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_cHeldenianModeMap = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 34: 
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
						delete[] pContents;
					return FALSE;
					}
					m_pMapList[iMapIndex]->m_sHeldenianWinningZoneX = atoi(token);
					cReadModeB = 2;
					break;
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
						delete[] pContents;
					return FALSE;
					}
					m_pMapList[iMapIndex]->m_sHeldenianWinningZoneY = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 35: 
				switch (cReadModeB) {
				case 1: 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Direction - Wrong Data format.");
						delete[] pContents;
					return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].cDir = atoi(token);
					cReadModeB = 2;
					break;
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door X pos - Wrong Data format.");
						delete[] pContents;
					return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].dX = atoi(token);
					cReadModeB = 3;
					break;
				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Y pos - Wrong Data format.");
					delete[] pContents;
					return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].dY = atoi(token);
					iIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
						break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "teleport-loc", 12) == 0) {
				m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex] = new class CTeleportLoc;
				cReadModeA = 1;
				cReadModeB = 1;
			}

			if (memcmp(token, "waypoint", 8) == 0) {
				cReadModeA = 2;
				cReadModeB = 1;
			}

			if (memcmp(token, "npc", 3) == 0) {
				cReadModeA = 3;
				cReadModeB = 1;
			}

			if (memcmp(token, "random-mob-generator", 20) == 0) {
				cReadModeA = 4;
				cReadModeB = 1;
			}

			if (memcmp(token, "maximum-object", 14) == 0) 
				cReadModeA = 5;

			if (memcmp(token, "npc-avoidrect", 13) == 0) {
				cReadModeA = 6;
				cReadModeB = 1;
			}

			if (memcmp(token, "spot-mob-generator", 18) == 0) {
				cReadModeA = 7;
				cReadModeB = 1;
			}

			if (memcmp(token, "map-location", 12) == 0)
				cReadModeA = 8;

			if (memcmp(token, "initial-point", 13) == 0) {
				cReadModeA = 9;
				cReadModeB = 1;
			}

			if (memcmp(token, "no-attack-area", 14) == 0) {
				cReadModeA = 10;
				cReadModeB = 1;
			}

			if (memcmp(token, "fixed-dayornight-mode", 21) == 0) cReadModeA = 11;

			if (memcmp(token, "fish-point", 10) == 0) {
				cReadModeA = 12;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-fish", 8) == 0)		cReadModeA = 13;
			if (memcmp(token, "type", 4) == 0)			cReadModeA = 14;
			if (memcmp(token, "level-limit", 11) == 0)	cReadModeA = 15;

			if (memcmp(token, "mineral-generator", 17) == 0) {
				cReadModeA = 16;
				cReadModeB = 1;
			}

			if (memcmp(token, "mineral-point", 13) == 0) {
				cReadModeA = 17;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-mineral", 11) == 0)			cReadModeA = 18;
			if (memcmp(token, "upper-level-limit", 17) == 0)	cReadModeA = 19;
			if (memcmp(token, "strategic-point", 15) == 0) {
				cReadModeA = 20;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-creation-point", 28) == 0) {
				cReadModeA = 21;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-goal-point", 24) == 0) {
				cReadModeA = 22;
				cReadModeB = 1;
			}

			if (memcmp(token, "strike-point", 12) == 0) {
				cReadModeA = 23;
				cReadModeB = 1;
			}

			if (memcmp(token, "item-event", 10) == 0) {
				cReadModeA = 24;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-auto-creation", 27) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;

				m_pMapList[iMapIndex]->m_bIsEnergySphereAutoCreation = TRUE;
			}

			if (memcmp(token, "mobevent-amount", 15) == 0) {
				cReadModeA = 25;
				cReadModeB = 1;
			}

			if (memcmp(token, "ApocalypseMobGenType", 20) == 0) 
			{	cReadModeA = 26;
				cReadModeB = 1;
			}
			if (memcmp(token, "ApocalypseBossMob", 17) == 0) 
			{	cReadModeA = 27;
				cReadModeB = 1;
			}
			if (memcmp(token, "DynamicGateType", 15) == 0) 
			{	cReadModeA = 28;
				cReadModeB = 1;
			}
			if (memcmp(token, "DynamicGateCoord", 16) == 0) 
			{	cReadModeA = 29;
				cReadModeB = 1;
			}
						
			if (memcmp(token, "ApocalypseMap", 13) == 0) 
			{	cReadModeA = 30;
				cReadModeB = 1;
			}	
			
			if (memcmp(token, "HeldenianMap", 12) == 0) {
				cReadModeA = 31;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianTower", 14) == 0) {
				cReadModeA = 32;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianModeMap", 16) == 0) {
				cReadModeA = 33;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianWinningZone", 20) == 0) {
				cReadModeA = 34;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianGateDoor", 17) == 0) {
				cReadModeA = 35;
				cReadModeB = 1;
			}
			if (memcmp(token, "[END-MAP-INFO]", 14) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto RMI_SKIPDECODING;
			}
		}
		token = pStrTok->pGet();
	}

RMI_SKIPDECODING:;

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(ERROR) CRITICAL ERROR! map info file contents error!");
		return FALSE;
	}

	//wsprintf(cTxt, "(!) Map info file decoding(%s) - success! TL(%d) WP(%d) LNPC(%d) MXO(%d) RMG(%d / %d)", cFn, iTeleportLocIndex, iWayPointCfgIndex, iTotalNpcSetting, m_pMapList[iMapIndex]->m_iMaximumObject, m_pMapList[iMapIndex]->m_bRandomMobGenerator, m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel);
	//PutLogList(cTxt);

	m_pMapList[iMapIndex]->_SetupNoAttackArea();

	return TRUE;

}

void CGame::Quit()
{
	int i;


	Sleep(300);

	m_astoria.reset(NULL);

	for (i = 0; i < MAXSUBLOGSOCK; i++)
		if (m_pSubLogSock[i] != NULL) delete m_pSubLogSock[i];

	for (i = 0; i < MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) delete m_pClientList[i];

	for (i = 0; i < MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) delete m_pNpcList[i];

	for (i = 0; i < MAXMAPS; i++)
		if (m_pMapList[i] != NULL) delete m_pMapList[i];

	for (i = 0; i < MAXITEMTYPES; i++)
		if (m_pItemConfigList[i] != NULL) delete m_pItemConfigList[i];

	for (i = 0; i < MAXNPCTYPES; i++)
		if (m_npcConfigList[i] != NULL) delete m_npcConfigList[i];

	for (i = 0; i < MAXMAGICTYPE; i++)
		if (m_pMagicConfigList[i] != NULL) delete m_pMagicConfigList[i];

	for (i = 0; i < MAXSKILLTYPE; i++)
		if (m_pSkillConfigList[i] != NULL) delete m_pSkillConfigList[i];

	for (i = 0; i < MAXQUESTTYPE; i++)
		if (m_pQuestConfigList[i] != NULL) delete m_pQuestConfigList[i];

	for (i = 0; i < MAXDYNAMICOBJECTS; i++)
		if (m_pDynamicObjectList[i] != NULL) delete m_pDynamicObjectList[i];

	for (i = 0; i < MAXDELAYEVENTS; i++)
		if (m_pDelayEventList[i] != NULL) delete m_pDelayEventList[i];

	for (i = 0; i < MAXNOTIFYMSGS; i++)
		if (m_pNoticeMsgList[i] != NULL) delete m_pNoticeMsgList[i];

	for (i = 0; i < MAXFISHS; i++)
//		if (m_pFish[i] != NULL) delete m_pFish[i];

	for (i = 0; i < MAXMINERALS; i++)
		if (m_pMineral[i] != NULL) delete m_pMineral[i];

	for (i = 0; i < MAXPOTIONTYPES; i++)
		if (m_pPotionConfigList[i] != NULL) delete m_pPotionConfigList[i];

	for (i = 0; i < MAXCRAFTING; i++)
		if (m_pCraftingConfigList[i] != NULL) delete m_pCraftingConfigList[i];

	for (i = 0; i < MAXBUILDITEMS; i++) 
		if (m_pBuildItemList[i] != NULL) delete m_pBuildItemList[i];

	for (i = 0; i < MAXDUPITEMID; i++)
		if (m_pDupItemIDList[i] != NULL) delete m_pDupItemIDList[i];

	if (m_pNoticementData != NULL) delete m_pNoticementData;

	if (m_pGold != NULL) delete m_pGold;

}

 int CGame::iGetLevelExp(int iLevel)
{
     __int64 iRet;

	if (iLevel == 0) return 0;
	//iRet = iGetLevelExp
		
iRet = (iLevel * iLevel) + iLevel * ( 50 + (iLevel * (iLevel / 17) * (iLevel / 17) ) );

	return iRet;
}

int CGame::_iCalcSkillSSNpoint(int iLevel)
{
	int iRet;

	if (iLevel < 1) return 1;

	if (iLevel <= 50) 
	iRet = iLevel;
	else if (iLevel > 50) {
		//iRet = ( iLevel * iLevel / 5 ); // / 10;
iRet = ( iLevel * iLevel / 7);
	}

	return iRet;
}

bool CGame::bCheckLevelUp(int iClientH)
{
	char cLoopCnt;
	class CItem * pItem;
	int iMaxSuperAttack;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	if (m_pClientList[iClientH]->m_iLevel >= m_sMaxPlayerLevel) {
		while(m_pClientList[iClientH]->m_iExp >= m_iLevelExpTable[m_sMaxPlayerLevel + 1])
		{
				m_pClientList[iClientH]->m_iExp -= (m_iLevelExpTable[m_sMaxPlayerLevel+1] - m_iLevelExpTable[m_sMaxPlayerLevel]);
				SendNotifyMsg(NULL, iClientH, NOTIFY_EXP, NULL, NULL, NULL, NULL);
				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft++;
				SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 1, NULL, NULL);
		}
		return FALSE;
	}

	if (m_pClientList[iClientH]->m_iExp < m_pClientList[iClientH]->m_iNextLevelExp) return FALSE;

	cLoopCnt = 0;
	while (1) {
		if (cLoopCnt++ > 100) return FALSE; 		
		if (m_pClientList[iClientH]->m_iExp >= m_pClientList[iClientH]->m_iNextLevelExp) {
			if (m_pClientList[iClientH]->m_iLevel >= m_sMaxPlayerLevel) {
				while(m_pClientList[iClientH]->m_iExp >= m_iLevelExpTable[m_sMaxPlayerLevel + 1])
				{
					m_pClientList[iClientH]->m_iExp -= (m_iLevelExpTable[m_sMaxPlayerLevel+1] - m_iLevelExpTable[m_sMaxPlayerLevel]);
					SendNotifyMsg(NULL, iClientH, NOTIFY_EXP, NULL, NULL, NULL, NULL);
					m_pClientList[iClientH]->m_iGizonItemUpgradeLeft++;
					SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 1, NULL, NULL);
				}
				return FALSE;
			}
			m_pClientList[iClientH]->m_iLevel++;
			m_pClientList[iClientH]->m_iLU_Pool += 3;

			if (m_pClientList[iClientH]->m_iLevel >= 1 && m_pClientList[iClientH]->m_iLevel <= 50) {
				pItem = new class CItem;
				_bInitItemAttr(pItem, "Gold");
				pItem->m_dwCount = (DWORD)500;
				bAddItem(iClientH, pItem);
			}

			if (m_pClientList[iClientH]->GetBaseStr() > m_sCharStatLimit)      
				m_pClientList[iClientH]->SetStr(m_sCharStatLimit);
			if (m_pClientList[iClientH]->GetBaseDex() > m_sCharStatLimit) 
				m_pClientList[iClientH]->SetDex(m_sCharStatLimit);
			if (m_pClientList[iClientH]->m_iVit > m_sCharStatLimit)
				m_pClientList[iClientH]->m_iVit = m_sCharStatLimit;
			if (m_pClientList[iClientH]->GetBaseInt() > m_sCharStatLimit)
				m_pClientList[iClientH]->SetInt(m_sCharStatLimit);
			if (m_pClientList[iClientH]->GetBaseMag() > m_sCharStatLimit)
				m_pClientList[iClientH]->SetMag(m_sCharStatLimit);
			if (m_pClientList[iClientH]->m_iRange > m_sCharStatLimit) m_pClientList[iClientH]->m_iRange = m_sCharStatLimit;

			SendNotifyMsg(NULL, iClientH, NOTIFY_LEVELUP, NULL, NULL, NULL, NULL);
			
			m_pClientList[iClientH]->m_iHP = m_pClientList[iClientH]->GetMaxHP();
	m_pClientList[iClientH]->m_iMP = m_pClientList[iClientH]->GetMaxMP();
	m_pClientList[iClientH]->m_iSP = m_pClientList[iClientH]->GetMaxSP();
	iMaxSuperAttack = (m_pClientList[iClientH]->m_iLevel / 10);
	m_pClientList[iClientH]->m_iSuperAttackLeft = iMaxSuperAttack;

			m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1]; //iGetLevelExp(m_pClientList[iClientH]->m_iLevel + 1);


			CalcTotalItemEffect(iClientH, -1, FALSE);

			if (m_pClientList[iClientH]->m_iLevel > m_iPlayerMaxLevel) {
				wsprintf(g_cTxt, "(!) Player(%s) above max level!", m_pClientList[iClientH]->m_cCharName);
				PutLogFileList(g_cTxt);
			}
		}
		else return TRUE;
	}

	return FALSE;
}



void CGame::LevelUpSettingsHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
	char * cp, cStr, cVit, cDex, cInt, cMag, cChr;
	int iTotalSetting = 0;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iLU_Pool <= 0) 
	{

		SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return ;
	}
	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	cStr = *cp;
	cp++;

	cVit = *cp;
	cp++;

	cDex = *cp;
	cp++;

	cInt = *cp;
	cp++;

	cMag = *cp;
	cp++;

	cChr = *cp;
	cp++;

	//	if(m_pClientList[iClientH]->m_iLU_Pool < 3) {
	//		m_pClientList[iClientH]->m_iLU_Pool = 3;
	//	}


	if ( (cStr + cVit + cDex + cInt + cMag + cChr) > m_pClientList[iClientH]->m_iLU_Pool) { // -3
		SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->GetBaseStr() + cStr > 
		m_sCharStatLimit) || (cStr < 0)) 
		return;

	if ((m_pClientList[iClientH]->GetBaseDex() + cDex > 
		m_sCharStatLimit) || (cDex < 0)) 
		return;

	if ((m_pClientList[iClientH]->GetBaseInt() + cInt > 
		m_sCharStatLimit) || (cInt < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iVit + cVit > m_sCharStatLimit) || (cVit < 0)) 
		return;

	if ((m_pClientList[iClientH]->GetBaseMag() + cMag > 
		m_sCharStatLimit) || (cMag < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iRange + cChr > m_sCharStatLimit) || (cChr < 0)) 
		return;

	iTotalSetting = m_pClientList[iClientH]->GetBaseStr() + m_pClientList[iClientH]->GetBaseDex() + m_pClientList[iClientH]->m_iVit + 
		m_pClientList[iClientH]->GetBaseInt() + m_pClientList[iClientH]->GetBaseMag() + m_pClientList[iClientH]->m_iRange;

	if (iTotalSetting + m_pClientList[iClientH]->m_iLU_Pool -3 > ((m_pClientList[iClientH]->m_iLevel-1)*3 + 70))
	{
		int bobdole;
		bobdole = 3;
		m_pClientList[iClientH]->m_iLU_Pool = 3 + (m_pClientList[iClientH]->m_iLevel-1)*3 + 70 - iTotalSetting;

		if(m_pClientList[iClientH]->m_iLU_Pool < 3)
			m_pClientList[iClientH]->m_iLU_Pool = 3;
		SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return ;
	}


	if (iTotalSetting + (cStr + cVit + cDex + cInt + cMag + cChr)
		>	((m_pClientList[iClientH]->m_iLevel-1)*3 + 70)) 
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	m_pClientList[iClientH]->m_iLU_Pool = m_pClientList[iClientH]->m_iLU_Pool - (cStr + cVit + cDex + cInt + cMag + cChr);

	m_pClientList[iClientH]->SetStr(m_pClientList[iClientH]->GetBaseStr() + cStr);
	m_pClientList[iClientH]->m_iVit  += cVit;
	m_pClientList[iClientH]->SetDex(m_pClientList[iClientH]->GetBaseDex() + cDex);
	m_pClientList[iClientH]->SetInt(m_pClientList[iClientH]->GetBaseInt() + cInt);
	m_pClientList[iClientH]->SetMag(m_pClientList[iClientH]->GetBaseMag() + cMag);
	m_pClientList[iClientH]->m_iRange  += cChr;

	SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);

}


void CGame::FightzoneReserveHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
	char cData[100];
	int iFightzoneNum ,* ip ,  iEnableReserveTime ;
	DWORD * dwp, dwGoldCount ;
	WORD  * wp, wResult;
	int     iRet, iResult=1, iCannotReserveDay;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	GetLocalTime(&SysTime);

	iEnableReserveTime  = 2*20*60 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 5*20;

	dwGoldCount = dwGetItemCount(iClientH, "Gold");

	ip = (int *)(pData + INDEX2_MSGTYPE + 2);
	iFightzoneNum = *ip;

	if ((iFightzoneNum < 1) || (iFightzoneNum > MAXFIGHTZONE)) return;


	//if ((iFightzoneNum >= 1) && (iFightzoneNum <= 4)) return;

	iCannotReserveDay = (SysTime.wDay + m_pClientList[iClientH]->m_side + iFightzoneNum ) % 2 ;
	if (iEnableReserveTime <= 0 ){
		wResult = MSGTYPE_REJECT;
		iResult = 0 ;
	} else if (m_iFightZoneReserve[iFightzoneNum-1] != 0){
		wResult = MSGTYPE_REJECT;
		iResult = -1 ;
	} else if ( dwGoldCount < 1500 ) {
		wResult = MSGTYPE_REJECT;
		iResult = -2 ;
	} else if( iCannotReserveDay ) {
			wResult = MSGTYPE_REJECT;
			iResult = -3 ;
		} else if( m_pClientList[iClientH]-> m_iFightzoneNumber != 0 ) {
			wResult = MSGTYPE_REJECT;
			iResult = -4 ;
		} else {

			wResult = MSGTYPE_CONFIRM;

			SetItemCount(iClientH, "Gold", dwGoldCount - 1500);
			iCalcTotalWeight(iClientH);

			m_iFightZoneReserve[iFightzoneNum-1] = iClientH;

			m_pClientList[iClientH]->m_iFightzoneNumber  = iFightzoneNum ;
			m_pClientList[iClientH]->m_iReserveTime	 =  SysTime.wMonth*10000 + SysTime.wDay*100 + SysTime.wHour ;  

#ifdef TAIWANLOG
			_bItemLog(ITEMLOG_RESERVEFIGZONE,iClientH,(char *)NULL,NULL) ;
#endif

			if (SysTime.wHour%2 )	m_pClientList[iClientH]->m_iReserveTime  += 1  ;			
			else					m_pClientList[iClientH]->m_iReserveTime  += 2  ;    
			wsprintf(g_cTxt, "(*) Reserve FIGHTZONETICKET : Char(%s) TICKENUMBER (%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iReserveTime);
			PutLogFileList(g_cTxt);
			PutLogList(g_cTxt);

			m_pClientList[iClientH]->m_iFightZoneTicketNumber  = 50 ;  
			iResult = 1 ;
		}  

		ZeroMemory(cData, sizeof(cData));

		dwp = (DWORD *)(cData + INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_FIGHTZONE_RESERVE;

		wp = (WORD *)(cData + INDEX2_MSGTYPE);
		*wp =  wResult ;

		ip  = (int *)(cData + INDEX2_MSGTYPE+2) ; 
		*ip =  iResult ;
		ip+= 4;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10);

		switch (iRet) {
		case XSOCKEVENT_QUENEFULL:
		case XSOCKEVENT_SOCKETERROR:
		case XSOCKEVENT_CRITICALERROR:
		case XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
}


bool CGame::bCheckLimitedUser(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return FALSE;

	if (m_pClientList[iClientH]->IsNeutral() && 
		(m_pClientList[iClientH]->m_iExp >= m_iLevelExp51) &&
		!m_pClientList[iClientH]->IsGM()) {

			m_pClientList[iClientH]->m_iExp = m_iLevelExp51 - 1;
			SendNotifyMsg(NULL, iClientH, NOTIFY_TRAVELERLIMITEDLEVEL, NULL, NULL, NULL, NULL);
			return TRUE;
	}

	return FALSE;
}

void CGame::RequestCivilRightHandler(int iClientH, char *pData)
{
	char * cp, cData[100];
	DWORD * dwp;
	WORD * wp, wResult;
	int  iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if (!m_pClientList[iClientH]->IsNeutral() ) wResult = 0;
	else wResult = 1;

	if (m_pClientList[iClientH]->m_iLevel < 5) wResult = 0;

	if (wResult == 1) {
		ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
		strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);

#ifdef TAIWANLOG
		_bItemLog(ITEMLOG_APPLY, iClientH, (char) 0 , NULL) ;
#endif
	}

	iSetSide(iClientH);
	dwp  = (DWORD *)(cData + INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_CIVILRIGHT;
	wp   = (WORD *)(cData + INDEX2_MSGTYPE);
	*wp  = wResult;


	cp = (char *)(cData + INDEX2_MSGTYPE + 2);
	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
	cp += 10;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 16);
	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}

	SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTNULLACTION, NULL, NULL, NULL);

	if (m_pClientList[iClientH]->m_iPartyID != NULL) RequestDeletePartyHandler(iClientH);
}


void CGame::RequestRetrieveItemHandler(int iClientH, char *pData)
{
	char * cp, cBankItemIndex, cMsg[100];
	register int i, j, iRet, iItemWeight;
	DWORD * dwp;
	WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	cBankItemIndex = *cp;


	if (m_pClientList[iClientH]->m_bIsOnWarehouse == FALSE) return ;


	if ((cBankItemIndex < 0) || (cBankItemIndex >= MAXBANKITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] == NULL) {
		ZeroMemory(cMsg, sizeof(cMsg));

		dwp  = (DWORD *)(cMsg + INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_RETRIEVEITEM;
		wp   = (WORD *)(cMsg + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_REJECT;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
	}
	else {

		/*
		if ( (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == ITEMTYPE_CONSUME) ||
		(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == ITEMTYPE_ARROW) ) {
		//iItemWeight = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight * m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount;
		iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
		}
		else iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], 1); //m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight;
		*/

		iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);

		if ( (iItemWeight + m_pClientList[iClientH]->m_iCurWeightLoad) > _iCalcMaxLoad(iClientH)) {
			SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
			return;
		}

		//!!!
		if ( (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == ITEMTYPE_CONSUME) || 
			(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == ITEMTYPE_ARROW) ) {

				for (i = 0; i < MAXITEMS; i++)
					if ( (m_pClientList[iClientH]->m_pItemList[i] != NULL) && 
						(m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType) && 
						(memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cName, 20) == 0) ) {


							SetItemCount(iClientH, i, m_pClientList[iClientH]->m_pItemList[i]->m_dwCount + m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);

							delete m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
							m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = NULL;


							if (m_pClientList[iClientH]->m_pItemList[i] != NULL)
							{
								if (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum == ITEM_ZEM )
									_bItemLog(ITEMLOG_RETRIEVE, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[i], TRUE);
								else 
									_bItemLog(ITEMLOG_RETRIEVE, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[i]) ;
							}



							for ( j = 0; j <= MAXBANKITEMS - 2; j++) {
								if ((m_pClientList[iClientH]->m_pItemInBankList[j+1] != NULL) && (m_pClientList[iClientH]->m_pItemInBankList[j] == NULL)) {
									m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j+1];

									m_pClientList[iClientH]->m_pItemInBankList[j+1] = NULL;
								}
							}

							ZeroMemory(cMsg, sizeof(cMsg));

							dwp  = (DWORD *)(cMsg + INDEX4_MSGID);
							*dwp = MSGID_RESPONSE_RETRIEVEITEM;
							wp   = (WORD *)(cMsg + INDEX2_MSGTYPE);
							*wp  = MSGTYPE_CONFIRM;

							cp = (char *)(cMsg + INDEX2_MSGTYPE + 2);
							*cp = cBankItemIndex;
							cp++;
							*cp = i;
							cp++;

							iCalcTotalWeight(iClientH);
							m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

							iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);

							m_pClientList[iClientH]->m_bIsBankModified = TRUE ;

							switch (iRet) {
							case XSOCKEVENT_QUENEFULL:
							case XSOCKEVENT_SOCKETERROR:
							case XSOCKEVENT_CRITICALERROR:
							case XSOCKEVENT_SOCKETCLOSED:
								DeleteClient(iClientH, TRUE, TRUE);
								return;
							}
							return;
					}


					goto RRIH_NOQUANTITY;
		} 
		else {
RRIH_NOQUANTITY:;
			for (i = 0; i < MAXITEMS; i++)
				if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {

					m_pClientList[iClientH]->m_pItemList[i] = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];

					m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
					m_pClientList[iClientH]->m_ItemPosList[i].y = 30;

					m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;

					m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = NULL;


					if (m_pClientList[iClientH]->m_pItemList[i] != NULL)
					{
						if (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum == ITEM_ZEM )
							_bItemLog(ITEMLOG_RETRIEVE, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[i], TRUE);
						else 
							_bItemLog(ITEMLOG_RETRIEVE, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[i]) ;
					}

					for ( j = 0; j <= MAXBANKITEMS - 2; j++) {
						if ((m_pClientList[iClientH]->m_pItemInBankList[j+1] != NULL) && (m_pClientList[iClientH]->m_pItemInBankList[j] == NULL)) {
							m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j+1];
							m_pClientList[iClientH]->m_pItemInBankList[j+1] = NULL;
						}
					}

					ZeroMemory(cMsg, sizeof(cMsg));

					dwp  = (DWORD *)(cMsg + INDEX4_MSGID);
					*dwp = MSGID_RESPONSE_RETRIEVEITEM;
					wp   = (WORD *)(cMsg + INDEX2_MSGTYPE);
					*wp  = MSGTYPE_CONFIRM;

					cp = (char *)(cMsg + INDEX2_MSGTYPE + 2);
					*cp = cBankItemIndex;
					cp++;
					*cp = i;
					cp++;

					iCalcTotalWeight(iClientH);

					m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);

					m_pClientList[iClientH]->m_bIsBankModified = TRUE ;

					switch (iRet) {
					case XSOCKEVENT_QUENEFULL:
					case XSOCKEVENT_SOCKETERROR:
					case XSOCKEVENT_CRITICALERROR:
					case XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
					}
					return;
				}

				ZeroMemory(cMsg, sizeof(cMsg));

				dwp  = (DWORD *)(cMsg + INDEX4_MSGID);
				*dwp = MSGID_RESPONSE_RETRIEVEITEM;
				wp   = (WORD *)(cMsg + INDEX2_MSGTYPE);
				*wp  = MSGTYPE_REJECT;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
		}
	}

	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
}

bool CGame::bSetItemToBankItem(int iClientH, short sItemIndex)
{
	register int i, iRet;
	DWORD * dwp;
	WORD  * wp;
	char  * cp;
	short * sp;
	char cData[100];
	class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_bIsOnWarehouse == FALSE) return FALSE;

	for (i = 0; i < MAXBANKITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {

			m_pClientList[iClientH]->m_pItemInBankList[i] = m_pClientList[iClientH]->m_pItemList[sItemIndex];
			pItem = m_pClientList[iClientH]->m_pItemInBankList[i];

			m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;

			iCalcTotalWeight(iClientH);

			dwp  = (DWORD *)(cData + INDEX4_MSGID);			   
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + INDEX2_MSGTYPE);		       
			*wp  = NOTIFY_ITEMTOBANK;

			cp = (char *)(cData + INDEX2_MSGTYPE + 2);

			*cp = i; 
			cp++;

			cp += WriteItemData(cp, pItem);


			sp = (short *)cp;
			*sp = pItem->m_sItemEffectValue2;
			cp += 2;


			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;


			*cp = (char) pItem->m_sItemSpecEffectValue2 ;
			cp ++ ;

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 56);

#ifdef TAIWANLOG
			_bItemLog(ITEMLOG_DEPOSIT, iClientH, (int) -1, pItem);
#endif
			m_pClientList[iClientH]->m_bIsBankModified = TRUE ;

			switch (iRet) {
			case XSOCKEVENT_QUENEFULL:
			case XSOCKEVENT_SOCKETERROR:
			case XSOCKEVENT_CRITICALERROR:
			case XSOCKEVENT_SOCKETCLOSED:
			// DeleteClient(iClientH, TRUE, TRUE);
			return TRUE; 
			}

			return TRUE;
		}


		return FALSE;
}


void CGame::PK_KillRewardHandler(short sAttackerH, short sVictimH)
{
	if (m_pClientList[sAttackerH] == NULL) return;
	if (m_pClientList[sVictimH] == NULL)   return;

	_bPKLog(PKLOG_BYPLAYER,sAttackerH,sVictimH,NULL) ;

	if (m_pClientList[sAttackerH]->m_iPKCount != 0) {

	}
	else {

		m_pClientList[sAttackerH]->m_iRewardGold += iGetExpLevel(m_pClientList[sVictimH]->m_iExp) * 3;

		if (m_pClientList[sAttackerH]->m_iRewardGold > MAXREWARDGOLD) 
			m_pClientList[sAttackerH]->m_iRewardGold = MAXREWARDGOLD;
		if (m_pClientList[sAttackerH]->m_iRewardGold < 0) 
			m_pClientList[sAttackerH]->m_iRewardGold = 0;

		SendNotifyMsg(NULL, sAttackerH, NOTIFY_PKCAPTURED, m_pClientList[sVictimH]->m_iPKCount, m_pClientList[sVictimH]->m_iLevel, NULL, m_pClientList[sVictimH]->m_cCharName);
	}
}

void CGame::EnemyKillRewardHandler(int iAttackerH, int iClientH)
{
	int iRewardExp, iEK_Level;

	if (m_pClientList[iAttackerH] == NULL) return;
	if (m_pClientList[iClientH] == NULL)   return;

	_bPKLog(PKLOG_BYENERMY,iAttackerH,iClientH,NULL) ;

	iEK_Level = 30;
	if (m_pClientList[iAttackerH]->m_iLevel >= 80) iEK_Level = 80;

	if (m_pClientList[iAttackerH]->m_iPKCount != 0) {
	}
	else {
		if (m_pClientList[iClientH]->m_iGuildRank == -1) {

			iRewardExp = (dice(3, (3*iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp))/ 3 ;

			if (m_bIsCrusadeMode == TRUE) {
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp)*5;

				if (m_pClientList[iAttackerH]->m_iWarContribution > MAXWARCONTRIBUTION)
					m_pClientList[iAttackerH]->m_iWarContribution = MAXWARCONTRIBUTION;

				m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;

				if (m_pClientList[iAttackerH]->m_iConstructionPoint > MAXCONSTRUCTIONPOINT) 
					m_pClientList[iAttackerH]->m_iConstructionPoint = MAXCONSTRUCTIONPOINT;


				SendNotifyMsg(NULL, iAttackerH, NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, NULL, NULL);

				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					m_pClientList[iAttackerH]->m_iEnemyKillCount + m_iEnemyKillAdjust;
					m_pClientList[iAttackerH]->ApplyElo(m_pClientList[iClientH]);
				}

				m_pClientList[iAttackerH]->m_iRewardGold += dice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
			else {
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;


				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					m_pClientList[iAttackerH]->m_iEnemyKillCount + m_iEnemyKillAdjust;
					m_pClientList[iAttackerH]->ApplyElo(m_pClientList[iClientH]);
				}

				m_pClientList[iAttackerH]->m_iRewardGold += dice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
		}
		else {

			iRewardExp = (dice(3, (3*iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp))/ 3 ;

			if (m_bIsCrusadeMode == TRUE) {
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp)*5;

				if (m_pClientList[iAttackerH]->m_iWarContribution > MAXWARCONTRIBUTION)
					m_pClientList[iAttackerH]->m_iWarContribution = MAXWARCONTRIBUTION;

				m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;

				if (m_pClientList[iAttackerH]->m_iConstructionPoint > MAXCONSTRUCTIONPOINT) 
					m_pClientList[iAttackerH]->m_iConstructionPoint = MAXCONSTRUCTIONPOINT;

				SendNotifyMsg(NULL, iAttackerH, NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, NULL, NULL);

				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					m_pClientList[iAttackerH]->m_iEnemyKillCount + m_iEnemyKillAdjust;
					m_pClientList[iAttackerH]->ApplyElo(m_pClientList[iClientH]);
				}

				m_pClientList[iAttackerH]->m_iRewardGold += dice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
			else {
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;

				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					m_pClientList[iAttackerH]->m_iEnemyKillCount + m_iEnemyKillAdjust;
					m_pClientList[iAttackerH]->ApplyElo(m_pClientList[iClientH]);
				}

				m_pClientList[iAttackerH]->m_iRewardGold += dice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
		}

		SendNotifyMsg(NULL, iAttackerH, NOTIFY_ENEMYKILLREWARD, iClientH, NULL, NULL, NULL);

		if (bCheckLimitedUser(iAttackerH) == FALSE) {

			SendNotifyMsg(NULL, iAttackerH, NOTIFY_EXP, NULL, NULL, NULL, NULL);
		}
		bCheckLevelUp(iAttackerH);


		m_stCityStatus[m_pClientList[iAttackerH]->m_side].iWins++;
	}
}

void CGame::GetRewardMoneyHandler(int iClientH)		    
{
	int iEraseReq, iWeightLeft, iRewardGoldLeft;
	class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	iWeightLeft = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);

	if (iWeightLeft <= 0) return;

	iWeightLeft = iWeightLeft / 2;
	if (iWeightLeft <= 0) return;

	pItem = new class CItem;
	_bInitItemAttr(pItem, "Gold");
	//pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;

	
	if ((iWeightLeft / iGetItemWeight(pItem, 1)) >= m_pClientList[iClientH]->m_iRewardGold) {

		pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;
		iRewardGoldLeft = 0;
	}
	else {
		
		pItem->m_dwCount = (iWeightLeft / iGetItemWeight(pItem, 1));
		iRewardGoldLeft = m_pClientList[iClientH]->m_iRewardGold - (iWeightLeft / iGetItemWeight(pItem, 1));
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {

		m_pClientList[iClientH]->m_iRewardGold = iRewardGoldLeft;

		SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);

		if (iEraseReq == 1) delete pItem;

		SendNotifyMsg(NULL, iClientH, NOTIFY_REWARDGOLD, NULL, NULL, NULL, NULL);
	}
	else {

	}
}


int CGame::_iCalcMaxLoad(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return 0;
	return (m_pClientList[iClientH]->GetStr() * 500 + m_pClientList[iClientH]->m_iLevel*500);
}

int CGame::iAddDynamicObjectList(short sOwner, char cOwnerType, short sType, char cMapIndex, short sX, short sY, DWORD dwLastTime, int iV1)
{
	register int i;
	short sPreType;
	DWORD dwTime, dwRegisterTime;

	m_pMapList[cMapIndex]->bGetDynamicObject(sX, sY, &sPreType, &dwRegisterTime);
	if (sPreType != NULL) return NULL;

	switch (sType) {
	case DYNAMICOBJECT_FIRE:
		if (m_pMapList[cMapIndex]->bGetIsMoveAllowedTile(sX, sY) == FALSE)
			return NULL;

		if (dwLastTime != NULL)  {
			switch (m_pMapList[cMapIndex]->m_cWhetherStatus) {
			case 1:	dwLastTime = dwLastTime - (dwLastTime / 2);       break;
			case 2:	dwLastTime = (dwLastTime / 2) - (dwLastTime / 3); break;
			case 3:	dwLastTime = (dwLastTime / 3) - (dwLastTime / 4); break;
			}

			if (dwLastTime == NULL) dwLastTime = 1000;
		}
		break;

	case DYNAMICOBJECT_FISHOBJECT:
	case DYNAMICOBJECT_FISH:
		if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == FALSE)
			return NULL;
		break;

	case DYNAMICOBJECT_MINERAL1:
	case DYNAMICOBJECT_MINERAL2:
		if (m_pMapList[cMapIndex]->bGetMoveable(sX, sY) == FALSE)
			return NULL;
		m_pMapList[cMapIndex]->SetTempMoveAllowedFlag(sX, sY, FALSE);
		break;
	case DYNAMICOBJECT_ARESDENFLAG:
	case DYNAMICOBJECT_ELVINEFLAG:
		m_pMapList[cMapIndex]->SetTempMoveAllowedFlag(sX, sY, FALSE);
		break;
	}


	for (i = 1; i < MAXDYNAMICOBJECTS; i++) 
		if (m_pDynamicObjectList[i] == NULL) {
			dwTime = timeGetTime();

			if (dwLastTime != NULL) 
				dwLastTime += (dice(1,4)*1000);

			m_pDynamicObjectList[i] = new class CDynamicObject(sOwner, cOwnerType, sType, cMapIndex, sX, sY, dwTime, dwLastTime, iV1);
			m_pMapList[cMapIndex]->SetDynamicObject(i, sType, sX, sY, dwTime);
			SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, MSGTYPE_CONFIRM, cMapIndex, sX, sY, sType, i, NULL);

			return i;
		}

	return NULL;
}

void CGame::CheckDynamicObjectList()
{
	register int i;
	DWORD dwTime = timeGetTime(), dwRegisterTime;
	short sType;

	for (i = 1; i < MAXDYNAMICOBJECTS; i++) {
		if (m_pDynamicObjectList[i] && m_pDynamicObjectList[i]->m_dwLastTime != 0) 
		{

			switch (m_pDynamicObjectList[i]->m_sType) 
			{
			case DYNAMICOBJECT_FIRE:

				switch (m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus) 
				{
				case 1: 
				case 2:
				case 3:
					m_pDynamicObjectList[i]->m_dwLastTime = m_pDynamicObjectList[i]->m_dwLastTime - 
						(m_pDynamicObjectList[i]->m_dwLastTime/10) * m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus;
					break;
				}
				break;
			}

			if (dwTime - m_pDynamicObjectList[i]->m_dwRegisterTime >= m_pDynamicObjectList[i]->m_dwLastTime) 
			{
				m_pMapList[ m_pDynamicObjectList[i]->m_cMapIndex ]->bGetDynamicObject( m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, &sType, &dwRegisterTime );

				if (dwRegisterTime == m_pDynamicObjectList[i]->m_dwRegisterTime) {
					SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, MSGTYPE_REJECT, m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, m_pDynamicObjectList[i]->m_sType, i, NULL);
					m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, dwTime);
				}

				switch (sType) 
				{
				case DYNAMICOBJECT_FISHOBJECT:
				case DYNAMICOBJECT_FISH:
					bDeleteFish(m_pDynamicObjectList[i]->m_sOwner, 2); 
					break;
				}

				delete m_pDynamicObjectList[i];
				m_pDynamicObjectList[i] = NULL;
			}
		}
	}
}

void CGame::MobGenerator()
{
	register int i, j, iNamingValue, iResult, iTotalMob;
	char cNpcName[21], cName_Master[11], cName_Slave[11], cWaypoint[11];
	char cSA;
	int  pX, pY, iMapLevel, iProbSA, iKindSA, iResultNum, iFirmSAType;
	bool bMaster, bFirmBerserk, bIsSpecialEvent;
	short sNpcType = 0 ;


	if (m_bOnExitProcess == TRUE) return;

	for (i = 0; i < MAXMAPS; i++) {
		// Random Mob Generator
		iResultNum = 0;

#ifdef CHECKUSERNPCNUM

		if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bRandomMobGenerator == TRUE)) {

			if (m_iTotalGameServerClients >= 1000) {
				iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
			}
			else {
				dV2 = (double)m_iTotalGameServerClients;
				dV3 = (m_pMapList[i]->m_iMaximumObject - 30);

				dV1 = (dV2 / 1000.0f)*dV3;
				iResultNum = (int)dV1;
			}


			iMin = (m_pMapList[i]->m_iMaximumObject - 30) - ((m_pMapList[i]->m_iMaximumObject - 30)/3);
			if (iResultNum > (m_pMapList[i]->m_iMaximumObject - 30)) iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
			if (iResultNum < iMin) iResultNum = iMin;
		}
#endif

		//if ( (m_pMapList[i] != NULL) && (m_pMapList[i]->m_bRandomMobGenerator == TRUE) && 
		//	 ((m_pMapList[i]->m_iMaximumObject - 30) > m_pMapList[i]->m_iTotalActiveObject) ) {

		if (m_pMapList[i] != NULL) {
			iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
		}
		if (m_bHeldenianMode && m_iHeldenianType == 1) return;
		if ( (m_pMapList[i] != NULL) && (m_pMapList[i]->m_bRandomMobGenerator == TRUE) && (iResultNum > m_pMapList[i]->m_iTotalActiveObject) ) {

			if ((m_iMiddlelandMapIndex != -1) && (m_iMiddlelandMapIndex == i) && (m_bIsCrusadeMode == TRUE)) break;

			iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
			if (iNamingValue != -1) {

				ZeroMemory(cName_Master, sizeof(cName_Master));
				wsprintf(cName_Master, "XX%d", iNamingValue);
				cName_Master[0] = '_';
				cName_Master[1] = i + 65;

				ZeroMemory(cNpcName, sizeof(cNpcName));

				iFirmSAType  = NULL;
				bFirmBerserk = FALSE;
				iResult = dice(1,100);
				switch (m_pMapList[i]->m_cRandomMobGeneratorLevel) {
				case 1:
					if ((iResult >= 1) && (iResult < 20)) {
						iResult = 1;  					}
					else if ((iResult >= 20) && (iResult < 40)) {
						iResult = 2;  
					}
					else if ((iResult >= 40) && (iResult < 85)) {
						iResult = 24; 					}
					else if ((iResult >= 85) && (iResult < 95)) {
						iResult = 25; 
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						iResult = 3;  					}

					iMapLevel = 1;
					break;

				case 2:
					if ((iResult >= 1) && (iResult < 40)) {
						iResult = 1;
					}
					else if ((iResult >= 40) && (iResult < 80)) {
						iResult = 2;
					}
					else iResult = 10;
					iMapLevel = 1;
					break;

				case 3:     
					if ((iResult >= 1) && (iResult < 20)) {
						switch ( dice(1,2) ) {
						case 1: iResult = 3; break;
						case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 20) && (iResult < 25)) {
						iResult = 30;  
					}
					else if ((iResult >= 25) && (iResult < 50)) {
						switch ( dice(1,3) ) {
						case 1: iResult = 5; break;
						case 2:	iResult = 6; break;
						case 3: iResult = 7; break;
						}
					}
					else if ((iResult >= 50) && (iResult < 75)) {

						switch ( dice(1,7) ) {
						case 1: 
						case 2: iResult = 8;  break;
						case 3:	iResult = 11; break;
						case 4:	iResult = 12; break;
						case 5: iResult = 18; break;
						case 6: iResult = 26; break;
						case 7: iResult = 28; break;	// Ettin
						}
					}
					else if ((iResult >= 75) && (iResult <= 100)) {

						switch ( dice(1,5) ) {
						case 1:
						case 2:	iResult = 9;  break;
						case 3:	iResult = 13; break;
						case 4: iResult = 14; break;
						case 5: iResult = 27; break;	// Mountain-Giant
						}
					}
					iMapLevel = 4;
					break;

				case 4:
					if ((iResult >= 1) && (iResult < 50)) {
						switch ( dice(1,2) ) {
						case 1:	iResult = 2; break;
						case 2: iResult = 10; break;
						}
					}
					else if ((iResult >= 50) && (iResult < 80)) {
						switch ( dice(1,2) ) {
						case 1: iResult = 8; break;
						case 2: iResult = 11; break;
						}
					}
					else if ((iResult >= 80) && (iResult < 100)) {
						switch ( dice(1,2) ) {
						case 1: iResult = 14; break;
						case 2:	iResult = 9; break;
						}
					}
					iMapLevel = 2;
					break;

				case 5:
					if ((iResult >= 1) && (iResult < 30)) {
						switch ( dice(1,5) ) {
						case 1:
						case 2: 
						case 3:
						case 4: 
						case 5: iResult = 2; break;
						}
					}
					else if ((iResult >= 30) && (iResult < 60)) {
						switch ( dice(1,2) ) {
						case 1: iResult = 3; break;
						case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 60) && (iResult < 80)) {
						switch ( dice(1,2) ) {
						case 1: iResult = 5; break;
						case 2: iResult = 7; break;
						}
					}
					else if ((iResult >= 80) && (iResult < 95)) {
						switch ( dice(1,3) ) {
						case 1:
						case 2: iResult = 8;  break;
						case 3:	iResult = 11; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						switch ( dice(1,3) ) {
						case 1: iResult = 11; break;
						case 2: iResult = 14; break;
						case 3: iResult = 9; break;
						}
					}
					iMapLevel = 3;
					break;

				case 6: // huntzone 2,4
					if ((iResult >= 1) && (iResult < 60)) {
						switch ( dice(1,4) ) {
						case 1: iResult = 5; break;
						case 2:	iResult = 6; break;
						case 3: iResult = 7; break;
						case 4: iResult = 4; break;
						}
					}
					else if ((iResult >= 60) && (iResult < 90)) {
						switch ( dice(1,4) ) {
						case 1:
						case 2: iResult = 8;  break;
						case 3:	iResult = 11; break;
						case 4:	iResult = 12; break;
						}
					}
					else if ((iResult >= 90) && (iResult <= 100)) {


						switch ( dice(1,7) ) {
						case 1: iResult = 26; break;
						case 2:	iResult = 9;  break;
						case 3:	iResult = 13; break;
						case 4: iResult = 14; break;
						case 5: iResult = 18; break;
						case 6: iResult = 28; break;	// Ettin
						case 7: iResult = 27; break;	// Mountain-Giant
						}
					}
					iMapLevel = 4;
					break;

				case 7: // areuni, elvuni
					if ((iResult >= 1) && (iResult < 50)) {
						switch (dice(1,5)) {
						case 1: iResult = 3;  break; // Orc
						case 2: iResult = 6;  break; // Orc-Mage
						case 3: iResult = 10; break; // Amphis
						case 4: iResult = 3;  break; // Orc
						case 5: iResult = 50; break; // Giant-Tree
						}
					}
					else if ((iResult >= 50) && (iResult < 60)) {
						iResult = 30; // Rudolph
					}
					else if ((iResult >= 60) && (iResult < 85)) {
						switch (dice(1,4)) {
						case 1: iResult = 50; break; // Giant-Tree
						case 2: 
						case 3: iResult = 6;  break; // Orc-Mage
						case 4: iResult = 12; break; // Troll
						}
					}
					else if ((iResult >= 85) && (iResult <= 100)) {
						switch (dice(1,3)) {
						case 1: iResult = 12;  break; // Troll
						case 2:
						case 3:
						if (dice(1,100) < 3) 
							iResult = 17; // Unicorn
						else iResult = 12; // Troll
						break;
						}
					}
					iMapLevel = 4;
					break;

				case 8:
					if ((iResult >= 1) && (iResult < 70)) {
						switch ( dice(1,2) ) {
						case 1:	iResult = 4;  break;
						case 2: iResult = 5;  break;
						}
					}
					else if ((iResult >= 70) && (iResult < 90)) {
						switch ( dice(1,3) ) {
						case 1: iResult = 8;  break;
						case 2: iResult = 11; break;
						case 3: iResult = 14; break;
						}
					}
					else if ((iResult >= 90) && (iResult < 100)) {
						switch ( dice(1,2) ) {
						case 1: iResult = 9;  break;
						case 2: iResult = 14; break;
						}
					}
					iMapLevel = 4;
					break;

				case 9:
					if ((iResult >= 1) && (iResult < 70)) {
						switch ( dice(1,2) ) {
						case 1:	iResult = 4;  break;
						case 2: iResult = 5;  break;
						}
					}
					else if ((iResult >= 70) && (iResult < 95)) {
						switch ( dice(1,3) ) {
						case 1: iResult = 8;  break;
						case 2: iResult = 9;  break;
						case 3: iResult = 13; break;
						}
					}
					else if ((iResult >= 95) && (iResult < 100)) {
						switch ( dice(1,6) ) {
						case 1:
						case 2:
						case 3: iResult = 9;  break;
						case 4:
						case 5: iResult = 14; break;
						case 6: iResult = 15; break;
						}
					}


					if ((dice(1,3) == 1) && (iResult != 16)) bFirmBerserk = TRUE;

					iMapLevel = 4;
					break;

				case 10:
					if ((iResult >= 1) && (iResult < 70)) {
						switch ( dice(1,2) ) {
						case 1:	iResult = 4; break;
						case 2: iResult = 5; break;
						}
					}
					else if ((iResult >= 70) && (iResult < 95)) {
						// 
						switch ( dice(1,3) ) {
						case 1:
						case 2:	iResult = 13; break;
						case 3: iResult = 14; break;
						}
					}
					else if ((iResult >= 95) && (iResult < 100)) {
						switch (dice(1,3)) {
						case 1:
						case 2: iResult = 14; break;
						case 3: iResult = 15; break;
						}
					}


					if ((dice(1,3) == 1) && (iResult != 16)) bFirmBerserk = TRUE;

					iMapLevel = 5;
					break;

				case 11:
					if ((iResult >= 1) && (iResult < 30)) {
						switch ( dice(1,5) ) {
						case 1:
						case 2: 
						case 3:
						case 4: 
						case 5: iResult = 2; break;
						}
					}
					else if ((iResult >= 30) && (iResult < 60)) {
						switch ( dice(1,2) ) {
						case 1: iResult = 3; break;
						case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 60) && (iResult < 80)) {
						switch ( dice(1,2) ) {
						case 1: iResult = 5; break;
						case 2: iResult = 7; break;
						}
					}
					else if ((iResult >= 80) && (iResult < 95)) {
						switch ( dice(1,3) ) {
						case 1:
						case 2: iResult = 10;  break;
						case 3:	iResult = 11; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						switch ( dice(1,3) ) {
						case 1: iResult = 11; break;
						case 2: iResult = 7; break;
						case 3: iResult = 8; break;
						}
					}
					iMapLevel = 4;
					break;

				case 12: // middled1n
					if ((iResult >= 1) && (iResult < 50)) {
						switch ( dice(1,3) ) {
						case 1:	iResult = 1 ; break;
						case 2: iResult = 2 ; break;
						case 3: iResult = 10; break;
						}
					}
					else if ((iResult >= 50) && (iResult < 85)) {
						switch ( dice(1,2) ) {
						case 1: iResult = 5; break;
						case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 85) && (iResult < 100)) {
						switch ( dice(1,3) ) {
						case 1: iResult = 8; break;
						case 2: iResult = 11; break;
						case 3: iResult = 26; break;
						}
					}
					iMapLevel = 4;
					break;

				case 13: 					
					if ((iResult >= 1) && (iResult < 15)) {
						iResult = 4;
						bFirmBerserk = TRUE;
						iFirmSAType  = 4 - (dice(1,2)-1);
					}
					else if ((iResult >= 15) && (iResult < 40)) {
						iResult = 14;
						bFirmBerserk = TRUE;
						iFirmSAType  = 4 - (dice(1,2)-1);
					}

					else if ((iResult >= 40) && (iResult < 60)) {
						iResult = 9;
						bFirmBerserk = TRUE;
						iFirmSAType  = 4 - (dice(1,2)-1);
					}
					else if ((iResult >= 60) && (iResult < 75)) {
						iResult = 13;
						bFirmBerserk = TRUE;
						iFirmSAType  = 4 - (dice(1,2)-1);
					}
					else if ((iResult >= 75) && (iResult < 95)) {

						iResult = 23;
					}
					else if ((iResult >= 95) && (iResult < 100)) {

						iResult = 22;
					}
					iMapLevel = 4;
					break;

				case 14: 					
					if ((iResult >= 1) && (iResult < 30)) {
						iResult = 23;
					}
					else if ((iResult >= 30) && (iResult < 50)) {

						iResult = 22;
					}
					else if ((iResult >= 50) && (iResult < 70)) {
						iResult = 15;
						bFirmBerserk = TRUE;
						iFirmSAType  = 4 - (dice(1,2)-1);
					}
					else if ((iResult >= 70) && (iResult < 90)) {
						iResult = 16;
					}
					else if ((iResult >= 90) && (iResult < 100)) {

						iResult = 21;
					}
					iMapLevel = 4;
					break;

				case 15: 
					if ((iResult >= 1) && (iResult < 35)) {

						iResult = 23;
						bFirmBerserk = TRUE;
					}
					else if ((iResult >= 35) && (iResult < 50)) {

						iResult = 22;
						bFirmBerserk = TRUE;
					}
					else if ((iResult >= 50) && (iResult < 80)) {
						iResult = 16;
						bFirmBerserk = TRUE;
					}
					else if ((iResult >= 80) && (iResult < 100)) {

						iResult = 21;
					}
					iMapLevel = 4;
					break;
				case 16: 
					if ((iResult >= 1) && (iResult < 40)) {
						switch ( dice(1,3) ) {
						case 1:	iResult = 1 ; break;
						case 2: iResult = 2 ; break;
						case 3: iResult = 10; break;
						}
					}
					else if ((iResult >= 40) && (iResult < 50)) {
						iResult = 30;
					}
					else if ((iResult >= 50) && (iResult < 85)) {
						switch ( dice(1,2) ) {
						case 1: iResult = 5; break;
						case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 85) && (iResult < 100)) {
						switch ( dice(1,3) ) {
						case 1: iResult = 8; break;
						case 2: iResult = 11; break;
						case 3: iResult = 26; break;
						}
					}
					iMapLevel = 1 ;
					break;
				case 17:
					if ((iResult >= 1) && (iResult < 30)) {
						switch ( dice(1,4) ) {
						case 1:	iResult = 22 ; break;
						case 2: iResult = 8; break;
						case 3: iResult = 24 ; break;
						case 4: iResult = 5; break;
						}
					}
					else if ((iResult >= 30) && (iResult < 40)) {
						iResult = 30;
					}
					else if ((iResult >= 40) && (iResult < 70)) {
						iResult = 32;

					}
					else if ((iResult >= 70) && (iResult < 90)) {
						iResult = 31;
						if (dice(1,5) == 1) bFirmBerserk = TRUE;
					}
					else if ((iResult >= 90) && (iResult <= 100)) {
						iResult = 33;
					}
					iMapLevel = 1 ;
					break;
				case 18:
					if ((iResult == 1) || (iResult == 2)) 
					{	iResult = 35; // Hellclaw
					}else if ((iResult > 2) && (iResult <= 12)) 
					{	iResult = 48; // Nizie
					}else if ((iResult > 12) && (iResult <= 50)) 
					{	iResult = 44; // ClawTurtle
					}else if ((iResult > 50) && (iResult <= 85)) 
					{	iResult = 45; // Giant-Crayfish
					}else if ((iResult > 85) && (iResult <= 95)) 
					{	iResult = 34; // Stalker							
					}else if ((iResult > 95) && (iResult <= 100)) 
					{	iResult = 26; // Frog
					}
					break;

				case 19: // Maze Map from HBChina351
					if ((iResult >= 1) && (iResult <= 15)) 
					{	iResult = 40; // Centaur
					}else if ((iResult > 15) && (iResult <= 25)) 
					{	iResult = 42; // Minaus
					}else if ((iResult > 25) && (iResult <= 35)) 
					{	iResult = 21; // Gagoyle
					}else if ((iResult > 35) && (iResult <= 60)) 
					{	iResult = 43; // Tentocle					
					}else if ((iResult > 60) && (iResult < 90)) 
					{	iResult = 23; // Dark-Elf					
					}else if ((iResult >= 90) && (iResult <= 100)) 
					{	iResult = 22; // Beholder
					}
					break;

				case 20: // Heldenian Map from HBChina351
					if (iResult == 1)  
					{	iResult = 37; // Fire-Wyvern
					}else if ((iResult > 1) && (iResult <=3)) 
					{	iResult = 36; // Wyvern
					}else if ((iResult > 3) && (iResult <= 8)) 
					{	iResult = 49; // TigerWorm
					}else if ((iResult == 9)) 
					{	iResult = 38; // HC
					}else if ((iResult > 9) && (iResult <= 20)) 
					{	iResult = 21; // Gagoyle
					}else if ((iResult > 20) && (iResult <= 35)) 
					{	iResult = 16; // Demon
					}else if ((iResult > 35) && (iResult <= 45)) 
					{	iResult = 40; // Centaurus
					}else if ((iResult > 45) && (iResult <= 55)) 
					{	iResult = 41; // Giant Lizard
					}else if ((iResult > 55) && (iResult <= 75)) 
					{	iResult = 28; // Ettin					
					}else if ((iResult > 75) && (iResult <= 95)) 
					{	iResult = 43; // Tentocle
					}else if ((iResult > 95) && (iResult <= 100)) 
					{	iResult = 22; // Beholder
					}
					break;

				case 21: // ????????
					if ((iResult >= 1) && (iResult < 94)) 
					{	iResult = 17; // Unicorn
						bFirmBerserk = TRUE;
					}else if ((iResult >= 94) && (iResult < 95)) 
					{	iResult = 36; // Wyvern
					}else if ((iResult >= 95) && (iResult < 96)) 
					{	iResult = 37; // Fire-Wyvern
					}else if ((iResult >= 96) && (iResult < 97)) 
					{	iResult = 47; // MasterMage-Orc
					}else if ((iResult >= 97) && (iResult < 98)) 
					{	iResult = 35; // Hellclaw
					}else if ((iResult >= 98) && (iResult < 99)) 
					{	iResult = 49; // Tigerworm
					}else if ((iResult >= 99) && (iResult <= 100)) 
					{	iResult = 51; // Abaddon
					}
					break;
				}

				pX = NULL;
				pY = NULL;


				bIsSpecialEvent = FALSE;
				if ((m_bIsSpecialEventTime == TRUE) && (dice(1,10) == 3)) bIsSpecialEvent = TRUE;

				if (bIsSpecialEvent == TRUE) {
					switch (m_cSpecialEventType) {
					case 1:
						if (m_pMapList[i]->m_iMaxPx != 0) {
							pX = m_pMapList[i]->m_iMaxPx*20 +10;
							pY = m_pMapList[i]->m_iMaxPy*20 +10;

							if (pX < 0) pX = 0;
							if (pY < 0) pY = 0;

							if (m_bIsCrusadeMode == TRUE) {
								if (strcmp(m_pMapList[i]->m_cName, sideMap[ARESDEN]) == 0)
									iResult = 20;
								else if (strcmp(m_pMapList[i]->m_cName, sideMap[ELVINE]) == 0)
									iResult = 19;
							}

							wsprintf(g_cTxt, "(!) Mob-Event Map(%s) Loc(%d,%d)", m_pMapList[i]->m_cName, pX, pY);
							PutLogList(g_cTxt);
						}
						break;

					case 2:
						if (dice(1,3) == 2) {
							if ((memcmp(m_pMapList[i]->m_cName, sideMap[ARESDEN], 7)   == 0) ||
								(memcmp(m_pMapList[i]->m_cName, "middled1n", 9) == 0) ||
								(memcmp(m_pMapList[i]->m_cName, "arefarm", 7) == 0) ||
								(memcmp(m_pMapList[i]->m_cName, "elvfarm", 7) == 0) ||
								(memcmp(m_pMapList[i]->m_cName, sideMap[ELVINE], 6)    == 0)) {
									if (dice(1,30) == 5) 
										iResult = 16;
									else iResult = 5;
							}
							else iResult = 16;
						}
						else iResult = 17;

						m_bIsSpecialEventTime = FALSE;
						break;
					}
				}

				ZeroMemory(cNpcName, sizeof(cNpcName));
				switch (iResult) {
				case 1:  strcpy(cNpcName, "Slime");     sNpcType = 10 ;   iProbSA = 5;  iKindSA = 1; break;
				case 2:  strcpy(cNpcName, "Giant-Ant"); sNpcType = 16 ;   iProbSA = 10; iKindSA = 2; break;
				case 3:  strcpy(cNpcName, "Orc");       sNpcType = 14 ;   iProbSA = 15; iKindSA = 1; break;
				case 4:  strcpy(cNpcName, "Zombie");    sNpcType = 18 ;   iProbSA = 15; iKindSA = 3; break;
				case 5:  strcpy(cNpcName, "Skeleton");  sNpcType = 11 ;   iProbSA = 35; iKindSA = 8; break;
				case 6:  strcpy(cNpcName, "Orc-Mage");  sNpcType = 14 ;   iProbSA = 30; iKindSA = 7; break;
				case 7:  strcpy(cNpcName, "Scorpion");  sNpcType = 17 ;   iProbSA = 15; iKindSA = 3; break;
				case 8:  strcpy(cNpcName, "Stone-Golem"); sNpcType = 12 ; iProbSA = 25; iKindSA = 5; break;
				case 9:  strcpy(cNpcName, "Cyclops");    sNpcType = 13 ;  iProbSA = 35; iKindSA = 8; break;
				case 10: strcpy(cNpcName, "Amphis");     sNpcType = 22 ;  iProbSA = 20; iKindSA = 3; break;
				case 11: strcpy(cNpcName, "Clay-Golem"); sNpcType = 23 ;  iProbSA = 20; iKindSA = 5; break;
				case 12: strcpy(cNpcName, "Troll");      sNpcType = 28 ;  iProbSA = 25; iKindSA = 3; break; 
				case 13: strcpy(cNpcName, "Orge");       sNpcType = 29 ;  iProbSA = 25; iKindSA = 1; break;
				case 14: strcpy(cNpcName, "Hellbound");  sNpcType = 27 ;  iProbSA = 25; iKindSA = 8; break;
				case 15: strcpy(cNpcName, "Liche");		 sNpcType = 30 ;  iProbSA = 30; iKindSA = 8; break;
				case 16: strcpy(cNpcName, "Demon");		 sNpcType = 31 ;  iProbSA = 20; iKindSA = 8; break;
				case 17: strcpy(cNpcName, "Unicorn");	 sNpcType = 32 ;  iProbSA = 35; iKindSA = 7; break;
				case 18: strcpy(cNpcName, "WereWolf");	 sNpcType = 33 ;  iProbSA = 25; iKindSA = 1; break;
				case 19: strcpy(cNpcName, "YB-Aresden"); sNpcType = 1 ;   iProbSA = 15; iKindSA = 1; break;
				case 20: strcpy(cNpcName, "YB-Elvine");	 sNpcType = 1 ;   iProbSA = 15; iKindSA = 1; break;
				case 21: strcpy(cNpcName, "Gagoyle");	 sNpcType = 52 ;  iProbSA = 20; iKindSA = 8; break;
				case 22: strcpy(cNpcName, "Beholder");	 sNpcType = 53 ;  iProbSA = 20; iKindSA = 5; break;
				case 23: strcpy(cNpcName, "Dark-Elf");	 sNpcType = 54 ;  iProbSA = 20; iKindSA = 3; break;

				case 24: strcpy(cNpcName, "Rabbit");	 sNpcType = 55 ;  iProbSA =  5; iKindSA = 1; break;
				case 25: strcpy(cNpcName, "Cat");		 sNpcType = 56 ;  iProbSA = 10; iKindSA = 2; break;
				case 26: strcpy(cNpcName, "Giant-Frog"); sNpcType = 57 ;  iProbSA = 10; iKindSA = 2; break;

				case 27: strcpy(cNpcName, "Mountain-Giant");  sNpcType = 58 ; 	iProbSA = 25; iKindSA = 1; break;
				case 28: strcpy(cNpcName, "Ettin");			  sNpcType = 59 ;	iProbSA = 20; iKindSA = 8; break;
				case 29: strcpy(cNpcName, "Cannibal-Plant");  sNpcType = 60 ; 	iProbSA = 20; iKindSA = 5; break;

				case 30: strcpy(cNpcName, "Rudolph");    sNpcType = 61 ; 	iProbSA = 20; iKindSA = 5; break;
				case 31: strcpy(cNpcName, "Ice-Golem");  sNpcType = 65 ;    iProbSA = 35; iKindSA = 8; break;
				case 32: strcpy(cNpcName, "DireBoar");  sNpcType = 62 ; 	iProbSA = 20; iKindSA = 5; break;
				case 33: strcpy(cNpcName, "Frost");		 sNpcType = 63 ;    iProbSA = 30; iKindSA = 8; break;

				case 34: strcpy(cNpcName, "Stalker");           sNpcType = 48; iProbSA = 20; iKindSA = 1; break;
				case 35: strcpy(cNpcName, "Hellclaw");			sNpcType = 49; iProbSA = 20; iKindSA = 1; break;
				case 36: strcpy(cNpcName, "Wyvern");			sNpcType = 66; iProbSA = 20; iKindSA = 10; break;
				case 37: strcpy(cNpcName, "Fire-Wyvern");		sNpcType = 73; iProbSA = 20; iKindSA = 10; break; 
				case 38: strcpy(cNpcName, "Barlog");			sNpcType = 70; iProbSA = 20; iKindSA = 1; break;
				case 39: strcpy(cNpcName, "Tentocle");			sNpcType = 80; iProbSA = 20; iKindSA = 1; break;
				case 40: strcpy(cNpcName, "Centaurus");			sNpcType = 71; iProbSA = 20; iKindSA = 1; break;
				case 41: strcpy(cNpcName, "Giant-Lizard");		sNpcType = 75; iProbSA = 20; iKindSA = 1; break;
				case 42: strcpy(cNpcName, "Minotaurs");			sNpcType = 78; iProbSA = 20; iKindSA = 1; break;
				case 43: strcpy(cNpcName, "Tentocle");			sNpcType = 80; iProbSA = 20; iKindSA = 1; break;
				case 44: strcpy(cNpcName, "Claw-Turtle");		sNpcType = 72; iProbSA = 20; iKindSA = 1; break;
				case 45: strcpy(cNpcName, "Giant-Crayfish");	sNpcType = 74; iProbSA = 20; iKindSA = 1; break;
				case 46: strcpy(cNpcName, "Giant-Plant");		sNpcType = 76; iProbSA = 20; iKindSA = 1; break;
				case 47: strcpy(cNpcName, "MasterMage-Orc");	sNpcType = 77; iProbSA = 20; iKindSA = 1; break;
				case 48: strcpy(cNpcName, "Nizie");				sNpcType = 79; iProbSA = 20; iKindSA = 1; break;
				case 49: strcpy(cNpcName, "Tigerworm");			sNpcType = 50; iProbSA = 20; iKindSA = 1; break;
				case 50: strcpy(cNpcName, "Giant-Plant");		sNpcType = 76; iProbSA = 20; iKindSA = 1; break;
				case 51: strcpy(cNpcName, "Abaddon");			sNpcType = 81; iProbSA = 20; iKindSA = 10; break;
				default: strcpy(cNpcName, "Orc");		      sNpcType = 14 ; 	iProbSA = 15; iKindSA = 1; break;
				}

				cSA = 0;
				if (iFirmSAType == NULL) {
					if (dice(1,100) <= iProbSA) cSA = _cGetSpecialAbility(iKindSA);
				}
				else cSA = (char)iFirmSAType;

				if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, cSA, MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, bFirmBerserk, TRUE)) == FALSE) {
					m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
				}
				else {

				}
			}

			switch (iResult) {
			case 1:	 iTotalMob = dice(1,5)-1; break;  // Slime 
			case 2:	 iTotalMob = dice(1,5)-1; break; // Giant-Ant
			case 3:	 iTotalMob = dice(1,5)-1; break; // Orc
			case 4:	 iTotalMob = dice(1,3)-1; break; // Zombie
			case 5:	 iTotalMob = dice(1,3)-1; break;
			case 6:  iTotalMob = dice(1,3)-1; break; // Skeleton
			case 7:  iTotalMob = dice(1,3)-1; break; // Scorpion
			case 8:  iTotalMob = dice(1,2)-1; break; // Stone-Golem
			case 9:  iTotalMob = dice(1,2)-1; break;
			case 10: iTotalMob = dice(1,5)-1; break; // Amphis
			case 11: iTotalMob = dice(1,3)-1; break; // Clay-Golem
			case 12: iTotalMob = dice(1,5)-1; break; // Troll
			case 13: iTotalMob = dice(1,3)-1; break; // Orge
			case 14: iTotalMob = dice(1,3)-1; break; // Rabbit
			case 15: iTotalMob = dice(1,3)-1; break; // Cat
			case 16: iTotalMob = dice(1,2)-1; break; // Giant-Frog
			case 17: iTotalMob = dice(1,2)-1; break; // Mountain-Giant
			case 18: iTotalMob = dice(1,5)-1; break; // Ettin
			case 21: iTotalMob = dice(1,2)-1; break; // Cannibal-Plant
			case 22: iTotalMob = dice(1,2)-1; break;
			case 23: iTotalMob = dice(1,5)-1; break;

			case 24: iTotalMob = dice(1,2)-1; break;
			case 25: iTotalMob = dice(1,2)-1; break;
			case 26: iTotalMob = dice(1,4)-1; break;
				// 2002-09-12 #1
			case 27: iTotalMob = dice(1,2)-1; break;
			case 28: iTotalMob = dice(1,3)-1; break;
			case 29: iTotalMob = dice(1,3)-1; break;

			case 30: iTotalMob = dice(1,3)-1; break;

			case 31: iTotalMob = dice(1,5)-1; break;
			case 32: iTotalMob = dice(1,3)-1; break;
			case 33: iTotalMob = dice(1,3)-1; break;
			case 34: iTotalMob = 1; break;
			case 35: iTotalMob = 1; break;
			case 36: iTotalMob = 1; break;

			case 37: iTotalMob = 1; break;
			case 38: iTotalMob = 1; break;
			case 39: iTotalMob = 1; break;
			case 40: iTotalMob = 1; break;
			case 41: iTotalMob = 1; break;

			case 42: iTotalMob = dice(1,3)-1; break;
			case 43: iTotalMob = 1; break;
			case 44: iTotalMob = dice(1,3)-1; break; 
			case 45: iTotalMob = 1; break;

			default: iTotalMob = 0; break;
			}
			if (bMaster == FALSE) iTotalMob = 0;


			//if ((iTotalMob >= 2) && (dice(1,2) == 1)) iTotalMob = 0;


			if (iTotalMob >= 2) {
				switch (iResult) {
				case 1:   // Slime 
				case 2:  // Giant-Ant
				case 3:  // Orc
				case 4:  // Zombie
				case 5:  // Skeleton
				case 7:  // Scorpion
				case 8:  // Stone-Golem
				case 10: // Amphis
				case 11: // Clay-Golem
				case 12: // Troll
				case 13: // Orge
				case 24: // Rabbit
				case 25: // Cat
				case 26: // Giant-Frog
				case 27: // Mountain-Giant
				case 28: // Ettin
				case 29: // Cannibal-Plant

				case 30:
				case 32: // DireBoar
				case 33: // Frost
					if (dice(1,5) != 1) iTotalMob = 0;  
					break;

				case 9:  // Cyclops
				case 6:  // Orc-Mage
				case 14: // Hellbound
				case 15: // Liche
				case 16: // Demon
				case 17: // Unicorn
				case 18: // WereWolf
				case 31: // Ice-Golem
				case 34:
				case 35:
				case 36:
				case 37:
				case 38:
				case 39:
				case 40:
				case 41:
				case 42:
				case 44:
				case 45:
				case 46:
				case 47:
				case 48:
				case 49:
					if (dice(1,5) == 1) iTotalMob = 0;  
					break;

				default: 					break;
				}
			}

			// 2002-7-4
			if (bIsSpecialEvent == TRUE) {
				switch (m_cSpecialEventType) {
				case 1:
					if ((iResult != 15) && (iResult != 16) && (iResult != 21))
						iTotalMob = m_pMapList[i]->sMobEventAmount;

					for (j = 1; j < MAXCLIENTS; j++) 
						if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == TRUE) && (m_pClientList[j]->m_cMapIndex == i)) 
							SendNotifyMsg(NULL, j, NOTIFY_MONSTEREVENT_POSITION, pX, pY, sNpcType, NULL);

					break;

				case 2:
					if ( (memcmp(m_pMapList[i]->m_cName, sideMap[ARESDEN], 7) == 0) ||
						(memcmp(m_pMapList[i]->m_cName, sideMap[ELVINE],  6) == 0) ||
						(memcmp(m_pMapList[i]->m_cName, "elvfarm", 7) == 0) ||
						(memcmp(m_pMapList[i]->m_cName, "arefarm", 7) == 0) ) {

							iTotalMob = 0;
					}
					break;
				}
				m_bIsSpecialEventTime = FALSE;
			}

			for (j = 0; j < iTotalMob; j++) {
				iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
				if (iNamingValue != -1) {

					ZeroMemory(cName_Slave, sizeof(cName_Slave));
					wsprintf(cName_Slave, "XX%d", iNamingValue);
					cName_Slave[0] = '_';
					cName_Slave[1] = i + 65;

					cSA = 0;
					if (iFirmSAType == NULL) {
						if (dice(1,100) <= iProbSA) cSA = _cGetSpecialAbility(iKindSA);
					}
					else cSA = (char)iFirmSAType;

					if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[i]->m_cName, cSA, MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
						m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
					}
					else {

						bSetNpcFollowMode(cName_Slave, cName_Master, OWNERTYPE_NPC);
					}
				}
			}
		}
		// random mob generator	^

		// spot mob generator 
		if ( (m_pMapList[i] != NULL) && ((m_pMapList[i]->m_iMaximumObject) > m_pMapList[i]->m_iTotalActiveObject) ) {
			for (j = 1; j < MAXSPOTMOBGENERATOR; j++)
				if ( (dice(1,3) == 2) && (m_pMapList[i]->m_stSpotMobGenerator[j].bDefined == TRUE) &&
					(m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs > m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs) ) {
						iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
						if (iNamingValue != -1) {

							ZeroMemory(cNpcName, sizeof(cNpcName));
							switch (m_pMapList[i]->m_stSpotMobGenerator[j].iMobType) {
							case 10:  strcpy(cNpcName,"Slime");        iProbSA = 5;  iKindSA = 1; break;
							case 16:  strcpy(cNpcName,"Giant-Ant");    iProbSA = 10; iKindSA = 2; break;
							case 14:  strcpy(cNpcName,"Orc");          iProbSA = 15; iKindSA = 1; break;
							case 18:  strcpy(cNpcName,"Zombie");       iProbSA = 15; iKindSA = 3; break;
							case 11:  strcpy(cNpcName,"Skeleton");     iProbSA = 35; iKindSA = 8; break;
							case 6:   strcpy(cNpcName,"Orc-Mage");     iProbSA = 30; iKindSA = 7; break;
							case 17:  strcpy(cNpcName,"Scorpion");     iProbSA = 15; iKindSA = 3; break;
							case 12:  strcpy(cNpcName,"Stone-Golem");  iProbSA = 25; iKindSA = 5; break;
							case 13:  strcpy(cNpcName,"Cyclops");      iProbSA = 35; iKindSA = 8; break;
							case 22:  strcpy(cNpcName,"Amphis");       iProbSA = 20; iKindSA = 3; break;
							case 23:  strcpy(cNpcName,"Clay-Golem");   iProbSA = 20; iKindSA = 5; break;
							case 24:  strcpy(cNpcName,"Guard-Aresden");iProbSA = 20; iKindSA = 1; break;
							case 25:  strcpy(cNpcName,"Guard-Elvine"); iProbSA = 20; iKindSA = 1; break;
							case 26:  strcpy(cNpcName,"Guard-Neutral");iProbSA = 20; iKindSA = 1; break;
							case 27:  strcpy(cNpcName,"Hellbound");    iProbSA = 20; iKindSA = 1; break;
							case 28:  strcpy(cNpcName,"Troll");			 iProbSA = 20; iKindSA = 1; break;
							case 29:  strcpy(cNpcName,"Orge");         iProbSA = 20; iKindSA = 1; break;
							case 30:  strcpy(cNpcName,"Liche");        iProbSA = 30; iKindSA = 8; break;
							case 31:  strcpy(cNpcName,"Demon");        iProbSA = 20; iKindSA = 8; break;
							case 32:  strcpy(cNpcName,"Unicorn");      iProbSA = 35; iKindSA = 7; break;
							case 33:  strcpy(cNpcName,"WereWolf");     iProbSA = 25; iKindSA = 1; break;
							case 34:  strcpy(cNpcName,"Dummy");        iProbSA = 5;  iKindSA = 1; break;
							case 35:  strcpy(cNpcName,"Attack-Dummy"); iProbSA = 5;  iKindSA = 1; break;
							case 48:  strcpy(cNpcName,"Stalker");      iProbSA = 20; iKindSA = 3; break;
							case 49:  strcpy(cNpcName,"Hellclaw");	   iProbSA = 20; iKindSA = 8; break;
							case 50:  strcpy(cNpcName,"Tigerworm");    iProbSA = 20; iKindSA = 8; break;
							case 52:  strcpy(cNpcName,"Gagoyle");     iProbSA = 20; iKindSA = 8; break;
							case 53:  strcpy(cNpcName,"Beholder");      iProbSA = 20; iKindSA = 8; break;
							case 54:  strcpy(cNpcName,"Dark-Elf");      iProbSA = 20; iKindSA = 8; break;
							case 57:   strcpy(cNpcName,"Giant-Frog");		iProbSA = 10; iKindSA = 2; break;
							case 58:   strcpy(cNpcName,"Mountain-Giant");	iProbSA = 25; iKindSA = 1; break;
							case 59:   strcpy(cNpcName,"Ettin");			iProbSA = 20; iKindSA = 8; break;
							case 60:   strcpy(cNpcName,"Cannibal-Plant");	iProbSA = 20; iKindSA = 5; break;
							case 61:   strcpy(cNpcName,"Rudolph");			iProbSA = 20; iKindSA = 1; break;
							case 62:   strcpy(cNpcName,"DireBoar");			iProbSA = 20; iKindSA = 1; break;
							case 63:   strcpy(cNpcName,"Frost");			iProbSA = 20; iKindSA = 8; break;
							case 65:   strcpy(cNpcName,"Ice-Golem");		iProbSA = 20; iKindSA = 8; break;
							case 66:   strcpy(cNpcName,"Wyvern");			iProbSA = 20; iKindSA = 10; break;
							case 55:   strcpy(cNpcName,"Rabbit");			iProbSA = 20; iKindSA = 1; break;
							case 67:   strcpy(cNpcName,"McGaffin");			iProbSA = 20; iKindSA = 1; break;
							case 68:   strcpy(cNpcName,"Perry");			iProbSA = 20; iKindSA = 1; break;
							case 69:   strcpy(cNpcName,"Devlin");			iProbSA = 20; iKindSA = 1; break;
							case 73:   strcpy(cNpcName,"Fire-Wyvern");		iProbSA = 20; iKindSA = 10;  break;
							case 70:   strcpy(cNpcName,"Barlog");			iProbSA = 20; iKindSA = 1;  break;
							case 80:   strcpy(cNpcName,"Tentocle");			iProbSA = 20; iKindSA = 1;  break;
							case 71:   strcpy(cNpcName,"Centaurus");			iProbSA = 20; iKindSA = 1;  break;
							case 75:   strcpy(cNpcName,"Giant-Lizard");		iProbSA = 20; iKindSA = 1;  break;
							case 78:   strcpy(cNpcName,"Minotaurs");			iProbSA = 20; iKindSA = 1;  break;
							case 81:   strcpy(cNpcName,"Abaddon");			iProbSA = 20; iKindSA = 10;  break;
							case 72:   strcpy(cNpcName,"Claw-Turtle");		iProbSA = 20; iKindSA = 1;  break;
							case 74:   strcpy(cNpcName,"Giant-Crayfish");	iProbSA = 20; iKindSA = 1;  break;
							case 76:   strcpy(cNpcName,"Giant-Plant");		iProbSA = 20; iKindSA = 1;  break;
							case 77:   strcpy(cNpcName,"MasterMage-Orc");	iProbSA = 20; iKindSA = 1;  break;
							case 79:   strcpy(cNpcName,"Nizie");				iProbSA = 20; iKindSA = 1; break;
							case 82:   strcpy(cNpcName,"Guard-Istria"); iProbSA = 20; iKindSA = 1; break;
							default:
								strcpy(cNpcName, "Orc");
								iProbSA = 15; 
								iKindSA = 1; 
							break;
							}

							bFirmBerserk = FALSE;
							if ((m_pMapList[i]->m_cRandomMobGeneratorLevel >= 9) &&(iMapLevel >= 4) && (dice(1,3) == 1)  ) bFirmBerserk = TRUE;

							ZeroMemory(cName_Master, sizeof(cName_Master));
							wsprintf(cName_Master, "XX%d", iNamingValue);
							cName_Master[0] = '_';
							cName_Master[1] = i + 65;

							cSA = 0;
							if ((m_pMapList[i]->m_stSpotMobGenerator[j].iMobType != 34) && (dice(1,100) <= iProbSA)) {
								cSA = _cGetSpecialAbility(iKindSA);
							}

							switch (m_pMapList[i]->m_stSpotMobGenerator[j].cType) {
							case 1:
								// RANDOMAREA
								if (bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, cSA, MOVETYPE_RANDOMAREA, &pX, &pY, cWaypoint, &m_pMapList[i]->m_stSpotMobGenerator[j].rcRect, j, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
									//PutLogList("SpotMobGenerator(RANDOMAREA) Fail! Cannot locate mob.");
									m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
								}
								else {
									//wsprintf(g_cTxt, "SpotMobGenerator(RANDOMAREA) - Map:%d TotalActiveObject:%d Mob:%s ", i, m_pMapList[i]->m_iTotalActiveObject, cNpcName );
									//PutLogList(g_cTxt);
									m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
								}
								break;

							case 2:
								// RANDOMWAYPOINT
								if (bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, cSA, MOVETYPE_RANDOMWAYPOINT, NULL, NULL, m_pMapList[i]->m_stSpotMobGenerator[j].cWaypoint, NULL, j, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
									//PutLogList("SpotMobGenerator(RANDOMWAYPOINT) Fail! Cannot locate mob.");
									m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
								}
								else {
									//wsprintf(g_cTxt, "SpotMobGenerator(RANDOMWAYPOINT) - Map:%d TotalActiveObject:%d Mob:%s (%d %d)", i, m_pMapList[i]->m_iTotalActiveObject, cNpcName, pX, pY);
									//PutLogList(g_cTxt);
									m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
								}
								break;
							}
						}
				}
		}
		// spot mob generator ^
	}
}

void CGame::DeleteNpc(int iNpcH)
{
	int  i, iNamingValue, iNumItem, iItemID, iItemIDs[MAX_NPCITEMDROP], iSlateID;
	char cTmp[21], cItemName[21];
	class CItem * pItem, * pItem2;
	DWORD dwCount, dwTime;
   Point ItemPositions[MAX_NPCITEMDROP];
	char cTemp[256];
	SYSTEMTIME SysTime;

	CNpc *& npc = m_pNpcList[iNpcH];
	if (!npc) return;

	dwTime = timeGetTime();

	//Init number of items to 1 unless its a multidrop;
	iNumItem = 0;
	iItemID = 0; // No current item

	SendEventToNearClient_TypeA(iNpcH, OWNERTYPE_NPC, MSGID_EVENT_LOG, MSGTYPE_REJECT, NULL, NULL, NULL);
	m_pMapList[npc->m_cMapIndex]->ClearOwner(/*11,*/ iNpcH, OWNERTYPE_NPC, npc->m_sX, npc->m_sY);

	ZeroMemory(cTmp, sizeof(cTmp));
	strcpy(cTmp, (char *)(npc->m_cName + 2));

	iNamingValue = atoi(cTmp);


	m_pMapList[npc->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
	m_pMapList[npc->m_cMapIndex]->m_iTotalActiveObject--;

	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalActiveObject == 0) 
	{	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iApocalypseMobGenType == 1)
		{	for (int i = 1; i < MAXCLIENTS; i++) 
				{	if (m_pClientList[i] == NULL) return;
					Notify_ApocalypseGateState(i);		
				} 
		}
		if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iApocalypseMobGenType == 2)
		{	GenerateApocalypseBoss(m_pNpcList[iNpcH]->m_cMapIndex);
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iApocalypseMobGenType = 1;	
	}	}



	if ( npc->m_iSpotMobIndex != NULL )
		m_pMapList[npc->m_cMapIndex]->m_stSpotMobGenerator[npc->m_iSpotMobIndex].iCurMobs--;

	RemoveFromTarget(iNpcH, OWNERTYPE_NPC);

	switch (npc->m_sType) 
	{
	case NPC_AGT:
	case NPC_CGT:
	case NPC_MS:
	case NPC_DT:
	case NPC_MANASTONE:
		m_pMapList[npc->m_cMapIndex]->bRemoveCrusadeStructureInfo(npc->m_sX, npc->m_sY);

		for (i = 0; i < MAXGUILDS; i++) {
			if (m_pGuildTeleportLoc[i].m_iV1 == npc->m_iGuildGUID) {
				m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				m_pGuildTeleportLoc[i].m_iV2--;
				if (m_pGuildTeleportLoc[i].m_iV2 < 0) m_pGuildTeleportLoc[i].m_iV2 = 0;
				break;
			}
		}
		break;

	case NPC_LWB:
	case NPC_GHK:
	case NPC_GHKABS:
	case NPC_TK:
	case NPC_BG:
	case NPC_CP:
		for (i = 0; i < MAXGUILDS; i++) {
			if (m_pGuildTeleportLoc[i].m_iV1 == npc->m_iGuildGUID) {
				m_pGuildTeleportLoc[i].m_iNumSummonNpc--;
				if (m_pGuildTeleportLoc[i].m_iNumSummonNpc < 0) m_pGuildTeleportLoc[i].m_iNumSummonNpc = 0;
				break;
			}
		}
		break;

	case NPC_CROPS:
		m_pMapList[npc->m_cMapIndex]->bRemoveCropsTotalSum();
		break;
	}


	RemoveFromDelayEventList(iNpcH, OWNERTYPE_NPC, NULL);

	int iItemprobability = 45 ;

	if(m_iMiddlelandMapIndex != -1 && m_iMiddlelandMapIndex == npc->m_cMapIndex)
	{
		iItemprobability -= 5 ;
	}

	if(iItemprobability < 15)
		iItemprobability = 15;

#ifndef NO_SECONDDROP
	if (!npc->m_bIsSummoned) 
	{
		pItem = new CItem;
		ZeroMemory(cItemName, sizeof(cItemName));

		if(m_drops.HasSecondaryDrop(npc))
		{
			if(m_drops.GetSecDropNum(npc->m_sType) == 1)
				iItemID = m_drops.Roll(npc, ONNPCDELETE);
			else
				iNumItem = RollMultiple( npc,ITEMSPREAD_FIXED, 4, iItemIDs, ItemPositions);
		}

		dwCount = 1;


		if (iNumItem > 0) {
			GetLocalTime(&SysTime);
			wsprintf(cTemp, "%d%02d%", SysTime.wMonth, SysTime.wDay);
			for(int j = 0; j < iNumItem; j++){
				if (pItem == NULL) {
					pItem = new class CItem;
				}
				if (_bInitItemAttr(pItem, iItemIDs[j]) == FALSE ||
					m_pMapList[ npc->m_cMapIndex ]->bGetIsMoveAllowedTile(ItemPositions[j].x, ItemPositions[j].y) == FALSE) {
						delete pItem;
						pItem = NULL;
				}
				else {
					if (iItemIDs[j] == ITEM_GOLD)
					{			
						if(npc->dwGoldDropValue <= 4) pItem->m_dwCount = dice(1, npc->dwGoldDropValue);
						else
							switch(dice(1,2))
						{
							case 1:
								pItem->m_dwCount = (DWORD)(npc->dwGoldDropValue + dice(1, npc->dwGoldDropValue/5));
								break;

							case 2:
								pItem->m_dwCount = (DWORD)(npc->dwGoldDropValue - dice(1, npc->dwGoldDropValue/5));
								break;
						}
					}
					else
						pItem->m_dwCount = dwCount;

					pItem->m_sTouchEffectType   = ITET_ID;
					pItem->m_sTouchEffectValue1 = dice(1,100000);
					pItem->m_sTouchEffectValue2 = dice(1,100000);
					pItem->m_sTouchEffectValue3 = (short)dwTime;
					if(!m_pMapList[ npc->m_cMapIndex ]->bSetItem(
						ItemPositions[j].x, ItemPositions[j].y, pItem))
					{
						delete pItem;
					}
					else
					{
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, npc->m_cMapIndex,
							ItemPositions[j].x, ItemPositions[j].y,	pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
						_bItemLog(ITEMLOG_NEWGENDROP, NULL, npc->m_cNpcName, pItem);
						AddGroundItem(pItem, ItemPositions[j].x, ItemPositions[j].y, npc->m_cMapIndex, TILECLEANTIMEPLAYER);
					}
					pItem = NULL;
				}
			}
		}
		else{
			if (iItemID == 0 && npc->dwGoldDropValue > 0 && dice(1,50) == 13) {
				iItemID = ITEM_GOLD;
				if(npc->dwGoldDropValue <= 4) dwCount = dice(1, npc->dwGoldDropValue);
				else
					switch(dice(1,2))
				{
					case 1:
						dwCount = (DWORD)(npc->dwGoldDropValue + dice(1, npc->dwGoldDropValue/5));
						break;

					case 2:
						dwCount = (DWORD)(npc->dwGoldDropValue - dice(1, npc->dwGoldDropValue/5));
						break;
				}
			}
			if (_bInitItemAttr(pItem, iItemID) == FALSE) {
				delete pItem;
				pItem = NULL;
			}
			else {

				pItem->m_dwCount = dwCount;

				pItem->m_sTouchEffectType   = ITET_ID;
				pItem->m_sTouchEffectValue1 = dice(1,100000);
				pItem->m_sTouchEffectValue2 = dice(1,100000);
#ifdef LOGTIME
				pItem->m_sTouchEffectValue3 = dwTime;
#else 
				SYSTEMTIME SysTime;
				char cTemp[256];
				GetLocalTime(&SysTime);
				ZeroMemory(cTemp, sizeof(cTemp));
				//			wsprintf(cTemp, "%d%02d%02d",  (short)SysTime.wMonth, (short)SysTime.wDay,(short) SysTime.wHour);
				wsprintf(cTemp, "%d%02d%",  (short)SysTime.wMonth, (short)SysTime.wDay);

				pItem->m_sTouchEffectValue3 = atoi(cTemp);
#endif
				if(!m_pMapList[ npc->m_cMapIndex ]->bSetItem(
					npc->m_sX, npc->m_sY, pItem))
				{
					delete pItem;
				}
				else
				{					
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, npc->m_cMapIndex,
						npc->m_sX, npc->m_sY,
						pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 

					_bItemLog(ITEMLOG_NEWGENDROP, 0, npc->m_cNpcName, pItem);
					AddGroundItem(pItem, npc->m_sX, npc->m_sY, npc->m_cMapIndex, TILECLEANTIMEPLAYER);
				}
				pItem = NULL;
			}
		}

		if (dice(1, 100000) < 60) {
			pItem2 = new class CItem;
			switch(dice(1,4)){
				case 1:	iSlateID = 868; break;
				case 2: iSlateID = 869; break;
				case 3: iSlateID = 870; break;
				case 4: iSlateID = 871; break;
			}
			if (_bInitItemAttr(pItem2, iSlateID) == FALSE) {
				delete pItem2;
				pItem2 = NULL;
			}
			else {
				pItem2->m_dwCount = 1;

				pItem2->m_sTouchEffectType   = ITET_ID;
				pItem2->m_sTouchEffectValue1 = dice(1,100000);
				pItem2->m_sTouchEffectValue2 = dice(1,100000);
				pItem2->m_sTouchEffectValue3 = (short)dwTime;

				if(!m_pMapList[ npc->m_cMapIndex ]->bSetItem(
					npc->m_sX, npc->m_sY, pItem2))
				{
					delete pItem2;
				}
				else
				{
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, npc->m_cMapIndex,
						npc->m_sX, npc->m_sY, pItem2->m_sSprite, pItem2->m_sSpriteFrame, pItem2->m_cItemColor);
					_bItemLog(ITEMLOG_NEWGENDROP, NULL, npc->m_cNpcName, pItem2);
					AddGroundItem(pItem, npc->m_sX, npc->m_sY, npc->m_cMapIndex, TILECLEANTIMEPLAYER);
				}
				pItem2 = NULL;
			}
		}
	}
#endif // NO_SECONDDROP

	delete npc;
	npc = NULL;
}

void CGame::RequestFullObjectData(int iClientH, char *pData, int objectID)
{
	DWORD * dwp;
	WORD  * wp, wObjectID;
	char  * cp, cData[100];
	short * sp, sX, sY;
	int   * ip, iRet, iTemp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if(objectID == -1){
		wp = (WORD *)(pData + INDEX2_MSGTYPE);
		wObjectID = *wp;
	}else
		wObjectID = (WORD) objectID;

	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(cData + INDEX4_MSGID);
	*dwp = MSGID_EVENT_MOTION;
	wp   = (WORD *)(cData + INDEX2_MSGTYPE);
	*wp  = OBJECTSTOP;

	cp = (char *)(cData + INDEX2_MSGTYPE + 2);

	if (wObjectID < 10000) {

		if ( (wObjectID == 0) || (wObjectID >= MAXCLIENTS) ) return;
		if (m_pClientList[wObjectID] == NULL) return;

		wp  = (WORD *)cp;
		*wp = wObjectID;			// ObjectID
		cp += 2;
		sp  = (short *)cp;
		sX  = m_pClientList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;
		sp  = (short *)cp;
		sY  = m_pClientList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sType;
		cp += 2;
		*cp = m_pClientList[wObjectID]->m_cDir;
		cp++;
		memcpy(cp, m_pClientList[wObjectID]->m_cCharName, 10);
		cp += 10;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr1;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr2;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr3;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr4;
		cp += 2;
		ip = (int *)cp;
		*ip = m_pClientList[wObjectID]->m_iApprColor;
		cp += 4;

		ip  = (int *)cp;

		iTemp = m_pClientList[wObjectID]->m_iStatus;
		if(_bGetIsPlayerHostile(iClientH,wObjectID) && wObjectID != iClientH && m_pClientList[iClientH]->m_iAdminUserLevel == 0)
			iTemp &= STATUS_ENEMYFLAGS;

		*ip = iTemp;
		cp += 4;

		if (m_pClientList[wObjectID]->m_bIsKilled == TRUE) 
			*cp = 1;
		else *cp = 0;
		cp++;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 43); 
	}
	else {

		if ( ((wObjectID - 10000) == 0) || ((wObjectID - 10000) >= MAXNPCS) ) return;
		if (m_pNpcList[wObjectID - 10000] == NULL) return;

		wp  = (WORD *)cp;
		*wp = wObjectID;
		cp += 2;

		wObjectID -= 10000;

		sp  = (short *)cp;
		sX  = m_pNpcList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;
		sp  = (short *)cp;
		sY  = m_pNpcList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pNpcList[wObjectID]->m_sType;
		cp += 2;
		*cp = m_pNpcList[wObjectID]->m_cDir;
		cp++;
		memcpy(cp, m_pNpcList[wObjectID]->m_cName, 5);
		cp += 5;
		sp  = (short *)cp;
		*sp = m_pNpcList[wObjectID]->m_sAppr2;
		cp += 2;

		ip  = (int *)cp;
		*ip = m_pNpcList[wObjectID]->m_iStatus;
		cp += 4;

		if (m_pNpcList[wObjectID]->m_bIsKilled == TRUE) 
			*cp = 1;
		else *cp = 0;
		cp++;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 27); 
	}

	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
}

int CGame::_iGetArrowItemIndex(int iClientH)
{
	register int i;

	if (m_pClientList[iClientH] == NULL) return -1;

	for (i = 0; i < MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
			if ( (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == ITEMTYPE_ARROW) &&
				(m_pClientList[iClientH]->m_pItemList[i]->m_dwCount > 0) )
				return i;
		}

	return -1;
}

void CGame::ItemDepleteHandler(int iClientH, short sItemIndex, bool bIsUseItemResult, bool bIsLog)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((sItemIndex < 0) || (sItemIndex >= MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;

	if ((bIsLog == TRUE) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != ITEMTYPE_CONSUME) 
		&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != ITEMTYPE_EAT) 
		&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != ITEMTYPE_USE_DEPLETE) 
		&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != ITEMTYPE_USE_DEPLETE_DEST)
		&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != ITEMTYPE_MATERIAL)
		&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != ITEM_ICESTORMMANUAL)
		&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != ITEM_MASSFIRESTRIKEMANUAL)
		&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != ITEM_BLOODYSHOCKWMANUAL))
		_bItemLog(ITEMLOG_DEPLETE, iClientH,(int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
	ReleaseItemHandler(iClientH, sItemIndex, TRUE);

	SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMDEPLETED_ERASEITEM, sItemIndex, (int)bIsUseItemResult, NULL, NULL);


	delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
	m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;

	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;

	// !!! BUG POINT

	m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

	iCalcTotalWeight(iClientH);
}

void CGame::UseItemHandler(int iClientH, short sItemIndex, short dX, short dY, short sDestItemID)
{
	int iTemp, iMax, iV1, iV2, iV3, iSEV1, iEffectResult = 0;
	DWORD dwTime;
	short sTemp, sTmpType, sTmpAppr1;
	DWORD dwGUID;
	dwTime = timeGetTime();

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((sItemIndex < 0) || (sItemIndex >= MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;

	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == ITEMTYPE_USE_DEPLETE) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == ITEMTYPE_USE_PERM) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == ITEMTYPE_ARROW) || 
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == ITEMTYPE_EAT) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == ITEMTYPE_USE_SKILL) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == ITEMTYPE_USE_DEPLETE_DEST) ) {
	}
	else return;

	if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == ITEMTYPE_USE_DEPLETE) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == ITEMTYPE_EAT) ) {


		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case ITEMEFFECTTYPE_WARM: 


			if (m_pClientList[iClientH]->m_cMagicEffectStatus[ MAGICTYPE_ICE ] == 1) {
				//	SetStatusFlag(iClientH, OWNERTYPE_PLAYER, FALSE);

				RemoveFromDelayEventList(iClientH, OWNERTYPE_PLAYER, MAGICTYPE_ICE);

				RegisterDelayEvent(DELAYEVENTTYPE_MAGICRELEASE, MAGICTYPE_ICE, dwTime + (1*1000), 
					iClientH, OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);

				//				SendNotifyMsg(NULL, iClientH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_ICE, NULL, NULL, NULL);
			}

			m_pClientList[iClientH]->m_dwWarmEffectTime = dwTime;
			break;

		case ITEMEFFECTTYPE_LOTTERY:

			iTemp = dice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1);
			if (iTemp == dice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1)) {

			}
			else {

			}
			break;

		case ITEMEFFECTTYPE_SLATES:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_ANCIENTTABLET) {
					if (m_astoria.get() && m_pClientList[iClientH]->m_cMapIndex == m_iAstoriaMapIndex) return;
					switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2){
					case 2: // Berserk slate
						if(m_pClientList[iClientH]->m_cMagicEffectStatus[ MAGICTYPE_BERSERK ])
							RemoveFromDelayEventList(iClientH, OWNERTYPE_PLAYER, MAGICTYPE_BERSERK);

						m_pClientList[iClientH]->m_cMagicEffectStatus[ MAGICTYPE_BERSERK ] = TRUE;
						m_pClientList[iClientH]->SetStatusFlag(STATUS_BERSERK, TRUE);
						RegisterDelayEvent(DELAYEVENTTYPE_MAGICRELEASE, MAGICTYPE_BERSERK, dwTime + (1000 * 600),
							iClientH, OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
						SendNotifyMsg(NULL, iClientH, NOTIFY_MAGICEFFECTON, MAGICTYPE_BERSERK, 1, NULL, NULL);
						break;

					case 1: // Invincible slate
					case 3: // Mana slate
					case 4: // Exp slate
						SetSlateFlag(iClientH, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2, TRUE);
						RegisterDelayEvent(DELAYEVENTTYPE_ANCIENT_TABLET, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2, 
							dwTime + (1000 * 600), iClientH, OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
						switch(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2) {
						case 1:	iEffectResult = 4;	break;
						case 3:	iEffectResult = 5;	break;
						case 4:	iEffectResult = 6;	break;
						}
					}
				}
			}
			break;

		case ITEMEFFECTTYPE_HP:
			iMax = m_pClientList[iClientH]->GetMaxHP();
			if (m_pClientList[iClientH]->m_iHP < iMax) {
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iHP += (dice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iHP > iMax) m_pClientList[iClientH]->m_iHP = iMax;
				if (m_pClientList[iClientH]->m_iHP <= 0)   m_pClientList[iClientH]->m_iHP = 1;

				iEffectResult = 1;
			}
			break;

		case ITEMEFFECTTYPE_MP:
			iMax = m_pClientList[iClientH]->GetMaxMP();
			if (m_pClientList[iClientH]->m_iMP < iMax) {

				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else 
				{
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iMP += (dice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iMP > iMax) 
					m_pClientList[iClientH]->m_iMP = iMax;

				iEffectResult = 2;
			}
			break;

		case ITEMEFFECTTYPE_SP:
			iMax = m_pClientList[iClientH]->GetMaxSP();

			if (m_pClientList[iClientH]->m_iSP < iMax) {

				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iSP += (dice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iSP > iMax) 
					m_pClientList[iClientH]->m_iSP = iMax;

				iEffectResult = 3;
			}

			if (m_pClientList[iClientH]->m_bIsPoisoned == TRUE) {

				m_pClientList[iClientH]->m_bIsPoisoned = FALSE;

				m_pClientList[iClientH]->SetStatusFlag(STATUS_POISON, FALSE);
				SendNotifyMsg(NULL, iClientH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_POISON, NULL, NULL, NULL);
			}
			break;

		case ITEMEFFECTTYPE_HPSTOCK:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;

			m_pClientList[iClientH]->m_iHPstock += dice(iV1, iV2) + iV3;
			if (m_pClientList[iClientH]->m_iHPstock < 0)   m_pClientList[iClientH]->m_iHPstock = 0;
			if (m_pClientList[iClientH]->m_iHPstock > 500) m_pClientList[iClientH]->m_iHPstock = 500;

			m_pClientList[iClientH]->m_iHungerStatus += dice(iV1, iV2) + iV3;
			if (m_pClientList[iClientH]->m_iHungerStatus > 100) m_pClientList[iClientH]->m_iHungerStatus = 100;
			if (m_pClientList[iClientH]->m_iHungerStatus < 0)   m_pClientList[iClientH]->m_iHungerStatus = 0;
			break;

		case ITEMEFFECTTYPE_STUDYSKILL:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			iSEV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;

			if (iSEV1 == 0) {
				TrainSkillResponse(TRUE, iClientH, iV1, iV2);
			}
			else {
				TrainSkillResponse(TRUE, iClientH, iV1, iSEV1);
			}
			break;

		case ITEMEFFECTTYPE_STUDYMAGIC:

			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			if (m_pMagicConfigList[iV1] != NULL) 
				RequestStudyMagicHandler(iClientH, m_pMagicConfigList[iV1]->m_cName, FALSE);
			break;

		case ITEMEFFECTTYPE_MAGIC:
			m_pClientList[iClientH]->RemoveMagicEffect(MAGICTYPE_INVISIBILITY);

			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:
				RequestTeleportHandler(iClientH, 1);
				break;

			case 2:
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 32, TRUE);
				break;

			case 3:
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == FALSE)
					PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 34, TRUE);
				break;

			case 4:

				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2) {
				case 1:
					if (memcmp(m_pClientList[iClientH]->m_cMapName, "bisle", 5) != 0) {
						ItemDepleteHandler(iClientH, sItemIndex, TRUE);
						RequestTeleportHandler(iClientH, 3, "bisle");
					}
					break;

				case 11:
				case 12:
				case 13:
				case 14:
				case 15:
				case 16:
				case 17:
				case 18:
				case 19:

					SYSTEMTIME SysTime;

					GetLocalTime(&SysTime);

					if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue1 != SysTime.wMonth) |
						(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue2 != SysTime.wDay) ||
						(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue3 <= SysTime.wHour) ) {

					}
					else {
						char cDestMapName[11];
						ZeroMemory(cDestMapName, sizeof(cDestMapName));
						wsprintf(cDestMapName, "fightzone%d", m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 - 10);
						if (memcmp(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10) != 0) {
							ItemDepleteHandler(iClientH, sItemIndex, TRUE);

							RequestTeleportHandler(iClientH, 3, cDestMapName);
						}
					}
					break;
				}
				break;
		
					case 5: // Heldenians scroll must be defined as ITEMTYPE_USE_PERM
					// Only Helnenian scrolls can be defined as ITEMTYPE_USE_PERM 
					// Scrolls not belonging to the user are depleted when entering function 
				if (   (m_bHeldenianMode)
					&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) 
					&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE)
					&& (strcmp(m_pClientList[iClientH]->m_cMapName, "GodH") != 0))
				{	memcpy(&dwGUID, &m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1, 4);					
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectType == ITET_UNIQUE_OWNER)
					{	if (dwGUID == m_dwHeldenianGUID)
						{	// Scrolls from current Heldenian can summon
							if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6 == -1)// -1 allows using with weapon shield equiped
								PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, TRUE,
									m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2); 
							else 
								PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, TRUE,
									m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 * -1); 
							m_pClientList[iClientH]->m_iWarContribution   += 300;
							if (m_pClientList[iClientH]->m_iWarContribution > MAXWARCONTRIBUTION)
								m_pClientList[iClientH]->m_iWarContribution = MAXWARCONTRIBUTION;
							if (m_pClientList[iClientH]->m_iWarContribution >= 256*128)
								SendNotifyMsg(NULL, iClientH, NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, (m_pClientList[iClientH]->m_iWarContribution %(256*128)), 1, NULL);
						}
						// But older scrolls will be depleted without effect!
						ItemDepleteHandler(iClientH, sItemIndex, TRUE);	
					}else
					{	// Not personal scrolls can summon and deplete scroll now
						if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6 == -1)// -1 allows using with weapon shield equiped
						PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, TRUE,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2); 
						else 
						PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, TRUE,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 * -1); 
						ItemDepleteHandler(iClientH, sItemIndex, TRUE);	
						return;
					}
				}else // No permanent scroll outside Special Heldenian summon scrolls
				{	if (!m_bHeldenianMode) ItemDepleteHandler(iClientH, sItemIndex, TRUE);	
					return;	
				}
			}
				break;

		case 20:
			if (m_pClientList[iClientH] == NULL) return;

			//m_pClientList[iClientH]->m_cSkillMastery[SKILL_MAGICRES] = 20;
			//SendNotifyMsg(NULL, iClientH, NOTIFY_SKILL, 3, m_pClientList[iClientH]->m_cSkillMastery[SKILL_MAGIC], NULL, NULL);
			break;

		case ITEMEFFECTTYPE_FIRMSTAMINAR:
			m_pClientList[iClientH]->m_iTimeLeft_FirmStamina += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStamina > 20*30) m_pClientList[iClientH]->m_iTimeLeft_FirmStamina = 20*30; 
			break;

		case ITEMEFFECTTYPE_CHANGEATTR:
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:
				m_pClientList[iClientH]->m_cHairColor++;
				if (m_pClientList[iClientH]->m_cHairColor > 15) m_pClientList[iClientH]->m_cHairColor = 0;

				sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
				m_pClientList[iClientH]->m_sAppr1 = sTemp;
				break;

			case 2:
				m_pClientList[iClientH]->m_cHairStyle++;
				if (m_pClientList[iClientH]->m_cHairStyle > 7) m_pClientList[iClientH]->m_cHairStyle = 0;

				sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
				m_pClientList[iClientH]->m_sAppr1 = sTemp;
				break;

			case 3:

				m_pClientList[iClientH]->m_cSkin++;
				if (m_pClientList[iClientH]->m_cSkin > 3)
					m_pClientList[iClientH]->m_cSkin = 1;

				if (m_pClientList[iClientH]->m_cSex == MALE)      sTemp = 1;
				else if (m_pClientList[iClientH]->m_cSex == FEMALE) sTemp = 4; 

				switch (m_pClientList[iClientH]->m_cSkin) {
				case 2:	sTemp += 1; break;
				case 3:	sTemp += 2; break;
				}
				m_pClientList[iClientH]->m_sType  = sTemp;
			break;

			case 4:
				sTemp = m_pClientList[iClientH]->m_sAppr3 & 0xFF0F;
				if (sTemp == 0) {

					if (m_pClientList[iClientH]->m_cSex == MALE) 
						m_pClientList[iClientH]->m_cSex = FEMALE;
					else m_pClientList[iClientH]->m_cSex = MALE;


					if (m_pClientList[iClientH]->m_cSex == MALE) {
						sTmpType = 1;
					}
					else if (m_pClientList[iClientH]->m_cSex == FEMALE) {
						sTmpType = 4; 
					}

					switch (m_pClientList[iClientH]->m_cSkin) {
					case 1:
						break;
					case 2:
						sTmpType += 1;
						break;
					case 3:
						sTmpType += 2;
						break;
					}

					sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
					m_pClientList[iClientH]->m_sType  = sTmpType;
					m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1; 
					//
				}
				break;

			case 5: 
				m_pClientList[iClientH]->m_cUnderwear++;
				if (m_pClientList[iClientH]->m_cUnderwear > 7) m_pClientList[iClientH]->m_cUnderwear = 0;

				sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
				m_pClientList[iClientH]->m_sAppr1 = sTemp;
				break;
			}

			SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTNULLACTION, NULL, NULL, NULL);
			break;
		}


		ItemDepleteHandler(iClientH, sItemIndex, TRUE);

		switch (iEffectResult) {
		case 1:
			SendNotifyMsg(NULL, iClientH, NOTIFY_HP, NULL, NULL, NULL, NULL);
			break;
		case 2:
			SendNotifyMsg(NULL, iClientH, NOTIFY_MP, NULL, NULL, NULL, NULL);
			break;
		case 3:
			SendNotifyMsg(NULL, iClientH, NOTIFY_SP, NULL, NULL, NULL, NULL);
			break;
		case 4: // Invincible
			SendNotifyMsg(NULL, iClientH, NOTIFY_SLATE_INVINCIBLE, NULL, NULL, NULL, NULL);
			break;
		case 5: // Mana
			SendNotifyMsg(NULL, iClientH, NOTIFY_SLATE_MANA, NULL, NULL, NULL, NULL);
			break;
		case 6: // EXP
			SendNotifyMsg(NULL, iClientH, NOTIFY_SLATE_EXP, NULL, NULL, NULL, NULL);
			break;
		default:
			break;
		}
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == ITEMTYPE_USE_DEPLETE_DEST) {

		if (_bDepleteDestTypeItemUseEffect(iClientH, dX, dY, sItemIndex, sDestItemID) == TRUE) 
			ItemDepleteHandler(iClientH, sItemIndex, TRUE); 
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == ITEMTYPE_ARROW) {
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == ITEMTYPE_USE_PERM) {
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType)
		{
		case ITEMEFFECTTYPE_SHOWLOCATION:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			switch (iV1) 
			{
			case 1:
				if (strcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ARESDEN]) == 0)
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 1, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ELVINE]) == 0)
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 2, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "middleland") == 0)
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 3, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, sideMap[NEUTRAL]) == 0)
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 4, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone2") == 0)
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 5, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone1") == 0)
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 6, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone4") == 0)
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 7, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone3") == 0)
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 8, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "arefarm") == 0)
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 9, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvfarm") == 0)
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 10, NULL, NULL);
				else 
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 0, NULL, NULL);
				break;
			}
			break;
		}
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == ITEMTYPE_USE_SKILL) {

		if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) || 
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) ||
			(m_pClientList[iClientH]->m_bSkillUsingStatus[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] == TRUE) ) {
				return;
		}
		else {
			if ( m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan != 0 ) {
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan--;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMLIFESPANEND, EQUIPPOS_NONE, sItemIndex, NULL, NULL);
				}
				else {
					int iSkillUsingTimeID = (int)timeGetTime();

					RegisterDelayEvent(DELAYEVENTTYPE_USEITEM_SKILL, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill, 
						dwTime + m_pSkillConfigList[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]->m_sValue2*1000, 
						iClientH, OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_cMapIndex, dX, dY, 
						m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ], iSkillUsingTimeID, NULL);

					m_pClientList[iClientH]->m_bSkillUsingStatus[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] = TRUE;
					m_pClientList[iClientH]->m_iSkillUsingTimeID[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] = iSkillUsingTimeID;
				}
			}
		}
	}
}


void CGame::Effect_Damage_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3, bool bExp, int iAttr)
{
	int iPartyID, iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iMaxSuperAttack;
	char cAttackerSide, cDamageMoveDir;
	DWORD dwTime;
	register double dTmp1, dTmp2, dTmp3;
	short sAtkX, sAtkY, sTgtX, sTgtY, dX, dY;

	if (cAttackerType == OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	if (cAttackerType == OWNERTYPE_NPC)
		if (m_pNpcList[sAttackerH] == NULL) return;

	dwTime = timeGetTime();

	iDamage = dice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	iPartyID = 0;

	switch (cAttackerType) {
	case OWNERTYPE_PLAYER:
		dTmp1 = (double)iDamage;
		if (m_pClientList[sAttackerH]->GetMag() <= 0)
			dTmp2 = 1.0f;
		else dTmp2 = (double)m_pClientList[sAttackerH]->GetMag();

		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 +0.5f);

		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;

		iDamage += iDamage * m_pClientList[sAttackerH]->m_addMagicDmgPct/100;

		if (iDamage <= 0) iDamage = 0;

		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
			iDamage += iDamage/3;

		if ((cTargetType == OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) 
		{
			if (m_pClientList[sAttackerH]->m_iLevel <= 80)
			{
				iDamage += (iDamage* 7)/10 ;
			} 
			else if (m_pClientList[sAttackerH]->m_iLevel <= 100)
			{
				iDamage += iDamage/2;

			} else iDamage += iDamage/3;
		}

		cAttackerSide = m_pClientList[sAttackerH]->m_side;
		sAtkX = m_pClientList[sAttackerH]->m_sX;
		sAtkY = m_pClientList[sAttackerH]->m_sY;

		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_side;
		sAtkX = m_pNpcList[sAttackerH]->m_sX;
		sAtkY = m_pNpcList[sAttackerH]->m_sY;
		break;
	}

	switch (cTargetType) {
	case OWNERTYPE_PLAYER:

		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;

#ifdef SAMESIDETOWNPROTECT

		if ((m_pClientList[sTargetH]->m_iPKCount == 0) && (cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_side == cAttackerSide) && (m_pClientList[sTargetH]->m_iIsOnTown == NONPK)) return ;
#endif 
#ifdef BEGINNERTOWNPROTECT
		if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_iIsOnTown == NONPK)) return;
#endif
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > RAGPROTECTIONTIME) return;

		if (m_pMapList[ m_pClientList[sTargetH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return;

		if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;

		if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;

		if ((m_pClientList[sTargetH]->m_iStatus & STATUS_REDSLATE) != 0) return;

		if (cAttackerType == OWNERTYPE_PLAYER) {

			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) {
				iSideCondition = m_pClientList[sAttackerH]->GetPlayerRelationship(sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
				}
				else {
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {

						}
						else return;
					}
					else return;
				}
			}
			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}

		ClearSkillUsingStatus(sTargetH);

		switch (iAttr) {
		case 1:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 2:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 3:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 4:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		default: break;
		}

		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < MAXITEMS)) {


			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335: 				
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;

			case 337: 				
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;

			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;
			if (iRemainLife <= iDamage) {
				ItemDepleteHandler(sTargetH, iIndex, TRUE);
			}
			else {
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
			}
		}


		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2/100.0f)*dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}


		if (cTargetType == OWNERTYPE_PLAYER) {
			iDamage -= (dice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}

		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) && 
			(dice(1,10) < 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
				iDamage = 1;
		}

		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[MAGICTYPE_PROTECT] == MAGICPROTECT_PFM)
			iDamage *= 0.5;


		if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				// 
				return;
			}
		}

		m_pClientList[sTargetH]->m_iHP -= iDamage;
		m_pClientList[sTargetH]->m_lastDamageTime = dwTime;
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			g_clientList[sTargetH]->KilledHandler( sAttackerH, cAttackerType, iDamage);
		}
		else {
			if (iDamage > 0) {

				if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
					dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1/100.0f)*dTmp2 +1.0f;


					iTemp = (2*m_pClientList[sTargetH]->GetMag()) + (2*m_pClientList[sTargetH]->m_iLevel) + (m_pClientList[sTargetH]->GetInt()/2);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}


				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
					if (dice(1,100) < (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
						iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;

						SendNotifyMsg(NULL, sTargetH, NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
					}
				}

				SendNotifyMsg(NULL, sTargetH, NOTIFY_HP, NULL, NULL, NULL, NULL);

				SendEventToNearClient_TypeA(sTargetH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTDAMAGE, iDamage, NULL, NULL);


				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != TRUE) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(/*0,*/ sTargetH, OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}

				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) {

					// 1: Hold-Person 
					// 2: Paralize
					SendNotifyMsg(NULL, sTargetH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ], NULL, NULL);

					m_pClientList[sTargetH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
					RemoveFromDelayEventList(sTargetH, OWNERTYPE_PLAYER, MAGICTYPE_HOLDOBJECT);
				}
			}
		}

		sTgtX = m_pClientList[sTargetH]->m_sX;
		sTgtY = m_pClientList[sTargetH]->m_sY;
		break;

	case OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode == TRUE) && (cAttackerSide == m_pNpcList[sTargetH]->m_side)) return;

		sTgtX = m_pNpcList[sTargetH]->m_sX;
		sTgtY = m_pNpcList[sTargetH]->m_sY;

		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
		case 6: 
		return;

		case 4: 			
			if (sTgtX == sAtkX) {
				if (sTgtY == sAtkY) return;
				else if (sTgtY > sAtkY) cDamageMoveDir = 5;
				else if (sTgtY < sAtkY) cDamageMoveDir = 1;
			}
			else if (sTgtX > sAtkX) {
				if (sTgtY == sAtkY)     cDamageMoveDir = 3;
				else if (sTgtY > sAtkY) cDamageMoveDir = 4;
				else if (sTgtY < sAtkY) cDamageMoveDir = 2;
			}
			else if (sTgtX < sAtkX) {
				if (sTgtY == sAtkY)     cDamageMoveDir = 7;
				else if (sTgtY > sAtkY) cDamageMoveDir = 6;
				else if (sTgtY < sAtkY) cDamageMoveDir = 8;
			}

			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
				cDamageMoveDir = dice(1,8);
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) return;
			}

			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(/*5,*/ sTargetH, OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);

			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX   = dX;
			m_pNpcList[sTargetH]->m_sY   = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

			SendEventToNearClient_TypeA(sTargetH, OWNERTYPE_NPC, MSGID_EVENT_MOTION, OBJECTMOVE, NULL, NULL, NULL);

			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {

				cDamageMoveDir = dice(1,8);
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) return;
			}

			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(/*5,*/ sTargetH, OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);

			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX   = dX;
			m_pNpcList[sTargetH]->m_sY   = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

			SendEventToNearClient_TypeA(sTargetH, OWNERTYPE_NPC, MSGID_EVENT_MOTION, OBJECTMOVE, NULL, NULL, NULL);

			if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType) == TRUE) {
				DeleteNpc(sTargetH);
			}
			return;
		}

		if (cAttackerType == OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if (m_pClientList[sAttackerH]->IsNeutral() || (m_pNpcList[sTargetH]->m_side == m_pClientList[sAttackerH]->m_side)) return;
				break;
			}
		}

		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage)/100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[MAGICTYPE_PROTECT] == MAGICPROTECT_PFM)
			iDamage *= 0.5;

		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) {

			NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}
		else {

			switch (cAttackerType) {
			case OWNERTYPE_PLAYER:
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_side == cAttackerSide)) return ;
				break;

			case OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_side == m_pNpcList[sTargetH]->m_side) return;
				break;
			}

			SendEventToNearClient_TypeA(sTargetH, OWNERTYPE_NPC, MSGID_EVENT_MOTION, OBJECTDAMAGE, iDamage, NULL, NULL);

			if ((dice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {
				if ((cAttackerType == OWNERTYPE_NPC) && 
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_side == m_pNpcList[sTargetH]->m_side)) return;


				m_pNpcList[sTargetH]->m_cBehavior          = BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;


				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) {

					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
					RemoveFromDelayEventList(sTargetH, OWNERTYPE_NPC, MAGICTYPE_HOLDOBJECT);
				}

				// Crusade
				int iExp;

				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) && 
					(cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) ) {

						if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
							// Crusade
							iExp = iDamage;
							if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;



							if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
								dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
								dTmp2 = (double)iExp;
								dTmp3 = (dTmp1/100.0f)*dTmp2;
								iExp += (int)dTmp3;
							}


							if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
								switch (m_pNpcList[sTargetH]->m_sType) {
								case 55:
								case 56:
									iExp = 0 ;
									break ;
								default: break;
								}
							}

							if (bExp == TRUE) 
								GetExp(sAttackerH, iExp, TRUE); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //iDamage;
							else GetExp(sAttackerH, (iExp/2), TRUE); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(iDamage/2);
							m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
						}
						else {
							// Crusade
							iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
							if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;


							if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
								dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
								dTmp2 = (double)iExp;
								dTmp3 = (dTmp1/100.0f)*dTmp2;
								iExp += (int)dTmp3;
							}


							if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
								switch (m_pNpcList[sTargetH]->m_sType) {
								case 55:
								case 56:
									iExp = 0 ;
									break ;
								default: break;
								}
							}

							if (bExp == TRUE) 
								GetExp(sAttackerH, iExp, TRUE); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //m_pNpcList[sTargetH]->m_iNoDieRemainExp;
							else GetExp(sAttackerH, (iExp/2), TRUE); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(m_pNpcList[sTargetH]->m_iNoDieRemainExp/2);
							m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
						}
				}
			}
		}
		break;
	}
}

void CGame::Effect_Damage_Spot_DamageMove(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sAtkX, short sAtkY, short sV1, short sV2, short sV3, bool bExp, int iAttr)
{
	int iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iMaxSuperAttack;
	DWORD dwTime;
	char cAttackerSide, cDamageMoveDir;
	register double dTmp1, dTmp2, dTmp3;
	int iPartyID, iMoveDamage;
	short sTgtX, sTgtY;

	if (cAttackerType == OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	if (cAttackerType == OWNERTYPE_NPC)
		if (m_pNpcList[sAttackerH] == NULL) return;

	dwTime = timeGetTime();
	sTgtX = 0;
	sTgtY = 0;

	iDamage = dice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	iPartyID = 0;


	switch (cAttackerType) {
	case OWNERTYPE_PLAYER:
		dTmp1 = (double)iDamage;
		if (m_pClientList[sAttackerH]->GetMag() <= 0)
			dTmp2 = 1.0f;
		else dTmp2 = (double)m_pClientList[sAttackerH]->GetMag();

		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 +0.5f);
		if (iDamage <= 0) iDamage = 0;


		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;

		iDamage += iDamage * m_pClientList[sAttackerH]->m_addMagicDmgPct/100;


		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
			iDamage += iDamage/3;


		if ((cTargetType == OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) 
		{
			if (m_pClientList[sAttackerH]->m_iLevel <= 80)
			{
				iDamage += (iDamage* 7)/10 ;
			} 
			else if (m_pClientList[sAttackerH]->m_iLevel <= 100)
			{
				iDamage += iDamage/2;
			} else iDamage += iDamage/3;
		}

		cAttackerSide = m_pClientList[sAttackerH]->m_side;

		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_side;
		break;
	}

	switch (cTargetType) {
	case OWNERTYPE_PLAYER:

		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > RAGPROTECTIONTIME) return;


		if (m_pClientList[sTargetH]->m_cMapIndex == -1) return;
		if (m_pMapList[ m_pClientList[sTargetH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return;

		if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;

#ifdef SAMESIDETOWNPROTECT

		if ((m_pClientList[sTargetH]->m_iPKCount == 0) && (cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_side == cAttackerSide) && (m_pClientList[sTargetH]->m_iIsOnTown == NONPK)) return ;
#endif 
#ifdef BEGINNERTOWNPROTECT
		if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_iIsOnTown == NONPK)) return;
#endif

		if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;

		if ((m_pClientList[sTargetH]->m_iStatus & STATUS_REDSLATE) != 0) return;

		if (cAttackerType == OWNERTYPE_PLAYER) {

			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) {
				iSideCondition = m_pClientList[sAttackerH]->GetPlayerRelationship(sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {

				}
				else {
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {

						}
						else return;
					}
					else return;
				}
			}

			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}

		ClearSkillUsingStatus(sTargetH);

		switch (iAttr) {
			case 1:
				if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
					dTmp1 = (double)iDamage;
					dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
					dTmp3 = (dTmp2/100.0f)*dTmp1;
					iDamage = iDamage - (int)(dTmp3);
					if (iDamage < 0) iDamage = 0;
				}
				break;

			case 2:
				if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
					dTmp1 = (double)iDamage;
					dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
					dTmp3 = (dTmp2/100.0f)*dTmp1;
					iDamage = iDamage - (int)(dTmp3);
					if (iDamage < 0) iDamage = 0;
				}
				break;

			case 3:
				if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
					dTmp1 = (double)iDamage;
					dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
					dTmp3 = (dTmp2/100.0f)*dTmp1;
					iDamage = iDamage - (int)(dTmp3);
					if (iDamage < 0) iDamage = 0;
				}
				break;

			case 4:
				if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
					dTmp1 = (double)iDamage;
					dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
					dTmp3 = (dTmp2/100.0f)*dTmp1;
					iDamage = iDamage - (int)(dTmp3);
					if (iDamage < 0) iDamage = 0;
				}
				break;

			default: break;
		}

		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < MAXITEMS)) {


			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335: 				
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;

			case 337: 				
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;

			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;
			if (iRemainLife <= iDamage) {
				ItemDepleteHandler(sTargetH, iIndex, TRUE);
			}
			else {
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
			}
		}


		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2/100.0f)*dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}


		if (cTargetType == OWNERTYPE_PLAYER) {
			iDamage -= (dice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}

		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[MAGICTYPE_PROTECT] == MAGICPROTECT_PFM)
			iDamage *= 0.5;

		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) && 
			(dice(1,10) < 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
				iDamage = 1;
		}


		if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				// 
				return;
			}
		}

		m_pClientList[sTargetH]->m_iHP -= iDamage;
		m_pClientList[sTargetH]->m_lastDamageTime = dwTime;
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			g_clientList[sTargetH]->KilledHandler( sAttackerH, cAttackerType, iDamage);
		}
		else {
			if (iDamage > 0) {


				if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
					dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1/100.0f)*dTmp2 +1.0f;


					iTemp = (2*m_pClientList[sTargetH]->GetMag()) + (2*m_pClientList[sTargetH]->m_iLevel) + (m_pClientList[sTargetH]->GetInt()/2);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}


				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
					if (dice(1,100) < (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
						iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;

						SendNotifyMsg(NULL, sTargetH, NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
					}
				}


				if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) 
					iMoveDamage = 80;
				else iMoveDamage = 50;

				if (iDamage >= iMoveDamage) {

					///		char cDamageMoveDir;
					sTgtX = m_pClientList[sTargetH]->m_sX;
					sTgtY = m_pClientList[sTargetH]->m_sY;

					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY)     goto EDSD_SKIPDAMAGEMOVE;
						else if (sTgtY > sAtkY) cDamageMoveDir = 5;
						else if (sTgtY < sAtkY) cDamageMoveDir = 1;
					}
					else if (sTgtX > sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 3;
						else if (sTgtY > sAtkY) cDamageMoveDir = 4;
						else if (sTgtY < sAtkY) cDamageMoveDir = 2;
					}
					else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;
					}


					m_pClientList[sTargetH]->m_iLastDamage = iDamage;
					SendNotifyMsg(NULL, sTargetH, NOTIFY_HP, NULL, NULL, NULL, NULL);

					SendNotifyMsg(NULL, sTargetH, NOTIFY_DAMAGEMOVE, cDamageMoveDir, iDamage, NULL, NULL);
				}
				else {
EDSD_SKIPDAMAGEMOVE:;
					SendNotifyMsg(NULL, sTargetH, NOTIFY_HP, NULL, NULL, NULL, NULL);

					SendEventToNearClient_TypeA(sTargetH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTDAMAGE, iDamage, NULL, NULL);
				}

				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != TRUE) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(/*0,*/ sTargetH, OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}

				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) {
					// 1: Hold-Person 
					// 2: Paralize
					SendNotifyMsg(NULL, sTargetH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ], NULL, NULL);

					m_pClientList[sTargetH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
					RemoveFromDelayEventList(sTargetH, OWNERTYPE_PLAYER, MAGICTYPE_HOLDOBJECT);
				}
			}
		}
		break;

	case OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode == TRUE) && (cAttackerSide == m_pNpcList[sTargetH]->m_side)) return;

		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
		case 4:
		case 6: 
		return;
		}

		if (cAttackerType == OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_side == 0) || (m_pNpcList[sTargetH]->m_side == m_pClientList[sAttackerH]->m_side)) return;
				break;
			}
		}

		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage)/100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[MAGICTYPE_PROTECT] == MAGICPROTECT_PFM)
			iDamage *= 0.5;

		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) {

			NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}
		else {

			switch (cAttackerType) {
			case OWNERTYPE_PLAYER:

				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_side == cAttackerSide)) return;
				break;

			case OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_side == m_pNpcList[sTargetH]->m_side) return;
			break;
			}

			SendEventToNearClient_TypeA(sTargetH, OWNERTYPE_NPC, MSGID_EVENT_MOTION, OBJECTDAMAGE, iDamage, NULL, NULL);

			if ((dice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {

				if ((cAttackerType == OWNERTYPE_NPC) && 
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_side == m_pNpcList[sTargetH]->m_side)) return;


				m_pNpcList[sTargetH]->m_cBehavior          = BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;



				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) {

					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
					RemoveFromDelayEventList(sTargetH, OWNERTYPE_NPC, MAGICTYPE_HOLDOBJECT);
				}

				//Crusade
				int iExp;


				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) && 
					(cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) ) {
						if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
							// Crusade
							iExp = iDamage;
							if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

							if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
								dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
								dTmp2 = (double)iExp;
								dTmp3 = (dTmp1/100.0f)*dTmp2;
								iExp += (int)dTmp3;
							}

							if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
								switch (m_pNpcList[sTargetH]->m_sType) {
								case 55:
								case 56:
									iExp = 0 ;
									break ;
								default: break;
								}
							}

							if (bExp == TRUE) 
								GetExp(sAttackerH, iExp); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //iDamage;
							else GetExp(sAttackerH, (iExp/2)); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(iDamage/2);
							m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
						}
						else {
							// Crusade
							iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
							if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;


							if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
								dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
								dTmp2 = (double)iExp;
								dTmp3 = (dTmp1/100.0f)*dTmp2;
								iExp += (int)dTmp3;
							}


							if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
								switch (m_pNpcList[sTargetH]->m_sType) {
								case 55:
								case 56:
									iExp = 0 ;
									break ;
								default: break;
								}
							}

							if (bExp == TRUE) 
								GetExp(sAttackerH, iExp); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //m_pNpcList[sTargetH]->m_iNoDieRemainExp;
							else GetExp(sAttackerH, (iExp/2)); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(m_pNpcList[sTargetH]->m_iNoDieRemainExp/2);
							m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
						}
				}
			}
		}
		break;
	}
}

void CGame::Effect_HpUp_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
	int iHP, iMaxHP;

	if (cAttackerType == OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	iHP = dice(sV1, sV2) + sV3;

	switch (cTargetType) {
	case OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;

		m_pClientList[sTargetH]->AddHP(iHP);
		break;

	case OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if (m_pNpcList[sTargetH]->m_bIsKilled == TRUE) return;

		iMaxHP = m_pNpcList[sTargetH]->m_iHitDice*4;
		if (m_pNpcList[sTargetH]->m_iHP < iMaxHP) {
			m_pNpcList[sTargetH]->m_iHP += iHP;

			if (m_pNpcList[sTargetH]->m_iHP > iMaxHP) m_pNpcList[sTargetH]->m_iHP = iMaxHP;
			if (m_pNpcList[sTargetH]->m_iHP <= 0)     m_pNpcList[sTargetH]->m_iHP = 1;
		}
		break;
	}
}

void CGame::Effect_SpDown_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
	int iSP, iMaxSP, iSideCondition;

	if (cAttackerType == OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	iSP = dice(sV1, sV2) + sV3;

	switch (cTargetType) {
	case OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;

		// Is the user having an invincibility slate
		if ((m_pClientList[sTargetH]->m_iStatus & STATUS_REDSLATE) != 0) return;


		if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {

			if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (m_pClientList[sAttackerH]->m_iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;

			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) {
				iSideCondition = m_pClientList[sAttackerH]->GetPlayerRelationship(sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
				}
				else {

					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {

						}
						else return;
					}
					else return;
				}
			}
		}

		iMaxSP = m_pClientList[sTargetH]->GetMaxSP();
		if (m_pClientList[sTargetH]->m_iSP > 0) {
			if (m_pClientList[sTargetH]->m_iTimeLeft_FirmStamina == 0) {
				m_pClientList[sTargetH]->m_iSP -= iSP;
				if (m_pClientList[sTargetH]->m_iSP < 0) m_pClientList[sTargetH]->m_iSP = 0;
				SendNotifyMsg(NULL, sTargetH, NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
		}
		break;

	case OWNERTYPE_NPC:

		break;
	}
}

bool CGame::bSetItemToBankItem(int iClientH, class CItem * pItem)
{
	register int i, iRet;
	DWORD * dwp;
	WORD  * wp;
	char  * cp;
	short * sp;
	char cData[100];		   

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (pItem == NULL) return FALSE;

	if (m_pClientList[iClientH]->m_bIsOnWarehouse == FALSE) return FALSE;

	for (i = 0; i < MAXBANKITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {

			m_pClientList[iClientH]->m_pItemInBankList[i] = pItem;

			dwp  = (DWORD *)(cData + INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + INDEX2_MSGTYPE);
			*wp  = NOTIFY_ITEMTOBANK;

			cp = (char *)(cData + INDEX2_MSGTYPE + 2);

			*cp = i; 
			cp++;

			cp += WriteItemData(cp, pItem);

			sp = (short *)cp;
			*sp = pItem->m_sItemEffectValue2;
			cp += 2;

			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;

			*cp = (char) pItem->m_sItemSpecEffectValue2 ;
			cp ++ ;

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 56);

#ifdef TAIWANLOG
			_bItemLog(ITEMLOG_DEPOSIT, iClientH, (int) -1, pItem);
#endif

			m_pClientList[iClientH]->m_bIsBankModified = TRUE ;

			switch (iRet) {
			case XSOCKEVENT_QUENEFULL:
			case XSOCKEVENT_SOCKETERROR:
			case XSOCKEVENT_CRITICALERROR:
			case XSOCKEVENT_SOCKETCLOSED:
			// DeleteClient(iClientH, TRUE, TRUE);
			return TRUE; 
			}

			return TRUE;
		}
		return FALSE;
}

void CGame::OnKeyDown(WPARAM wParam, LPARAM lParam)
{
	switch (wParam) {
	case VK_F1:
		m_bF1pressed = TRUE;
		break;
	case VK_F4:
		m_bF4pressed = TRUE;
		break;
	case VK_F12:
		m_bF12pressed = TRUE;
		break;
	}
}

void CGame::OnKeyUp(WPARAM wParam, LPARAM lParam)
{
	int i;
	switch (wParam) {
	case VK_F2:

		/*
		char cTxt[120];
		for (i = 1; i <= 200; i++){
		wsprintf(cTxt, "Level %d:  Exp %d", i, iGetLevelExp(i));
		PutLogFileList(cTxt);
		}

		if (m_bOnExitProcess == FALSE) {
		m_cShutDownCode      = 3;
		m_bOnExitProcess     = TRUE;
		m_dwExitProcessTime  = timeGetTime();

		PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by Log-server connection Lost Emulation)!!!");
		}
		*/
		break;

	case VK_F1:
		m_bF1pressed = FALSE;
		break;
	case VK_F4:
		m_bF4pressed = FALSE;
		break;
	case VK_F12:
		m_bF12pressed = FALSE;
		break;

	case VK_F6:
		if (m_bF1pressed == TRUE) {
			PutLogList("(!) Send server shutdown announcement1...");
			for (i = 1; i < MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					SendNotifyMsg(NULL, i, NOTIFY_SERVERSHUTDOWN, 1, NULL, NULL, NULL);
				}
		}
		break;

	case VK_F7:
		if (m_bF1pressed == TRUE) {
			PutLogList("(!) Send server shutdown announcement2...");
			for (i = 1; i < MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					SendNotifyMsg(NULL, i, NOTIFY_SERVERSHUTDOWN, 2, NULL, NULL, NULL);
				}
		}
		break;

	case VK_F9:
		if (m_bF1pressed == TRUE) {
			PutLogList("(!!!) Resume Crusade Mode...");
			LocalStartCrusadeMode(NULL);
		}
		break;

	case VK_F11:
		if (m_bF1pressed == TRUE) {
			PutLogList("(!!!) ManualEndCrusadeMode: side 0");
			ManualEndCrusadeMode(0);
		}
		break;
	case VK_HOME:
		if (m_bF1pressed == TRUE) {
			GlobalStartCrusadeMode();
		}
		break;

	case VK_END:
		//LocalEndCrusadeMode();
		break;

	case VK_INSERT:
		//_GrandMagicLaunchMsgSend(1, 1);
		//MeteorStrikeMsgHandler(1);
		break;

	case VK_DELETE:
		//_GrandMagicLaunchMsgSend(1, 2);
		//MeteorStrikeMsgHandler(2);
		break;
	}
}

int CGame::iGetFollowerNumber(short sOwnerH, char cOwnerType)
{
	register int i, iTotal;

	iTotal = 0;

	for (i = 1; i < MAXNPCS; i++) 
		if ( (m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_cMoveType == MOVETYPE_FOLLOW) ) {

			if ((m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH) && (m_pNpcList[i]->m_cFollowOwnerType == cOwnerType))
				iTotal++;
		}

	return iTotal;
}

bool CGame::RegisterDelayEvent(int iDelayType, int iEffectType, DWORD dwLastTime, int iTargetH, char cTargetType, char cMapIndex, int dX, int dY, int iV1, int iV2, int iV3)
{
	register int i;

	for (i = 0; i < MAXDELAYEVENTS; i++) 
		if (m_pDelayEventList[i] == NULL) {

			m_pDelayEventList[i] = new class CDelayEvent;

			m_pDelayEventList[i]->m_iDelayType = iDelayType;
			m_pDelayEventList[i]->m_iEffectType = iEffectType;

			m_pDelayEventList[i]->m_cMapIndex = cMapIndex;
			m_pDelayEventList[i]->m_dX = dX;
			m_pDelayEventList[i]->m_dY = dY;

			m_pDelayEventList[i]->m_iTargetH    = iTargetH;
			m_pDelayEventList[i]->m_cTargetType = cTargetType;
			m_pDelayEventList[i]->m_iV1         = iV1;
			m_pDelayEventList[i]->m_iV2         = iV2;
			m_pDelayEventList[i]->m_iV3         = iV3; 

			m_pDelayEventList[i]->m_dwTriggerTime = dwLastTime;

			return TRUE;
		}

		return FALSE;
}

bool CGame::RegisterDelayEvent(int iDelayType, int iEffectType, DWORD dwLastTime, Unit * unit, char cMapIndex, int dX, int dY, int iV1, int iV2, int iV3)
{
	register int i;

	for (i = 0; i < MAXDELAYEVENTS; i++) 
		if (m_pDelayEventList[i] == NULL) {

			m_pDelayEventList[i] = new class CDelayEvent;

			m_pDelayEventList[i]->m_iDelayType = iDelayType;
			m_pDelayEventList[i]->m_iEffectType = iEffectType;

			m_pDelayEventList[i]->m_cMapIndex = cMapIndex;
			m_pDelayEventList[i]->m_dX = dX;
			m_pDelayEventList[i]->m_dY = dY;

			m_pDelayEventList[i]->m_iTargetH    = unit->m_handle;
			m_pDelayEventList[i]->m_cTargetType = unit->m_ownerType;
			m_pDelayEventList[i]->m_iV1         = iV1;
			m_pDelayEventList[i]->m_iV2         = iV2;
			m_pDelayEventList[i]->m_iV3         = iV3; 

			m_pDelayEventList[i]->m_dwTriggerTime = dwLastTime;

			return TRUE;
		}

		return FALSE;
}

void CGame::DelayEventProcessor()
{
	register int i, iSkillNum, iResult;
	DWORD dwTime = timeGetTime();
	int iTemp;
	Unit * unit = NULL;

	for (i = 0; i < MAXDELAYEVENTS; i++) 
		if ((m_pDelayEventList[i] != NULL) && (m_pDelayEventList[i]->m_dwTriggerTime < dwTime)) {

			switch (m_pDelayEventList[i]->m_iDelayType) 
			{

			case DELAYEVENTTYPE_ANCIENT_TABLET:
				if ((m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iStatus & STATUS_REDSLATE) != 0) {
					iTemp = 1;
				}
				else if ((m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iStatus & STATUS_BLUESLATE) != 0) {
					iTemp = 3;
				}
				else if ((m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iStatus & STATUS_GREENSLATE) != 0) {
					iTemp = 4;
				}

				SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, NOTIFY_SLATE_STATUS, iTemp, NULL, NULL, NULL);
				SetSlateFlag(m_pDelayEventList[i]->m_iTargetH, iTemp, FALSE);
				break;

			case DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT:
				CalcMeteorStrikeEffectHandler(m_pDelayEventList[i]->m_cMapIndex);
				break;

			case DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE:
				DoMeteorStrikeDamageHandler(m_pDelayEventList[i]->m_cMapIndex);
				break;

			case DELAYEVENTTYPE_METEORSTRIKE:
				MeteorStrikeHandler(m_pDelayEventList[i]->m_cMapIndex);
				break;

			case DELAYEVENTTYPE_USEITEM_SKILL:

				switch (m_pDelayEventList[i]->m_cTargetType) 
				{
				case OWNERTYPE_PLAYER:
					iSkillNum = m_pDelayEventList[i]->m_iEffectType;

					if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH] == NULL ) break;
					if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] == FALSE ) break;
					if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] != m_pDelayEventList[i]->m_iV2) break;

					m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] = FALSE;
					m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] = NULL;

					iResult = iCalculateUseSkillItemEffect(m_pDelayEventList[i]->m_iTargetH, m_pDelayEventList[i]->m_cTargetType,
						m_pDelayEventList[i]->m_iV1, iSkillNum, m_pDelayEventList[i]->m_cMapIndex, m_pDelayEventList[i]->m_dX, m_pDelayEventList[i]->m_dY);

					SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, NOTIFY_SKILLUSINGEND, iResult, NULL, NULL, NULL);
					break;
				}
				break;
		case DELAYEVENTTYPE_KILL_ABADDON:
			NpcKilledHandler(m_pDelayEventList[i]->m_iTargetH, OWNERTYPE_NPC, m_pDelayEventList[i]->m_iTargetH, 0);
			break;

		case DELAYEVENTTYPE_END_APOCALYPSE:
			GlobalEndApocalypseMode(0);	
			break;
			case DELAYEVENTTYPE_DAMAGEOBJECT:
				break;

			case DELAYEVENTTYPE_MAGICRELEASE:
				if(m_pDelayEventList[i]->m_cTargetType == OWNERTYPE_PLAYER) 
					unit = m_pClientList[ m_pDelayEventList[i]->m_iTargetH ];
				else if(m_pDelayEventList[i]->m_cTargetType == OWNERTYPE_NPC) 
					unit = m_pNpcList[ m_pDelayEventList[i]->m_iTargetH ];

				if(!unit) break;

				unit->RemoveMagicEffect(m_pDelayEventList[i]->m_iEffectType);
				break;
			}

			delete m_pDelayEventList[i];
			m_pDelayEventList[i] = NULL;
		}
}

bool CGame::RemoveFromDelayEventList(int iH, char cType, int iEffectType)
{
	register int i;

	for (i = 0; i < MAXDELAYEVENTS; i++) 
		if (m_pDelayEventList[i] != NULL) {

			if (iEffectType == NULL) {

				if ( (m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType) ) {
					delete m_pDelayEventList[i];
					m_pDelayEventList[i] = NULL;
				}
			}
			else {
				if ( (m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType) &&
					(m_pDelayEventList[i]->m_iEffectType == iEffectType) ) {
						delete m_pDelayEventList[i];
						m_pDelayEventList[i] = NULL;
				}
			}
		}

	return TRUE;
}

bool CGame::RemoveFromDelayEventList(Unit * unit, int iEffectType)
{
	register int i;

	for (i = 0; i < MAXDELAYEVENTS; i++) 
		if (m_pDelayEventList[i] != NULL) {

			if (iEffectType == NULL) {

				if ( (m_pDelayEventList[i]->m_iTargetH == unit->m_handle) && (m_pDelayEventList[i]->m_cTargetType == unit->m_ownerType) ) {
					delete m_pDelayEventList[i];
					m_pDelayEventList[i] = NULL;
				}
			}
			else {
				if ( (m_pDelayEventList[i]->m_iTargetH == unit->m_handle) && (m_pDelayEventList[i]->m_cTargetType == unit->m_ownerType) &&
					(m_pDelayEventList[i]->m_iEffectType == iEffectType) ) {
						delete m_pDelayEventList[i];
						m_pDelayEventList[i] = NULL;
				}
			}
		}

	return TRUE;
}

void CGame::SendObjectMotionRejectMsg(int iClientH)
{
	char  * cp, cData[30];
	DWORD * dwp;
	WORD  * wp;
	short * sp;
	int     iRet;

	m_pClientList[iClientH]->m_bIsMoveBlocked = TRUE; 
	dwp  = (DWORD *)(cData + INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + INDEX2_MSGTYPE);
	*wp  = OBJECTMOTION_REJECT;

	cp   = (char *)(cData + INDEX2_MSGTYPE + 2); 
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX; 
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY; 
	cp += 2;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10);
	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
	return;
}

int CGame::_iGetTotalClients()
{
	register int i, iTotal;

	iTotal = 0;
	for (i = 1; i < MAXCLIENTS; i++) 
		if (m_pClientList[i] != NULL) iTotal++;

	return iTotal;
}

void CGame::DynamicObjectEffectProcessor()
{
	register int i, ix, iy, iIndex;
	short sOwnerH, iDamage, sType;
	char  cOwnerType;
	DWORD dwTime = timeGetTime(), dwRegisterTime;

	for (i = 0; i < MAXDYNAMICOBJECTS; i++) 
		if (m_pDynamicObjectList[i] != NULL) {
			switch (m_pDynamicObjectList[i]->m_sType) {
		case DYNAMICOBJECT_PCLOUD_BEGIN:

			for (ix = m_pDynamicObjectList[i]->m_sX -1; ix <= m_pDynamicObjectList[i]->m_sX+1; ix++)
				for (iy = m_pDynamicObjectList[i]->m_sY -1; iy <= m_pDynamicObjectList[i]->m_sY+1; iy++) {

					m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (sOwnerH != NULL) {

						switch (cOwnerType) {
						case OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;

							if(m_pClientList[sOwnerH]->IsInvincible()) break ;


							//if ((m_pClientList[sOwnerH]->m_bIsNeutral == TRUE) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

							if (m_pDynamicObjectList[i]->m_iV1 < 20)
								iDamage = dice(1,6);
							else iDamage = dice(1,8);

							m_pClientList[sOwnerH]->m_iHP -= iDamage;
							m_pClientList[sOwnerH]->m_lastDamageTime = dwTime;
							if (m_pClientList[sOwnerH]->m_iHP <= 0) {
								m_pClientList[sOwnerH]->KilledHandler(sOwnerH, cOwnerType, iDamage);
							}
							else {
								if (iDamage > 0) {
									SendNotifyMsg(NULL, sOwnerH, NOTIFY_HP, NULL, NULL, NULL, NULL);

									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) {
										// 1: Hold-Person 
										// 2: Paralize
										SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ], NULL, NULL);

										m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
										RemoveFromDelayEventList(sOwnerH, OWNERTYPE_PLAYER, MAGICTYPE_HOLDOBJECT);
									}
								}


								if ( (CheckResistingMagicSuccess(1, sOwnerH, OWNERTYPE_PLAYER, 100) == FALSE) &&
									(m_pClientList[sOwnerH]->m_bIsPoisoned == FALSE) ) {

										m_pClientList[sOwnerH]->m_bIsPoisoned  = TRUE;
										m_pClientList[sOwnerH]->m_iPoisonLevel = m_pDynamicObjectList[i]->m_iV1;
										m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;

										m_pClientList[sOwnerH]->SetStatusFlag(STATUS_POISON, TRUE);
										SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTON, MAGICTYPE_POISON, m_pClientList[sOwnerH]->m_iPoisonLevel, NULL, NULL);
#ifdef TAIWANLOG
										_bItemLog(ITEMLOG_POISONED,sOwnerH,(char *) NULL,NULL) ;
#endif
								}
							}
							break;

						case OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;

							if (m_pDynamicObjectList[i]->m_iV1 < 20)
								iDamage = dice(1,6);
							else iDamage = dice(1,8);

							switch (m_pNpcList[sOwnerH]->m_sType) {
							case 40:
							case 41:
							case 6: 
							case 5: // Crusade structures
							case 8: // Heldenian gate.
								iDamage = 0;
								break;
							}


							switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
							case 0: 
							case 3: 
							case 5: 
								m_pNpcList[sOwnerH]->m_iHP -= iDamage;
								break;
							}
							//if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) 
							//	m_pNpcList[sOwnerH]->m_iHP -= iDamage;

							if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
								NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); 
							}
							else {
								if (dice(1,3) == 2)
									m_pNpcList[sOwnerH]->m_dwTime = dwTime;
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
								}

								SendEventToNearClient_TypeA(sOwnerH, OWNERTYPE_NPC, MSGID_EVENT_MOTION, OBJECTDAMAGE, iDamage, 0, NULL);
							}
							break;
						}
					}
				}
				break;

		case DYNAMICOBJECT_ICESTORM:

			for (ix = m_pDynamicObjectList[i]->m_sX -2; ix <= m_pDynamicObjectList[i]->m_sX+2; ix++)
				for (iy = m_pDynamicObjectList[i]->m_sY -2; iy <= m_pDynamicObjectList[i]->m_sY+2; iy++) {
					m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (sOwnerH != NULL) {

						switch (cOwnerType) {
						case OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;

							if(m_pClientList[sOwnerH]->IsInvincible()) break  ;

							//if ((m_pClientList[sOwnerH]->m_bIsNeutral == TRUE) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

							iDamage = dice(3,3) + 5;
							m_pClientList[sOwnerH]->m_iHP -= iDamage;
							m_pClientList[sOwnerH]->m_lastDamageTime = dwTime;

							if (m_pClientList[sOwnerH]->m_iHP <= 0) {
								m_pClientList[sOwnerH]->KilledHandler(sOwnerH, cOwnerType, iDamage);
							}
							else {
								if (iDamage > 0) {
									SendNotifyMsg(NULL, sOwnerH, NOTIFY_HP, NULL, NULL, NULL, NULL);

									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] == 1) {

										// 1: Hold-Person 
										// 2: Paralize
										SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ], NULL, NULL);

										m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
										RemoveFromDelayEventList(sOwnerH, OWNERTYPE_PLAYER, MAGICTYPE_HOLDOBJECT);
									}
								}


								if (!checkResistingIceSuccess(1, sOwnerH, OWNERTYPE_PLAYER, m_pDynamicObjectList[i]->m_iV1))
									m_pClientList[sOwnerH]->AddMagicEffect(MAGICTYPE_ICE, g_magicConfigList[MAGIC_ICESTORM]->m_sValue[MAGICV_ICEDURATION]);
							}
							break;

						case OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;

							iDamage = dice(3,3) + 5;

							switch (m_pNpcList[sOwnerH]->m_sType) {
							case 40:
							case 41:
							case 6: 
								iDamage = 0;
								break;
						}


						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 0: 						
						case 3: 
						case 5: 
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							break;
						}
						//if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) 
						//	m_pNpcList[sOwnerH]->m_iHP -= iDamage;

						if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
							NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); 
						}
						else {
							if (dice(1,3) == 2)
								m_pNpcList[sOwnerH]->m_dwTime = dwTime;
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
							}

							SendEventToNearClient_TypeA(sOwnerH, OWNERTYPE_NPC, MSGID_EVENT_MOTION, OBJECTDAMAGE, iDamage, 0, NULL);

							if (!checkResistingIceSuccess(1, sOwnerH, OWNERTYPE_NPC, m_pDynamicObjectList[i]->m_iV1))
								m_pNpcList[sOwnerH]->AddMagicEffect(g_magicConfigList[MAGIC_ICESTORM]->m_sType, g_magicConfigList[MAGIC_ICESTORM]->m_sValue[MAGICV_ICEDURATION]);
						}
						break;
						}
					}

					m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {

							iDamage = dice(3,2);
							m_pClientList[sOwnerH]->m_iHP -= iDamage;

							if (m_pClientList[sOwnerH]->m_iHP <= 0) {
								m_pClientList[sOwnerH]->KilledHandler(sOwnerH, cOwnerType, iDamage);
							}
							else {
								if (iDamage > 0) {
									SendNotifyMsg(NULL, sOwnerH, NOTIFY_HP, NULL, NULL, NULL, NULL);
								}
							}
					}

					m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
					if ((sType == DYNAMICOBJECT_FIRE) && (m_pDynamicObjectList[iIndex] != NULL)) 
						m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime/10);
				}
				break;

		case DYNAMICOBJECT_FIRE:

			if (m_pDynamicObjectList[i]->m_iCount == 1) {
				CheckFireBluring(m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY);
			}
			m_pDynamicObjectList[i]->m_iCount++;
			if (m_pDynamicObjectList[i]->m_iCount > 10) m_pDynamicObjectList[i]->m_iCount = 10; 


			for (ix = m_pDynamicObjectList[i]->m_sX -1; ix <= m_pDynamicObjectList[i]->m_sX+1; ix++)
				for (iy = m_pDynamicObjectList[i]->m_sY -1; iy <= m_pDynamicObjectList[i]->m_sY+1; iy++) {

					m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (sOwnerH != NULL) {

						switch (cOwnerType) {

						case OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;

							if(m_pClientList[sOwnerH]->IsInvincible()) break  ;


							//if ((m_pClientList[sOwnerH]->m_bIsNeutral == TRUE) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

							iDamage = dice(1,6);
							m_pClientList[sOwnerH]->m_iHP -= iDamage;
							m_pClientList[sOwnerH]->m_lastDamageTime = dwTime;
							if (m_pClientList[sOwnerH]->m_iHP <= 0) {
								m_pClientList[sOwnerH]->KilledHandler(sOwnerH, cOwnerType, iDamage);
							}
							else {
								if (iDamage > 0) {
									SendNotifyMsg(NULL, sOwnerH, NOTIFY_HP, NULL, NULL, NULL, NULL);

									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) {
										// 1: Hold-Person 
										// 2: Paralize
										SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ], NULL, NULL);

										m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
										RemoveFromDelayEventList(sOwnerH, OWNERTYPE_PLAYER, MAGICTYPE_HOLDOBJECT);
									}
								}
							}
							break;

						case OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							iDamage = dice(1,6);
							switch (m_pNpcList[sOwnerH]->m_sType) {
							case 40:
							case 41:
							case 6: 
								iDamage = 0;
								break;
							}


							switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
							case 0: 						
							case 3: 
							case 5: 
								m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							break;
							}
							//if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) 
							//	m_pNpcList[sOwnerH]->m_iHP -= iDamage;

							if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
								NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); 
							}
							else {
								if (dice(1,3) == 2)
									m_pNpcList[sOwnerH]->m_dwTime = dwTime;
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
								}

								SendEventToNearClient_TypeA(sOwnerH, OWNERTYPE_NPC, MSGID_EVENT_MOTION, OBJECTDAMAGE, iDamage, 0, NULL);
							}
							break;
						}
					}

					m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {

							iDamage = dice(1,6);
							m_pClientList[sOwnerH]->m_iHP -= iDamage;
							m_pClientList[sOwnerH]->m_lastDamageTime = dwTime;
							if (m_pClientList[sOwnerH]->m_iHP <= 0) {
								m_pClientList[sOwnerH]->KilledHandler(sOwnerH, cOwnerType, iDamage);
							}
							else {
								if (iDamage > 0) {
									SendNotifyMsg(NULL, sOwnerH, NOTIFY_HP, NULL, NULL, NULL, NULL);
								}
							}
					}

					m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
					if ((sType == DYNAMICOBJECT_ICESTORM) && (m_pDynamicObjectList[iIndex] != NULL)) 
						m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime/10);
				}
				break;
			}
		}
}

void CGame::ClearSkillUsingStatus(int iClientH)
{
	register int i;

	if (m_pClientList[iClientH] == NULL) return;

	//m_pClientList[iClientH]->m_hasPrecasted = false;
	for (i = 0; i < MAXSKILLTYPE; i++) {
		m_pClientList[iClientH]->m_bSkillUsingStatus[i] = FALSE;
		m_pClientList[iClientH]->m_iSkillUsingTimeID[i] = NULL;
	}

	if (m_pClientList[iClientH]->m_iAllocatedFish != NULL) {
		if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != NULL) 
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;

		m_pClientList[iClientH]->m_iAllocatedFish = NULL;
		SendNotifyMsg(NULL, iClientH, NOTIFY_FISHCANCELED, NULL, NULL, NULL, NULL);
	}
}

int CGame::iCalculateUseSkillItemEffect(int iOwnerH, char cOwnerType, char cOwnerSkill, int iSkillNum, char cMapIndex, int dX, int dY)
{
	class CItem * pItem;
	short lX, lY;
	int   iResult, iFish, iItemID = 0 ;

	switch (cOwnerType) {
	case OWNERTYPE_PLAYER:
		if (m_pClientList[iOwnerH] == NULL) return 0;
		if (m_pClientList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pClientList[iOwnerH]->m_sX;
		lY = m_pClientList[iOwnerH]->m_sY;
		break;

	case OWNERTYPE_NPC:
		if (m_pNpcList[iOwnerH] == NULL) return 0;
		if (m_pNpcList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pNpcList[iOwnerH]->m_sX;
		lY = m_pNpcList[iOwnerH]->m_sY;
		break;
	}

	if (cOwnerSkill == 0) return 0;

	iResult = dice(1, 105);
	if (cOwnerSkill <= iResult)	return 0;  
	if (m_pMapList[cMapIndex]->bGetIsWater(dX, dY) == FALSE) return 0;

	if (cOwnerType == OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(iOwnerH, iSkillNum, 1);

	switch (m_pSkillConfigList[iSkillNum]->m_sType) {
	case SKILLEFFECTTYPE_TAMING:
		_TamingHandler(iOwnerH, iSkillNum, cMapIndex, dX, dY);
		break;

	case SKILLEFFECTTYPE_GET: 

		switch (m_pSkillConfigList[iSkillNum]->m_sValue1) {
		case 1:

			iItemID = 99 ;  
			break;

		case 2:

			//if (m_pMapList[cMapIndex]->bGetIsWater(dX, dY) == FALSE) return 0; 

			if (cOwnerType == OWNERTYPE_PLAYER) {
				iFish = iCheckFish(iOwnerH, cMapIndex, dX, dY);
				if (iFish == NULL) iItemID = 100 ; 
			} else iItemID = 100 ; 
			break;
			}

			if (iItemID != 0) {


				if (iItemID == 100) {
					SendNotifyMsg(NULL, iOwnerH, NOTIFY_FISHSUCCESS, NULL, NULL, NULL, NULL);


					GetExp(iOwnerH, dice(2,5)); //m_pClientList[iOwnerH]->m_iExpStock += dice(1,2);
				}

				pItem = new class CItem;
				if (pItem == NULL) return 0;
				if (_bInitItemAttr(pItem, iItemID) == TRUE) {


					pItem->m_sTouchEffectType   = ITET_ID;
					pItem->m_sTouchEffectValue1 = dice(1,100000);
					pItem->m_sTouchEffectValue2 = dice(1,100000);

					pItem->m_sTouchEffectValue3 = (short) timeGetTime();


					m_pMapList[cMapIndex]->bSetItem(lX, lY, pItem);


					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, cMapIndex,
						lX, lY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4
				}
			}
		break;

	}
	return 1;
}


void CGame::UseSkillHandler(int iClientH, int iV1, int iV2, int iV3)
{
	char  cOwnerType;
	short sAttackerWeapon, sOwnerH;
	int   iResult, iPlayerSkillLevel;
	DWORD dwTime = timeGetTime();

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((iV1 < 0) || (iV1 >= MAXSKILLTYPE)) return;
	if (m_pSkillConfigList[iV1]	== NULL) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] == TRUE) return;
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;


	/*
	if (iV1 != 19) {
	m_pClientList[iClientH]->m_iAbuseCount++;
	if ((m_pClientList[iClientH]->m_iAbuseCount % 30) == 0) {
	wsprintf(g_cTxt, "(!)  (%s) Skill(%d) Tries(%d)",m_pClientList[iClientH]->m_cCharName, 
	iV1, m_pClientList[iClientH]->m_iAbuseCount);
	PutLogFileList(g_cTxt);
	}
	}
	*/

	iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[iV1];
	iResult = dice(1, 100);

	if (iResult > iPlayerSkillLevel) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
		return;
	}

	switch (m_pSkillConfigList[iV1]->m_sType) {
	case SKILLEFFECTTYPE_PRETEND:
		if(m_astoria.get() && m_astoria->GetRelicHolder() == m_pClientList[iClientH])
			return;
		switch (m_pSkillConfigList[iV1]->m_sValue1) {
		case 1:

			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}

			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetDeadOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			if (sOwnerH != NULL) {

				SendNotifyMsg(NULL, iClientH, NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}

			iResult = 0;
			if (m_pClientList[iClientH]->m_iAdminUserLevel <= 0) {
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY);
				iResult += sOwnerH;

				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
			}

			if (iResult != 0) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}

			m_pClientList[iClientH]->RemoveMagicEffect(MAGICTYPE_INVISIBILITY);

			CalculateSSN_SkillIndex(iClientH, iV1, 1);

			sAttackerWeapon = 1;
			SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTDYING, 0, sAttackerWeapon, NULL);

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(/*14,*/ iClientH, OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			break;
			}
		break;

	}
	m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] = TRUE;
}

void CGame::ReqSellItemHandler(int iClientH, char cItemID, char cSellToWhom, int iNum, char * pItemName)
{
	char cItemCategory;
	short sRemainLife;
	int   iPrice;
	double d1, d2, d3;
	bool   bNeutral;
	DWORD  dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2, dwMul1, dwMul2;


	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;	
	CItem * item = m_pClientList[iClientH]->m_pItemList[cItemID];
	if (!item) return;
	if (iNum <= 0) return;
	if (item->m_dwCount < iNum) return;

	iCalcTotalWeight(iClientH);


	bNeutral = FALSE;
	if (m_pClientList[iClientH]->IsNeutral()) bNeutral = TRUE;


	switch (cSellToWhom) {
	case 15: 
	case 24:        
		cItemCategory = item->m_cCategory;

		if ( (cItemCategory >= 1 && cItemCategory <= 10) || 
			item->m_sItemEffectType == ITEMEFFECTTYPE_JEWELRY) 
		{
			sRemainLife = item->m_wCurLifeSpan;

			if (sRemainLife == 0) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTSELLITEM, cItemID, 2, NULL, item->m_cName);
			}
			else {
				d1 = (double)sRemainLife;
				if (item->m_wMaxLifeSpan != 0)
					d2 = (double)item->m_wMaxLifeSpan;
				else d2 = 1.0f;
				d3 = (d1 / d2) * 0.5f;
				d2 = (double)item->m_wPrice; 				d3 = d3 * d2; 

				iPrice = (int)d3;
				iPrice = iPrice*iNum;

				dwAddPrice1 = 0;
				dwAddPrice2 = 0;

				if ((item->m_dwAttribute & 0x00F00000) != NULL) {
					dwSWEType  = (item->m_dwAttribute & 0x00F00000) >> 20;  
					dwSWEValue = (item->m_dwAttribute & 0x000F0000) >> 16;



					switch (dwSWEType) {
					case 6: dwMul1 = 2; break;  
					case 8: dwMul1 = 2; break;  
					case 5: dwMul1 = 3; break;  					
					case 1: dwMul1 = 4; break;  					
					case 7: dwMul1 = 5; break;  					
					case 2: dwMul1 = 6; break;  
					case 3: dwMul1 = 15; break; 
					case 9: dwMul1 = 20; break; 
					default: dwMul1 = 1; break;
					}

					d1 = (double)iPrice*dwMul1;
					switch (dwSWEValue) {
					case 1: d2 = 10.0f; break;
					case 2: d2 = 20.0f; break;
					case 3: d2 = 30.0f; break;
					case 4: d2 = 35.0f; break;
					case 5: d2 = 40.0f; break;
					case 6: d2 = 50.0f; break;
					case 7: d2 = 100.0f; break;
					case 8: d2 = 200.0f; break;
					case 9: d2 = 300.0f; break;
					case 10: d2 = 400.0f; break;
					case 11: d2 = 500.0f; break;
					case 12: d2 = 700.0f; break;
					case 13: d2 = 900.0f; break;
					default: d2 = 0.0f; break;
					}
					d3 = d1*(d2/100.0f);

					dwAddPrice1 = (int)(d1 + d3);
				}


				if ((item->m_dwAttribute & 0x0000F000) != NULL) {
					dwSWEType  = (item->m_dwAttribute & 0x0000F000) >> 12;  
					dwSWEValue = (item->m_dwAttribute & 0x00000F00) >> 8;




					switch (dwSWEType) {
					case 1: 
					case 12: dwMul2 = 2; break;

					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
					case 7: dwMul2 = 4; break;

					case 8:
					case 9:
					case 10:
					case 11: dwMul2 = 6; break;
					}

					d1 = (double)iPrice*dwMul2;
					switch (dwSWEValue) {
					case 1: d2 = 10.0f; break;
					case 2: d2 = 20.0f; break;
					case 3: d2 = 30.0f; break;
					case 4: d2 = 35.0f; break;
					case 5: d2 = 40.0f; break;
					case 6: d2 = 50.0f; break;
					case 7: d2 = 100.0f; break;
					case 8: d2 = 200.0f; break;
					case 9: d2 = 300.0f; break;
					case 10: d2 = 400.0f; break;
					case 11: d2 = 500.0f; break;
					case 12: d2 = 700.0f; break;
					case 13: d2 = 900.0f; break;
					default: d2 = 0.0f; break;
					}
					d3 = d1*(d2/100.0f);

					dwAddPrice2 = (int)(d1 + d3);
				}

				iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1/3)) + (dwAddPrice2 - (dwAddPrice2/3));

				if (bNeutral == TRUE) iPrice = iPrice/2;
				if (iPrice <= 0)    iPrice = 1;
				if (iPrice > 1000000) iPrice = 1000000;

				if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(m_pGold, iPrice) > _iCalcMaxLoad(iClientH)) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTSELLITEM, cItemID, 4, NULL, item->m_cName);
				}
				else SendNotifyMsg(NULL, iClientH, NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, item->m_cName, iNum);
			}
		}
		else 	if ( (cItemCategory >= 11) && (cItemCategory <= 50) ) {

			iPrice = (item->m_wPrice / 2)*iNum;
			sRemainLife = item->m_wCurLifeSpan;

			if (bNeutral == TRUE) iPrice = iPrice/2;
			if (iPrice <= 0)    iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000;

			if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(m_pGold, iPrice) > _iCalcMaxLoad(iClientH)) {

				SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTSELLITEM, cItemID, 4, NULL, item->m_cName);
			}
			else SendNotifyMsg(NULL, iClientH, NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, item->m_cName, iNum);
		}
		else SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTSELLITEM, cItemID, 1, NULL, item->m_cName);
		break;

	default:
		break;
	}
}

void CGame::ReqSellItemConfirmHandler(int iClientH, char cItemID, int iNum, char * pString)
{
	class CItem * pItemGold;
	short sRemainLife;
	int   iPrice;
	double d1, d2, d3;
	char   cItemName[21], cItemCategory;
	DWORD  dwMul1, dwMul2, dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2;
	int    iEraseReq;
	bool   bNeutral;


	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= MAXITEMS)) return;	
	CItem * item = m_pClientList[iClientH]->m_pItemList[cItemID];
	if (!item) return;
	if (iNum <= 0) return;
	if (item->m_dwCount < iNum) return;

	if (m_pClientList[iClientH]->m_bIsOnShop == FALSE ) return;


	iCalcTotalWeight(iClientH);
	cItemCategory = item->m_cCategory;

	bNeutral = FALSE;
	if (m_pClientList[iClientH]->IsNeutral()) bNeutral = TRUE;

	iPrice = 0;

	if ( (cItemCategory >= 1 && cItemCategory <= 10) || 
		item->m_sItemEffectType == ITEMEFFECTTYPE_JEWELRY) 
	{
		sRemainLife = item->m_wCurLifeSpan;

		if (sRemainLife <= 0) {
			return;
		}
		else {
			d1 = (double)sRemainLife;
			if (item->m_wMaxLifeSpan != 0)
				d2 = (double)item->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)item->m_wPrice; 			d3 = d3 * d2; 

			iPrice = (short)d3;
			iPrice = iPrice*iNum;

			dwAddPrice1 = 0;
			dwAddPrice2 = 0;

			if ((item->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (item->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (item->m_dwAttribute & 0x000F0000) >> 16;

				switch (dwSWEType) {
				case 6: dwMul1 = 2; break;  
				case 8: dwMul1 = 2; break;  
				case 5: dwMul1 = 3; break;  				
				case 1: dwMul1 = 4; break;  				
				case 7: dwMul1 = 5; break;  				
				case 2: dwMul1 = 6; break;  
				case 3: dwMul1 = 15; break; 
				case 9: dwMul1 = 20; break; 
				default: dwMul1 = 1; break;
				}

				d1 = (double)iPrice*dwMul1;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1*(d2/100.0f);
				dwAddPrice1 = (int)(d1 + d3);
			}

			if ((item->m_dwAttribute & 0x0000F000) != NULL) {
				dwSWEType  = (item->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (item->m_dwAttribute & 0x00000F00) >> 8;

				switch (dwSWEType) {
				case 1: 
				case 12: dwMul2 = 2; break;

				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7: dwMul2 = 4; break;

				case 8:
				case 9:
				case 10:
				case 11: dwMul2 = 6; break;
				}

				d1 = (double)iPrice*dwMul2;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1*(d2/100.0f);
				dwAddPrice2 = (int)(d1 + d3);
			}


			iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1/3)) + (dwAddPrice2 - (dwAddPrice2/3));

			if (bNeutral == TRUE) iPrice = iPrice/2;
			if (iPrice <= 0) iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000;

			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMSOLD, cItemID, NULL, NULL, NULL);

			_bItemLog(ITEMLOG_SELL, iClientH, (int) -1, item) ;

			if ((item->m_cItemType == ITEMTYPE_CONSUME) ||
				(item->m_cItemType == ITEMTYPE_ARROW)) {

					SetItemCount(iClientH, cItemID, item->m_dwCount - iNum);
			}
			else ItemDepleteHandler(iClientH, cItemID, FALSE, FALSE);
		}
	}
	else 
		if ( (cItemCategory >= 11) && (cItemCategory <= 50) ) {
			iPrice = item->m_wPrice/2; 
			iPrice = iPrice*iNum;


			if (bNeutral == TRUE) iPrice = iPrice/2;
			if (iPrice <= 0) iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000;


			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMSOLD, cItemID, NULL, NULL, NULL);

			_bItemLog(ITEMLOG_SELL, iClientH, (int) -1, item) ;


			if ((item->m_cItemType == ITEMTYPE_CONSUME) ||
				(item->m_cItemType == ITEMTYPE_ARROW)) {

					SetItemCount(iClientH, cItemID, item->m_dwCount - iNum);
			}

			else ItemDepleteHandler(iClientH, cItemID, FALSE, FALSE);
		}


	if (iPrice <= 0) return;

	pItemGold = new class CItem;
	ZeroMemory(cItemName, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	_bInitItemAttr(pItemGold, cItemName);

	pItemGold->m_dwCount = iPrice;

	if (_bAddClientItemList(iClientH, pItemGold, &iEraseReq) == TRUE) {

		SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItemGold, NULL, true);

		if (iEraseReq == 1)	delete pItemGold;
	}
	else {

		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			m_pClientList[iClientH]->m_sY, pItemGold);

		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
			pItemGold->m_sSprite, pItemGold->m_sSpriteFrame, pItemGold->m_cItemColor); 

		iCalcTotalWeight(iClientH);

		SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
	}
}

void CGame::ReqRepairItemHandler(int iClientH, char cItemID, char cRepairWhom, char * pString)
{
	char cItemCategory;
	DWORD remainLife, price;
	double d1, d2, d3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	CItem * item = m_pClientList[iClientH]->m_pItemList[cItemID];
	if (!item) return;

	cItemCategory = item->m_cCategory;

	if(cItemCategory >= 1 && cItemCategory <= 10) 
	{
		if (cRepairWhom != 24) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTREPAIRITEM, cItemID, 2, NULL, item->m_cName);
			return;
		}
	}
	else if((cItemCategory >= 43 && cItemCategory <= 50) || (cItemCategory >= 11 && cItemCategory <= 13)) 
	{
		if (cRepairWhom != 15) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTREPAIRITEM, cItemID, 2, NULL, item->m_cName);
			return;
		}
	}
	else
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTREPAIRITEM, cItemID, 1, NULL, item->m_cName);
		return;
	}

	remainLife = item->m_wCurLifeSpan;
	if (remainLife == 0) {
		price = item->m_wPrice / 2;
	}
	else {
		d1 = remainLife;
		if (item->m_wMaxLifeSpan != 0)
			d2 = item->m_wMaxLifeSpan;
		else d2 = 1.0f;
		d3 = (d1 / d2) * 0.5f;
		d2 = item->m_wPrice; 			
		d3 = d3 * d2; 

		price = (item->m_wPrice / 2) - d3;
	}

	SendNotifyMsg(NULL, iClientH, NOTIFY_REPAIRITEMPRICE, cItemID, remainLife, price, item->m_cName);

}

void CGame::ReqRepairItemCofirmHandler(int iClientH, char cItemID, char * pString)
{
	DWORD    remainLife, price;
	char   * cp, cItemCategory, cData[120];
	double   d1, d2, d3;
	DWORD  * dwp, dwGoldCount;
	WORD   * wp;
	int      iRet, iGoldWeight;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	CItem * item = m_pClientList[iClientH]->m_pItemList[cItemID];
	if (!item) return;


	if( m_pClientList[iClientH]->m_bIsOnShop != TRUE ) return ;

	cItemCategory = item->m_cCategory;

	if ( ((cItemCategory >= 1) && (cItemCategory <= 10)) || ((cItemCategory >= 43) && (cItemCategory <= 50)) || 
		((cItemCategory >= 11) && (cItemCategory <= 13))) {

			remainLife = item->m_wCurLifeSpan;
			if (remainLife == 0) {
				price = item->m_wPrice / 2;
			}
			else {
				d1 = remainLife;
				if (item->m_wMaxLifeSpan != 0)
					d2 = item->m_wMaxLifeSpan;
				else d2 = 1.0f;
				d3 = (d1 / d2) * 0.5f;
				d2 = (double)item->m_wPrice; 			
				d3 = d3 * d2; 

				price = (item->m_wPrice / 2) - d3;
			}

			dwGoldCount = dwGetItemCount(iClientH, "Gold");

			if ( dwGoldCount < (DWORD)price ) {
				dwp  = (DWORD *)(cData + INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + INDEX2_MSGTYPE);
				*wp  = NOTIFY_NOTENOUGHGOLD;
				cp   = (char *)(cData + INDEX2_MSGTYPE + 2);
				*cp  = cItemID;
				cp++;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
				switch (iRet) {
				case XSOCKEVENT_QUENEFULL:
				case XSOCKEVENT_SOCKETERROR:
				case XSOCKEVENT_CRITICALERROR:
				case XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
				return;
				}
				return;
			}
			else {

				item->m_wCurLifeSpan = item->m_wMaxLifeSpan;
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMREPAIRED, cItemID, item->m_wCurLifeSpan, NULL, NULL);

#ifdef TAIWANLOG
				if (item->m_cName != NULL) 
					_bItemLog(ITEMLOG_REPAIR,iClientH,item->m_cName,NULL) ;
#endif 

				iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - price );

				iCalcTotalWeight(iClientH);

				m_stCityStatus[m_pClientList[iClientH]->m_side].iFunds += price;
			}
	}
	else {

	}
}

int CGame::iCalcTotalWeight(int iClientH)
{
	register int i, iWeight;
	short sItemIndex;

	CClient * player = m_pClientList[iClientH];

	if (!player) return 0;

	player->m_iAlterItemDropIndex = -1;

	for (sItemIndex = 0; sItemIndex < MAXITEMS; sItemIndex++)
		if  (player->m_pItemList[sItemIndex] != NULL) {
			switch (player->m_pItemList[sItemIndex]->m_sItemEffectType) 
			{
			case ITEMEFFECTTYPE_ALTERITEMDROP:
				if (player->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) {
					player->m_iAlterItemDropIndex = sItemIndex;
				}
				break;
			}
		}

	iWeight = 0;
	for (i = 0; i < MAXITEMS; i++)
		if (player->m_pItemList[i] != NULL) {
			iWeight += iGetItemWeight(player->m_pItemList[i], player->m_pItemList[i]->m_dwCount);
		}

	player->m_iCurWeightLoad = iWeight;

	return iWeight;
}

void CGame::CheckAndNotifyPlayerConnection(int iClientH, char * pMsg, DWORD dwSize)
{
	char   seps[] = "= \t\n";
	char   * token, * cp, cName[11], cBuff[256], cTemp[120];
	register int i;
	WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (dwSize <= 0) return;

	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		return;
	}

	if (strlen(token) > 10) 
		memcpy(cName, token, 10);
	else memcpy(cName, token, strlen(token));


	for (i = 1; i < MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(cName, m_pClientList[i]->m_cCharName, 10) == 0)) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {

				cp = (char * ) cTemp ;
				memcpy(cp, m_pClientList[i]->m_cMapName, 10) ;
				cp += 10 ;

				wp = (WORD *)cp;
				*wp =(WORD) m_pClientList[i]->m_sX;
				cp += 2;

				wp = (WORD *)cp;
				*wp = (WORD) m_pClientList[i]->m_sY;
				cp += 2;
			}

			SendNotifyMsg(NULL, iClientH, NOTIFY_PLAYERONGAME, NULL, NULL, NULL, m_pClientList[i]->m_cCharName, NULL, NULL, NULL, NULL, NULL, NULL, cTemp);

			return;
		}

		//SendNotifyMsg(NULL, iClientH, NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);

		ZeroMemory(cBuff, sizeof(cBuff));
		cp = (char *)cBuff;
		*cp = GSM_REQUEST_FINDCHARACTER;
		cp++;

		wp = (WORD *)cp;
		*wp = GSID;
		cp += 2;

		wp = (WORD *)cp;
		*wp = iClientH;
		cp += 2;

		memcpy(cp, cName, 10);
		cp += 10;

		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;

		bStockMsgToGateServer(cBuff, 25);

}


/*
void CGame::ToggleWhisperPlayer(int iClientH, char * pMsg, DWORD dwMsgSize)
{
char   seps[] = "= \t\n";
char   * cp, * token, cName[11], cBuff[256];
class  CStrTok * pStrTok;
WORD   * wp;
register int i;

if (m_pClientList[iClientH] == NULL) return;
if (dwMsgSize <= 0) return;

ZeroMemory(cName, sizeof(cName));
ZeroMemory(cBuff, sizeof(cBuff));
memcpy(cBuff, pMsg, dwMsgSize);

pStrTok = new class CStrTok(cBuff, seps);
token = pStrTok->pGet();
token = pStrTok->pGet();

if (token == NULL) {
m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;
ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
SendNotifyMsg(NULL, iClientH, NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, cName);
m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = FALSE;
ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
}
else {
if (strlen(token) > 10)
memcpy(cName, token, 10);
else memcpy(cName, token, strlen(token));

m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;
for (i = 1; i < MAXCLIENTS; i++) 
if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {

return;
}

m_pClientList[iClientH]->m_iWhisperPlayerIndex = i;
ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
break;
}


if (m_pClientList[iClientH]->m_iWhisperPlayerIndex == -1) {
ZeroMemory(cBuff, sizeof(cBuff));
cp = (char *)cBuff;
*cp = GSM_REQUEST_FINDCHARACTER;
cp++;

wp = (WORD *)cp;
*wp = GSID;
cp += 2;

wp = (WORD *)cp;
*wp = iClientH;
cp += 2;

memcpy(cp, cName, 10);
cp += 10;

memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
cp += 10;

bStockMsgToGateServer(cBuff, 25);
m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = TRUE;

ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
}
else SendNotifyMsg(NULL, iClientH, NOTIFY_WHISPERMODEON, NULL, NULL, NULL, m_pClientList[iClientH]->m_cWhisperPlayerName);
return;
}

}*/

void CGame::ToggleWhisperPlayer(int iClientH, char * pMsg, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cName[11], cBuff[256];
	register int i;
	char *cp;
	WORD *wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (dwMsgSize <= 0) return;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;
		ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
		m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = FALSE;
		SendNotifyMsg(NULL, iClientH, NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, cName);
	}
	else {
		if (strlen(token) > 10)
			memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));

		m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
				if (i == iClientH) {
					return;
				}
				m_pClientList[iClientH]->m_iWhisperPlayerIndex = i;
				ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
				strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
				break;
			}

			if (m_pClientList[iClientH]->m_iWhisperPlayerIndex == -1) {
				ZeroMemory(cBuff, sizeof(cBuff));
				cp = (char *)cBuff;
				*cp = GSM_REQUEST_FINDCHARACTER;
				cp++;

				wp = (WORD *)cp;
				*wp = GSID;
				cp += 2;

				wp = (WORD *)cp;
				*wp = iClientH;
				cp += 2;

				memcpy(cp, cName, 10);
				cp += 10;

				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;

				bStockMsgToGateServer(cBuff, 25);

				ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
				strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
				m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = TRUE;
			}
			else{
				SendNotifyMsg(NULL, iClientH, NOTIFY_WHISPERMODEON, NULL, NULL, NULL, m_pClientList[iClientH]->m_cWhisperPlayerName);
			}
	}

}

void CGame::SetPlayerProfile(int iClientH, char * pMsg, DWORD dwMsgSize)
{
	char cTemp[256];
	register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize - 7) <= 0) return;

	ZeroMemory(cTemp, sizeof(cTemp));
	memcpy(cTemp, (pMsg + 7), dwMsgSize - 7);


	for (i = 0; i < 256; i++)
		if (cTemp[i] == ' ') cTemp[i] = '_';

	cTemp[255] = NULL;

	ZeroMemory(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile));
	strcpy(m_pClientList[iClientH]->m_cProfile, cTemp);
}

void CGame::GetPlayerProfile(int iClientH, char * pMsg, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cName[11], cBuff[256], cBuff2[500];
	register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {

		if (strlen(token) > 10) 
			memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {

				ZeroMemory(cBuff2, sizeof(cBuff2));

				wsprintf(cBuff2, "%s Profile:%s", cName, m_pClientList[i]->m_cProfile); 
				SendNotifyMsg(NULL, iClientH, NOTIFY_PLAYERPROFILE, NULL, NULL, NULL, cBuff2);

				return;
			}
			SendNotifyMsg(NULL, iClientH, NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	}

	return;
}

void CGame::CalcTotalItemEffect(int iClientH, int iEquipItemID, bool bNotify)
{
	register short sItemIndex;
	int  i, iArrowIndex, iPrevSAType;
	double dV1, dV2, dV3;
	DWORD  dwSWEType, dwSWEValue;
	float bonusDmg;
	short  sTemp;

	CClient * player = m_pClientList[iClientH];

	if (!player) return;

	SetAngel(iClientH, OWNERTYPE_PLAYER, 0, FALSE);

	if ( (player->m_sItemEquipmentStatus[EQUIPPOS_RHAND]   != -1) &&
		(player->m_sItemEquipmentStatus[EQUIPPOS_TWOHAND] != -1) ) {

			if (player->m_pItemList[ player->m_sItemEquipmentStatus[EQUIPPOS_RHAND] ] != NULL) {
				player->m_bIsItemEquipped[player->m_sItemEquipmentStatus[EQUIPPOS_RHAND]] = FALSE;
				player->m_sItemEquipmentStatus[EQUIPPOS_RHAND] = -1;
			}
	}

	player->m_bIsRight = FALSE;

	player->m_cAttackDiceThrow_SM = 0;
	player->m_cAttackDiceRange_SM = 0;
	player->m_cAttackBonus_SM     = 0;  

	player->m_cAttackDiceThrow_L  = 0;
	player->m_cAttackDiceRange_L  = 0;
	player->m_cAttackBonus_L      = 0;

	player->m_iHitRatio = 0;
	player->m_iDefenseRatio = player->GetDex() * 10;
	player->m_iDamageAbsorption_Shield = 0;

	for (i = 0; i < MAXITEMEQUIPPOS; i++)
		player->m_iDamageAbsorption_Armor[i]  = 0;

	player->m_iMPSaveRatio  = 0;
	player->m_iAddResistMagic = 0;

	player->m_iAddPhysicalDamage = 0;
	player->m_iAddMagicalDamage  = 0;
	player->m_addMagicDmgPct = 0;

	player->m_bIsLuckyEffect  = FALSE;
	player->m_iMagicDamageSaveItemIndex = -1;
	player->m_iSideEffect_MaxHPdown = 0;

	player->m_iAddAbsAir   = 0;
	player->m_iAddAbsEarth = 0;
	player->m_iAddAbsFire  = 0;
	player->m_iAddAbsWater = 0;

	player->m_iCustomItemValue_Attack  = 0;
	player->m_iCustomItemValue_Defense = 0;

	player->m_iMinAP_SM = 0;
	player->m_iMinAP_L  = 0;

	player->m_iMaxAP_SM = 0;
	player->m_iMaxAP_L  = 0;

	player->m_iSpecialWeaponEffectType  = 0;		
	player->m_iSpecialWeaponEffectValue = 0;
	player->m_iAddHP = player->m_iAddSP = player->m_iAddMP = 0; 
	player->m_iAddAR = player->m_iAddPR = player->m_iAddDR = 0;
	player->m_iAddMR = player->m_iAddAbsPD = player->m_iAddAbsMD = 0;
	player->m_iAddCD = player->m_iAddExp = player->m_iAddGold = 0;

	player->m_iHPStatic_stock = 0;

	iPrevSAType = player->m_iSpecialAbilityType;

	player->m_iSpecialAbilityType     = 0;
	player->m_specialAbilityLastSec  = 0;
	player->m_iSpecialAbilityEquipPos = 0;

	player->m_iAddTransMana = 0;
	player->m_iAddChargeCritical = 0;

	player->m_iAlterItemDropIndex = -1;

	for (sItemIndex = 0; sItemIndex < MAXITEMS; sItemIndex++)
	{
		if  (CItem * item = player->m_pItemList[sItemIndex]) {
			switch (item->m_sItemEffectType) {
			case ITEMEFFECTTYPE_ALTERITEMDROP:
				if (item->m_wCurLifeSpan > 0) {
					player->m_iAlterItemDropIndex = sItemIndex;
				}
			break;
			}
		}
	}

	CItem * item;

	for (sItemIndex = 0; sItemIndex < MAXITEMS; sItemIndex++)
	{
		if((item = player->m_pItemList[sItemIndex]) && 
			player->m_bIsItemEquipped[sItemIndex]) 
		{
			switch (item->m_sItemEffectType)
			{

			case ITEMEFFECTTYPE_MAGICDAMAGESAVE:
				player->m_iMagicDamageSaveItemIndex = sItemIndex;
				break;

			case ITEMEFFECTTYPE_HP:
				player->m_iHPStatic_stock += item->m_sItemEffectValue4 ;
				break; 

			case ITEMEFFECTTYPE_JEWELRY:
				dwSWEType = GetNibble(item->m_dwAttribute, 5);
				if (dwSWEType) 
				{
					dwSWEValue = GetNibble(item->m_dwAttribute, 4);

					switch (dwSWEType) 
					{
					case ITEMSTAT_SHARP: 					
						player->m_cAttackDiceRange_SM++;
						player->m_cAttackDiceRange_L++;
						break;

					case ITEMSTAT_ANCIENT: 
						player->m_cAttackDiceRange_SM += 2;
						player->m_cAttackDiceRange_L  += 2;
						break;


					case ITEMSTAT_MANACONV: 					
						player->m_iAddTransMana += dwSWEValue;
						if (player->m_iAddTransMana > 13) player->m_iAddTransMana = 13;
						break;

					case ITEMSTAT_CRITICAL2: 					
						player->m_iAddChargeCritical += dwSWEValue;
						if (player->m_iAddChargeCritical > 20) player->m_iAddChargeCritical = 20;
						break;
					}
				}


				dwSWEType = GetNibble(item->m_dwAttribute, 3);
				if (dwSWEType)
				{
					dwSWEValue = GetNibble(item->m_dwAttribute, 2); 

					switch (dwSWEType) 
					{
					case 0:  break;
					case 1:  player->m_iAddPR += (int)dwSWEValue*7; break;
					case 2:  player->m_iAddAR += (int)dwSWEValue*7; break;
					case 3:  player->m_iAddDR += (int)dwSWEValue*7; break;
					case 4:  player->m_iAddHP += (int)dwSWEValue*7; break;
					case 5:  player->m_iAddSP += (int)dwSWEValue*7; break;
					case 6:  player->m_iAddMP += (int)dwSWEValue*7; break;
					case 7:  player->m_iAddMR += (int)dwSWEValue*7; break;
					case 8:  player->m_iDamageAbsorption_Armor[item->m_cEquipPos] += (int)dwSWEValue*3; break;
					case 9:  
						player->m_iAddAbsMD += (int)dwSWEValue*3; 
						if (player->m_iAddAbsMD > 80) player->m_iAddAbsMD = 80;
						break;
					case 10: player->m_iAddCD    += (int)dwSWEValue; break;
					case 11: player->m_iAddExp   += (int)dwSWEValue*10; break;
					case 12: player->m_iAddGold  += (int)dwSWEValue*10; break;
					}
				}
				break;

			case ITEMEFFECTTYPE_ATTACK_SPECABLTY:
			case ITEMEFFECTTYPE_ATTACK_DEFENSE:
			case ITEMEFFECTTYPE_ATTACK_MANASAVE:
			case ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
			case ITEMEFFECTTYPE_ATTACK:
				player->m_cAttackDiceThrow_SM = item->m_sItemEffectValue1 * 100;
				player->m_cAttackDiceRange_SM = item->m_sItemEffectValue2 * 100;
				player->m_cAttackBonus_SM     = item->m_sItemEffectValue3*100;
				if(item->m_sItemEffectType == ITEMEFFECTTYPE_ATTACK_MANASAVE)
				{	
					player->m_cAttackDiceThrow_L  = player->m_cAttackDiceThrow_SM;
					player->m_cAttackDiceRange_L  = player->m_cAttackDiceRange_SM;
					player->m_cAttackBonus_L      = player->m_cAttackBonus_SM;
				}else{
					player->m_cAttackDiceThrow_L  = item->m_sItemEffectValue4;
					player->m_cAttackDiceRange_L  = item->m_sItemEffectValue5;
					player->m_cAttackBonus_L      = item->m_sItemEffectValue6;
				}

				bonusDmg = (item->m_dwAttribute & 0xF0000000) >> 28;

				player->m_iAddPhysicalDamage += bonusDmg;

				switch(item->m_sIDnum)
				{
				case ITEM_DMMAGICSTAFF: case ITEM_BLACKMAGETEMPLE: case ITEM_DMMAGICWAND:
					player->m_iAddMagicalDamage  += ceil(bonusDmg/2);  break;
				default:
					player->m_iAddMagicalDamage  += bonusDmg;
				}


				player->m_iHitRatio += player->m_cSkillMastery[ item->m_sRelatedSkill ]; 


				//player->m_iHitRatio_ItemEffect_SM += item->m_sSM_HitRatio;
				//player->m_iHitRatio_ItemEffect_L  += item->m_sL_HitRatio;
				//player->m_sUsingWeaponSkill = item->m_sRelatedSkill;


				if ((item->m_dwAttribute & 0x00000001) != NULL) {
					player->m_iCustomItemValue_Attack += item->m_sItemSpecEffectValue2;
					if (player->m_iCustomItemValue_Attack > 100)
						player->m_iCustomItemValue_Attack = 100;

					if (player->m_iCustomItemValue_Attack < -100)
						player->m_iCustomItemValue_Attack = -100;

					if (player->m_iCustomItemValue_Attack > 0) {

						dV2 = (double)player->m_iCustomItemValue_Attack;
						dV1 = (dV2/100.0f)*(5.0f);
						player->m_iMinAP_SM = player->m_cAttackDiceThrow_SM + 
							player->m_cAttackBonus_SM + (int)dV1;

						player->m_iMinAP_L  = player->m_cAttackDiceThrow_L + 
							player->m_cAttackBonus_L + (int)dV1;

						if (player->m_iMinAP_SM < 1) player->m_iMinAP_SM = 1;
						if (player->m_iMinAP_L < 1)  player->m_iMinAP_L = 1;


						if (player->m_iMinAP_SM > (player->m_cAttackDiceThrow_SM * player->m_cAttackDiceRange_SM + player->m_cAttackBonus_SM)) 
							player->m_iMinAP_SM = (player->m_cAttackDiceThrow_SM * player->m_cAttackDiceRange_SM + player->m_cAttackBonus_SM);

						if (player->m_iMinAP_L > (player->m_cAttackDiceThrow_L * player->m_cAttackDiceRange_L + player->m_cAttackBonus_L)) 
							player->m_iMinAP_L = (player->m_cAttackDiceThrow_L * player->m_cAttackDiceRange_L + player->m_cAttackBonus_L);
					}
					else if (player->m_iCustomItemValue_Attack < 0) {
						dV2 = (double)player->m_iCustomItemValue_Attack;
						dV1 = (dV2/100.0f)*(5.0f);
						player->m_iMaxAP_SM = player->m_cAttackDiceThrow_SM * player->m_cAttackDiceRange_SM 
							+ player->m_cAttackBonus_SM + (int)dV1;

						player->m_iMaxAP_L  = player->m_cAttackDiceThrow_L * player->m_cAttackDiceRange_L 
							+ player->m_cAttackBonus_L + (int)dV1;

						if (player->m_iMaxAP_SM < 1) player->m_iMaxAP_SM = 1;
						if (player->m_iMaxAP_L < 1)  player->m_iMaxAP_L = 1;


						if (player->m_iMaxAP_SM < (player->m_cAttackDiceThrow_SM * player->m_cAttackDiceRange_SM + player->m_cAttackBonus_SM)) 
							player->m_iMaxAP_SM = (player->m_cAttackDiceThrow_SM * player->m_cAttackDiceRange_SM + player->m_cAttackBonus_SM);

						if (player->m_iMaxAP_L < (player->m_cAttackDiceThrow_L * player->m_cAttackDiceRange_L + player->m_cAttackBonus_L)) 
							player->m_iMaxAP_L = (player->m_cAttackDiceThrow_L * player->m_cAttackDiceRange_L + player->m_cAttackBonus_L);
					}
				}


				if (dwSWEType  = GetNibble(item->m_dwAttribute, 5)) {
					dwSWEValue = GetNibble(item->m_dwAttribute, 4);

					player->m_iSpecialWeaponEffectType  = (int)dwSWEType;
					player->m_iSpecialWeaponEffectValue = (int)dwSWEValue;

					switch (dwSWEType) 
					{
					case ITEMSTAT_RIGHTEOUS:
						player->m_bIsRight = TRUE;
						break;    
					case ITEMSTAT_SHARP:
						player->m_cAttackDiceRange_SM++;
						player->m_cAttackDiceRange_L++;
						break;

					case ITEMSTAT_ANCIENT:
						player->m_cAttackDiceRange_SM += 2;
						player->m_cAttackDiceRange_L  += 2;
						break;
					}
				}


				if ((item->m_dwAttribute & 0x0000F000) != NULL) {
					dwSWEType  = (item->m_dwAttribute & 0x0000F000) >> 12;  
					dwSWEValue = (item->m_dwAttribute & 0x00000F00) >> 8;

					switch (dwSWEType) 
					{
					case 0:  break;
					case 1:  player->m_iAddPR += (int)dwSWEValue*7; break;
					case 2:  player->m_iAddAR += (int)dwSWEValue*7; break;
					case 3:  player->m_iAddDR += (int)dwSWEValue*7; break;
					case 4:  player->m_iAddHP += (int)dwSWEValue*7; break;
					case 5:  player->m_iAddSP += (int)dwSWEValue*7; break;
					case 6:  player->m_iAddMP += (int)dwSWEValue*7; break;
					case 7:  player->m_iAddMR += (int)dwSWEValue*7; break;
					case 8:  player->m_iDamageAbsorption_Armor[item->m_cEquipPos] += (int)dwSWEValue*3; break;
					case 9:  player->m_iAddAbsMD += (int)dwSWEValue*3; break;
					case 10: player->m_iAddCD    += (int)dwSWEValue; break;
					case 11: player->m_iAddExp   += (int)dwSWEValue*10; break;
					case 12: player->m_iAddGold  += (int)dwSWEValue*10; break;
					}


					switch (dwSWEType) 
					{
					case 9: if (player->m_iAddAbsMD > 80) player->m_iAddAbsMD = 80; break;
					}
				}

				switch (item->m_sItemEffectType) 
				{
				case ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
					player->m_iSideEffect_MaxHPdown = item->m_sSpecialEffect;
					player->m_iAddAR += 70;
					break;

				case ITEMEFFECTTYPE_ATTACK_MANASAVE:
					player->m_iMPSaveRatio    += item->m_sItemEffectValue4;
					if (player->m_iMPSaveRatio > 80) player->m_iMPSaveRatio = 80;
					switch(item->m_sItemEffectValue5)
					{
					case WET_ADDMAGICDMGPCT:
						player->m_addMagicDmgPct += item->m_sItemEffectValue6;
						break;
					}
					break;

				case ITEMEFFECTTYPE_ATTACK_DEFENSE:

					player->m_iDamageAbsorption_Armor[EQUIPPOS_BODY] += item->m_sSpecialEffect;
					break;

				case ITEMEFFECTTYPE_ATTACK_SPECABLTY:

					player->m_iSpecialAbilityType    = item->m_sSpecialEffect;

					player->m_specialAbilityLastSec = item->m_sSpecialEffectValue1; 
					player->m_iSpecialAbilityEquipPos = (int)item->m_cEquipPos;


					if ((bNotify == TRUE) && (iEquipItemID == (int)sItemIndex))
						SendNotifyMsg(NULL, iClientH, NOTIFY_SPECIALABILITYSTATUS, 2, player->m_iSpecialAbilityType, player->m_iSpecialAbilityTime, NULL);
					break;
				}
				break;

			case ITEMEFFECTTYPE_ADDEFFECT:
				switch (item->m_sItemEffectValue1) 
				{
				case 1:

					player->m_iAddResistMagic += item->m_sItemEffectValue2;
					break;

				case 2:
					player->m_iMPSaveRatio += item->m_sItemEffectValue2;
					if (player->m_iMPSaveRatio > 80) player->m_iMPSaveRatio = 80;
					break;

				case 3:

					player->m_iAddPhysicalDamage += item->m_sItemEffectValue2;
					break;

				case 4:

					player->m_iDefenseRatio += item->m_sItemEffectValue2;
					break;

				case 5:
					if (item->m_sItemEffectValue2 != 0)
						player->m_bIsLuckyEffect = TRUE;
					else player->m_bIsLuckyEffect = FALSE;
					break;

				case 6:

					player->m_iAddMagicalDamage += item->m_sItemEffectValue2;
					break;

				case 7:
					player->m_iAddAbsAir += item->m_sItemEffectValue2;
					break;

				case 8:
					player->m_iAddAbsEarth += item->m_sItemEffectValue2;
					break;

				case 9:
					player->m_iAddAbsFire += item->m_sItemEffectValue2;
					break;

				case 10:
					player->m_iAddAbsWater += item->m_sItemEffectValue2;
					break;

				case 11:
					player->m_iAddPR += item->m_sItemEffectValue2;
					break;

				case 12:
					player->m_iHitRatio += item->m_sItemEffectValue2;
					break;

				case 13: 
					player->m_iAddHP += (item->m_sItemSpecEffectValue2 /5);
					break;

				case 14:
					player->m_iAddAR += (item->m_sItemSpecEffectValue2 /5);
					break;

				case 15:
					player->m_iAddAbsMD += (item->m_sItemSpecEffectValue2 /10);
					if (player->m_iAddAbsMD > 80) player->m_iAddAbsMD = 80; 
					break;

				case 20:	
					sTemp = (item->m_sItemSpecEffectValue2 /10);
					player->m_iDamageAbsorption_Armor[EQUIPPOS_HEAD]  += sTemp;
					player->m_iDamageAbsorption_Armor[EQUIPPOS_BODY]  += sTemp;	
					player->m_iDamageAbsorption_Armor[EQUIPPOS_ARMS]  += sTemp;
					player->m_iDamageAbsorption_Armor[EQUIPPOS_PANTS] += sTemp;
					break;	

				case 16: // Angel STR//AngelicPendant(STR)
					player->SetAngelStr(
						((item->m_dwAttribute & 0xF0000000) >> 28) + 1
						);
					SetAngel(iClientH, OWNERTYPE_PLAYER, 1);
					break;
				case 17: // Angel DEX //AngelicPendant(DEX)
					player->SetAngelDex(
						((item->m_dwAttribute & 0xF0000000) >> 28) + 1
						);
					SetAngel(iClientH, OWNERTYPE_PLAYER, 2);
					break;
				case 18: // Angel INT//AngelicPendant(INT)
					player->SetAngelInt(
						((item->m_dwAttribute & 0xF0000000) >> 28) + 1
						);
					SetAngel(iClientH, OWNERTYPE_PLAYER, 3);
					break;
				case 19: // Angel MAG//AngelicPendant(MAG)
					player->SetAngelMag(
						((item->m_dwAttribute & 0xF0000000) >> 28) + 1
						);
					SetAngel(iClientH, OWNERTYPE_PLAYER, 4);
					break;
				}
				break;

			case ITEMEFFECTTYPE_ATTACK_ARROW:
				if ( (player->m_cArrowIndex != -1) && 
					(player->m_pItemList[player->m_cArrowIndex] == NULL) ) {

						player->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
				}
				else if (player->m_cArrowIndex == -1) 
					player->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

				if (player->m_cArrowIndex == -1) {
					player->m_cAttackDiceThrow_SM = 0;
					player->m_cAttackDiceRange_SM = 0;
					player->m_cAttackBonus_SM     = 0;
					player->m_cAttackDiceThrow_L  = 0;
					player->m_cAttackDiceRange_L  = 0;
					player->m_cAttackBonus_L      = 0;
				}
				else {
					iArrowIndex = player->m_cArrowIndex;
					/*
					player->m_cAttackDiceThrow_SM = player->m_pItemList[iArrowIndex]->m_sItemEffectValue1;
					player->m_cAttackDiceRange_SM = player->m_pItemList[iArrowIndex]->m_sItemEffectValue2;
					player->m_cAttackBonus_SM     = player->m_pItemList[iArrowIndex]->m_sItemEffectValue3;
					player->m_cAttackDiceThrow_L  = player->m_pItemList[iArrowIndex]->m_sItemEffectValue4;
					player->m_cAttackDiceRange_L  = player->m_pItemList[iArrowIndex]->m_sItemEffectValue5;
					player->m_cAttackBonus_L      = player->m_pItemList[iArrowIndex]->m_sItemEffectValue6;
					*/

					player->m_cAttackDiceThrow_SM = item->m_sItemEffectValue1;
					player->m_cAttackDiceRange_SM = item->m_sItemEffectValue2;
					player->m_cAttackBonus_SM     = item->m_sItemEffectValue3;
					player->m_cAttackDiceThrow_L  = item->m_sItemEffectValue4;
					player->m_cAttackDiceRange_L  = item->m_sItemEffectValue5;
					player->m_cAttackBonus_L      = item->m_sItemEffectValue6;
				}


				player->m_iHitRatio += player->m_cSkillMastery[ item->m_sRelatedSkill ]; 

				// player->m_iHitRatio_ItemEffect_SM += item->m_sSM_HitRatio;
				// player->m_iHitRatio_ItemEffect_L  += item->m_sL_HitRatio;
				break;

			case ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
			case ITEMEFFECTTYPE_DEFENSE:
				player->m_iDefenseRatio += player->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;

				//player->m_iHitRatio_ItemEffect_SM += item->m_sSM_HitRatio;
				//player->m_iHitRatio_ItemEffect_L  += item->m_sL_HitRatio;


				if ((item->m_dwAttribute & 0x00000001) != NULL) {
					player->m_iCustomItemValue_Defense += item->m_sItemSpecEffectValue2;


					dV2 = (double)item->m_sItemSpecEffectValue2;
					dV3 = (double)player->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;
					dV1 = (double)(dV2 / 100.0f)*dV3;

					dV1 = dV1 / 2.0f;
					player->m_iDefenseRatio += (int)dV1;
					if (player->m_iDefenseRatio <= 0) player->m_iDefenseRatio = 1;
				}


				if ((item->m_dwAttribute & 0x00F00000) != NULL) {
					dwSWEType  = (item->m_dwAttribute & 0x00F00000) >> 20;  
					dwSWEValue = (item->m_dwAttribute & 0x000F0000) >> 16;


					switch (dwSWEType) 
					{
					case ITEMSTAT_SHARP: 					
						player->m_cAttackDiceRange_SM++;
						player->m_cAttackDiceRange_L++;
						break;

					case ITEMSTAT_ANCIENT: 
						player->m_cAttackDiceRange_SM += 2;
						player->m_cAttackDiceRange_L  += 2;
						break;


					case ITEMSTAT_MANACONV: 					
						player->m_iAddTransMana += dwSWEValue;
						if (player->m_iAddTransMana > 13) player->m_iAddTransMana = 13;
						break;

					case ITEMSTAT_CRITICAL2: 					
						player->m_iAddChargeCritical += dwSWEValue;
						if (player->m_iAddChargeCritical > 20) player->m_iAddChargeCritical = 20;
						break;
					}
				}


				if ((item->m_dwAttribute & 0x0000F000) != NULL) {
					dwSWEType  = (item->m_dwAttribute & 0x0000F000) >> 12;  
					dwSWEValue = (item->m_dwAttribute & 0x00000F00) >> 8;


					switch (dwSWEType) 
					{
					case 0:  break;
					case 1:  player->m_iAddPR += (int)dwSWEValue*7; break;
					case 2:  player->m_iAddAR += (int)dwSWEValue*7; break;
					case 3:  player->m_iAddDR += (int)dwSWEValue*7; break;
					case 4:  player->m_iAddHP += (int)dwSWEValue*7; break;
					case 5:  player->m_iAddSP += (int)dwSWEValue*7; break;
					case 6:  player->m_iAddMP += (int)dwSWEValue*7; break;
					case 7:  player->m_iAddMR += (int)dwSWEValue*7; break;
					case 8:  player->m_iDamageAbsorption_Armor[item->m_cEquipPos] += (int)dwSWEValue*3; break;
					case 9:  player->m_iAddAbsMD += (int)dwSWEValue*3; break;
					case 10: player->m_iAddCD    += (int)dwSWEValue; break;
					case 11: player->m_iAddExp   += (int)dwSWEValue*10; break;
					case 12: player->m_iAddGold  += (int)dwSWEValue*10; break;
					}

					switch (dwSWEType) 
					{
					case 9: if (player->m_iAddAbsMD > 80) player->m_iAddAbsMD = 80; break; 				
					}
				}

				switch(item->m_cEquipPos) 
				{
				case EQUIPPOS_LHAND:
					player->m_iDamageAbsorption_Shield	= item->m_sItemEffectValue2;
					break;
				default:
					player->m_iDamageAbsorption_Armor[item->m_cEquipPos] += item->m_sItemEffectValue2;
					break;
				}

				switch (item->m_sItemEffectType) 
				{
				case ITEMEFFECTTYPE_DEFENSE_SPECABLTY:

					player->m_iSpecialAbilityType = item->m_sSpecialEffect;

					player->m_specialAbilityLastSec = item->m_sSpecialEffectValue1; 
					player->m_iSpecialAbilityEquipPos = (int)item->m_cEquipPos;


					if ((bNotify == TRUE) && (iEquipItemID == (int)sItemIndex))
						SendNotifyMsg(NULL, iClientH, NOTIFY_SPECIALABILITYSTATUS, 2, player->m_iSpecialAbilityType, player->m_iSpecialAbilityTime, NULL);
					break;
				}
				break;
			}
		}
	}

	if ((iPrevSAType != 0) && (player->m_iSpecialAbilityType == 0) && (bNotify == TRUE)) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_SPECIALABILITYSTATUS, 4, NULL, NULL, NULL);
		if (player->m_bIsSpecialAbilityEnabled == TRUE) {
			player->m_bIsSpecialAbilityEnabled = FALSE;

			player->m_iSpecialAbilityTime = SPECABLTYTIMESEC;
			sTemp = player->m_sAppr4;
			sTemp = sTemp & 0xFF0F;
			player->m_sAppr4 = sTemp;
			SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTNULLACTION, NULL, NULL, NULL);
		}
	}

	if ((iPrevSAType != 0) && (player->m_iSpecialAbilityType != 0) && 
		(iPrevSAType != player->m_iSpecialAbilityType) && (bNotify == TRUE)) {

			if (player->m_bIsSpecialAbilityEnabled == TRUE) {

				SendNotifyMsg(NULL, i, NOTIFY_SPECIALABILITYSTATUS, 3, NULL, NULL, NULL);
				player->m_bIsSpecialAbilityEnabled = FALSE;

				player->m_iSpecialAbilityTime = SPECABLTYTIMESEC;
				sTemp = player->m_sAppr4;
				sTemp = sTemp & 0xFF0F;
				player->m_sAppr4 = sTemp;
				SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTNULLACTION, NULL, NULL, NULL);
			}
	}
}

bool CGame::bAnalyzeCriminalAction(int iClientH, short dX, short dY, bool bIsCheck)
{
	int   iNamingValue, tX, tY;
	short sOwnerH;
	char  cOwnerType, cName[11], cNpcName[21];
	char  cNpcWaypoint[11];

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return FALSE;
	if (m_bIsCrusadeMode == TRUE) return FALSE;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone) return FALSE;

	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

	if ((cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL)) {
		if (_bGetIsPlayerHostile(iClientH, sOwnerH) != TRUE) {
			if (bIsCheck == TRUE) return TRUE;

			ZeroMemory(cNpcName, sizeof(cNpcName));
			if (strcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ARESDEN]) == 0) 
				strcpy(cNpcName, "Guard-Aresden");
			else if (strcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ELVINE]) == 0) 
				strcpy(cNpcName, "Guard-Elvine");
			else  if (strcmp(m_pClientList[iClientH]->m_cMapName, sideMap[NEUTRAL]) == 0) 
				strcpy(cNpcName, "Guard-Neutral");
			else  if (strcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ISTRIA]) == 0) 
				strcpy(cNpcName, "Guard-Istria");
			else strcpy(cNpcName, "XXX");  

			iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {

			}
			else {

				ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

				ZeroMemory(cName, sizeof(cName));
				wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;

				tX = (int)m_pClientList[iClientH]->m_sX;
				tY = (int)m_pClientList[iClientH]->m_sY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, MOVETYPE_RANDOM, 
					&tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, TRUE) == FALSE) {
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				} 
				else {

					bSetNpcAttackMode(cName, iClientH, OWNERTYPE_PLAYER, TRUE);
				}
			}
		}
	}

	return FALSE;
}

bool CGame::_bGetIsPlayerHostile(int iClientH, int sOwnerH)
{
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[sOwnerH]  == NULL) return FALSE;

	if (iClientH == sOwnerH) return TRUE;

	if (m_pClientList[iClientH]->IsNeutral()) {
		if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
			return TRUE;
		else return FALSE;
	}
	else {
		if (m_pClientList[iClientH]->m_side != m_pClientList[sOwnerH]->m_side) {
			return TRUE;
		}
		else {
			if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
				return TRUE;
			else return FALSE;
		}
	}

	return FALSE;
}

void CGame::bSetNpcAttackMode(char * cName, int iTargetH, char cTargetType, bool bIsPermAttack)
{
	int iIndex = NULL;

	for (int i = 1; i < MAXNPCS; i++)
	{
		if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, cName, 5) == 0) ) {
			iIndex = i;
			break;
		}
	}

	if (!iIndex)	return;

	switch (cTargetType) 
	{
	case OWNERTYPE_PLAYER:
		if (m_pClientList[iTargetH] == NULL) return;
		break;

	case OWNERTYPE_NPC:
		if (m_pNpcList[iTargetH] == NULL) return;
		break;
	}

	m_pNpcList[iIndex]->m_cBehavior          = BEHAVIOR_ATTACK;
	m_pNpcList[iIndex]->m_sBehaviorTurnCount = 0;
	m_pNpcList[iIndex]->m_iTargetIndex = iTargetH;
	m_pNpcList[iIndex]->m_cTargetType  = cTargetType;

	m_pNpcList[iIndex]->m_bIsPermAttackMode = bIsPermAttack;
}


void CGame::PoisonEffect(int iClientH, int iV1)
{
	int iPoisonLevel, iDamage, iPrevHP, iProb;

	if (m_pClientList[iClientH] == NULL)     return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	iPoisonLevel = m_pClientList[iClientH]->m_iPoisonLevel;

	iDamage = dice(1, iPoisonLevel);

	iPrevHP = m_pClientList[iClientH]->m_iHP;
	m_pClientList[iClientH]->m_iHP -= iDamage;
	if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 1;

	if (iPrevHP != m_pClientList[iClientH]->m_iHP)
		SendNotifyMsg(NULL, iClientH, NOTIFY_HP, NULL, NULL, NULL, NULL);

	//iProb = m_pClientList[iClientH]->m_cSkillMastery[SKILL_POISONRES] -10 +m_pClientList[iClientH]->m_iAddPR;
	iProb = 10 +m_pClientList[iClientH]->m_iAddPR;
	if (iProb <= 10) iProb = 10;
	if (dice(1,100) <= iProb) {
		m_pClientList[iClientH]->m_bIsPoisoned = FALSE;
		m_pClientList[iClientH]->SetStatusFlag(STATUS_POISON, FALSE);
		SendNotifyMsg(NULL, iClientH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_POISON, NULL, NULL, NULL);
	}
}

bool CGame::bCheckBadWord(char * pString)
{
	char * cp;

	cp = pString;
	while (*cp != NULL) {

		cp++;
	}

	return FALSE;
}

void CGame::CheckDayOrNightMode()
{
	SYSTEMTIME SysTime;
	char cPrevMode;
	int  i;

	cPrevMode = m_cDayOrNight;

	GetLocalTime(&SysTime);
	if (SysTime.wMinute >= NIGHTTIME) 
		m_cDayOrNight = 2;
	else m_cDayOrNight = 1;

	if (cPrevMode != m_cDayOrNight) {

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				if ((m_pClientList[i]->m_cMapIndex >= 0) && 
					(m_pMapList[m_pClientList[i]->m_cMapIndex] != NULL) &&
					(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFixedDayMode == FALSE))
					SendNotifyMsg(NULL, i, NOTIFY_TIMECHANGE, m_cDayOrNight, NULL, NULL, NULL);
			}
	}
}


void CGame::ShutUpPlayer(int iClientH, char * pMsg, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cName[11], cBuff[256],* cp;
	WORD * wp ;
	register int i, iTime;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {

		if (strlen(token) > 10) 
			memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));


		token = pStrTok->pGet();
		if (token == NULL) 
			iTime = 0;
		else iTime = atoi(token);

		if (iTime < 0) iTime = 0;

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {


				m_pClientList[i]->m_iTimeLeft_ShutUp = iTime*20; 
				SendNotifyMsg(NULL, iClientH, NOTIFY_PLAYERSHUTUP, iTime, NULL, NULL, cName);
				SendNotifyMsg(NULL, i, NOTIFY_PLAYERSHUTUP, iTime, NULL, NULL, cName);

				// Admin Log

				wsprintf(g_cTxt, "GM Order(%s): Shutup PC(%s) (%d)Min", m_pClientList[iClientH]->m_cCharName, 
					m_pClientList[i]->m_cCharName, iTime);

#ifdef TAIWANLOG
				_bItemLog(ITEMLOG_SHUTUP,i,m_pClientList[iClientH]->m_cCharName,NULL) ;

				// Admin Log

				wsprintf(g_cTxt, "GM Order(%s): Shutup PC(%s) (%d)Min", m_pClientList[iClientH]->m_cCharName, 
					m_pClientList[i]->m_cCharName, iTime);

				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);
#endif

				return;
			}

			ZeroMemory(cBuff, sizeof(cBuff));
			cp = (char *)cBuff;
			*cp = GSM_REQUEST_SHUTUPPLAYER;
			cp++;

			wp = (WORD *)cp;
			*wp = GSID;
			cp += 2;

			wp = (WORD *)cp;
			*wp = iClientH;
			cp += 2;

			memcpy(cp, cName, 10);
			cp += 10;

			wp = (WORD *)cp;
			*wp = iTime ;
			cp += 2;

			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;

			bStockMsgToGateServer(cBuff, 27);

			return;

	}

	return;
}


void CGame::SetPlayerReputation(int iClientH, char * pMsg, char cValue, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cName[11], cBuff[256];
	register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iLevel < 15) return;

	if ((m_pClientList[iClientH]->m_iTimeLeft_Rating != 0) || (m_pClientList[iClientH]->m_iPKCount != 0)) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTRATING, m_pClientList[iClientH]->m_iTimeLeft_Rating, NULL, NULL, NULL);
		return;
	}
	else if ( m_pClientList[iClientH]->IsNeutral() ) { // 2002-11-15
		SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTRATING, 0, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {

		if (strlen(token) > 10) 
			memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
				if (i != iClientH) {
					if(strcmp(m_pClientList[i]->m_cIPaddress,m_pClientList[iClientH]->m_cIPaddress) != 0){
						if (cValue == 0) 
							m_pClientList[i]->m_reputation--;
						else if (cValue == 1)
							m_pClientList[i]->m_reputation++;

						m_pClientList[iClientH]->m_iTimeLeft_Rating = 20*60;

						SendNotifyMsg(NULL, i, NOTIFY_RATINGPLAYER, cValue, NULL, NULL, cName);
						SendNotifyMsg(NULL, iClientH, NOTIFY_RATINGPLAYER, cValue, NULL, NULL, cName);
					}
					return;
				}
			}
			SendNotifyMsg(NULL, iClientH, NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	}

	return;
}

bool CGame::bReadNotifyMsgListFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, * token, cReadMode;
	char seps[] = "=\t\n;";
	
	int   i;

	cReadMode = 0;
	m_iTotalNoticeMsg = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		PutLogList("(!) Notify Message list file not found!...");
		return FALSE;
	}
	else {
		//PutLogList("(*) Reading Notify Message list file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		StrTok pStrTok(new CStrTok(cp, seps));
		token = pStrTok->pGet();
		//token = strtok( cp, seps );   
		while( token != NULL )   {

			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					for (i = 0; i < MAXNOTIFYMSGS; i++) 
						if (m_pNoticeMsgList[i] == NULL) {
							m_pNoticeMsgList[i] = new class CMsg;
							m_pNoticeMsgList[i]->bPut(NULL, token, strlen(token), NULL, NULL);
							m_iTotalNoticeMsg++;
							break;
						}
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "notify_msg", 10) == 0) cReadMode = 1;
			}

			token = pStrTok->pGet();
			//token = strtok( NULL, seps );
		}

		delete[] cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}


void CGame::NoticeHandler()
{
	char  cTemp, cBuffer[1000], cKey;
	DWORD dwSize, dwTime = timeGetTime();
	register int i, iMsgIndex, iTemp;


	if (m_iTotalNoticeMsg <= 1) return;

	if ((dwTime - m_dwNoticeTime) > NOTICETIME) {

		m_dwNoticeTime = dwTime;
		do {
			iMsgIndex = dice(1, m_iTotalNoticeMsg) - 1;
		} while (iMsgIndex == m_iPrevSendNoticeMsg);

		m_iPrevSendNoticeMsg = iMsgIndex;

		ZeroMemory(cBuffer, sizeof(cBuffer));
		if (m_pNoticeMsgList[iMsgIndex] != NULL) {
			m_pNoticeMsgList[iMsgIndex]->Get(&cTemp, cBuffer, &dwSize, &iTemp, &cKey);
		}

		for (i = 1; i < MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				SendNotifyMsg(NULL, i, NOTIFY_NOTICEMSG, NULL, NULL, NULL, cBuffer);
			}
	}
}


void CGame::ResponseSavePlayerDataReplyHandler(char * pData, DWORD dwMsgSize)
{
	char * cp, cCharName[11];
	register int i;

	ZeroMemory(cCharName, sizeof(cCharName));

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);

	for (i = 0; i < MAXCLIENTS; i++) 
		if (m_pClientList[i] != NULL) {
			if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {
				SendNotifyMsg(NULL, i, NOTIFY_SERVERCHANGE, NULL, NULL, NULL, NULL);
			}
		}
}

void CGame::CalcExpStock(int iClientH)
{
	bool bIsLevelUp;
	class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iExpStock <= 0) return;

	// !!!!
	//if ((m_pClientList[iClientH]->m_iLevel >= ) && (m_pClientList[iClientH]->m_iExp >= m_iLevelExpTable[])) return;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == MAPTYPE_NOPENALTY_NOREWARD) {
		m_pClientList[iClientH]->m_iExpStock = 0;
		return;
	}

	m_pClientList[iClientH]->m_iExp += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iAutoExpAmount += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iExpStock = 0;

	if (bCheckLimitedUser(iClientH) == FALSE) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_EXP, NULL, NULL, NULL, NULL);
	}
	bIsLevelUp = bCheckLevelUp(iClientH);

	if ((bIsLevelUp == TRUE) && (m_pClientList[iClientH]->m_iLevel <= 5)) {

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, "Gold") == FALSE) {
			delete pItem;
			return;
		}
		else pItem->m_dwCount = (DWORD)100;
		bAddItem(iClientH, pItem);
	}

	if ((bIsLevelUp == TRUE) && (m_pClientList[iClientH]->m_iLevel > 5 ) &&  (m_pClientList[iClientH]->m_iLevel <= 20) ) {

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, "Gold") == FALSE) {
			delete pItem;
			return;
		}
		else pItem->m_dwCount = (DWORD)3000;
		bAddItem(iClientH, pItem);
	}

}

int CGame::iGetExpLevel(int iExp)
{
	unsigned int i;

	for (i = 1; i < 890; i++) 
		if ((m_iLevelExpTable[i] <= iExp) && (m_iLevelExpTable[i+1] > iExp)) return i;

	return 0;
}

void CGame::AdminOrder_CallGuard(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cName[11], cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11];
	register int i, iNamingValue, tX, tY;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {

		if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {

				if (memcmp(m_pClientList[i]->m_cMapName, sideMap[ARESDEN], 7) == 0) 
					strcpy(cNpcName, "Guard-Aresden");
				else if (memcmp(m_pClientList[i]->m_cMapName, sideMap[ELVINE], 6) == 0) 
					strcpy(cNpcName, "Guard-Elvine");
				else if (memcmp(m_pClientList[i]->m_cMapName, sideMap[ISTRIA], 6) == 0) 
					strcpy(cNpcName, "Guard-Istria");
				else strcpy(cNpcName, "Guard-Neutral");  

				iNamingValue = m_pMapList[ m_pClientList[i]->m_cMapIndex ]->iGetEmptyNamingValue();
				if (iNamingValue == -1) {

				}
				else {

					wsprintf(cName, "XX%d", iNamingValue);
					cName[0] = '_';
					cName[1] = m_pClientList[i]->m_cMapIndex+65;

					tX = (int)m_pClientList[i]->m_sX;
					tY = (int)m_pClientList[i]->m_sY;
					if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[i]->m_cMapIndex ]->m_cName, 0, MOVETYPE_RANDOM, 
						&tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, TRUE) == FALSE) {
							m_pMapList[ m_pClientList[i]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
					} 
					else {

						wsprintf(g_cTxt, "GM Order(%s): Guard Attack PC(%s)",m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cCharName);
						bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);


						bSetNpcAttackMode(cName, i, OWNERTYPE_PLAYER, TRUE);
					}
				}

				return;
			}

			SendNotifyMsg(NULL, iClientH, NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	return;
}


void CGame::AdminOrder_ReserveFightzone(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256];
	int iNum ;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if( m_iFightzoneNoForceRecall == 0 ) {
		m_iFightzoneNoForceRecall = 1 ; 
		SendNotifyMsg(NULL, iClientH, NOTIFY_FIGHTZONERESERVE, -5, NULL, NULL, NULL);
	} else {
		m_iFightzoneNoForceRecall = 0 ; 
		SendNotifyMsg(NULL, iClientH, NOTIFY_FIGHTZONERESERVE, -4, NULL, NULL, NULL);
	}

	if (token == NULL) {
		return;
	}

	iNum = atoi(token) - 1;

	if ( m_iFightZoneReserve[iNum] != -1) {
		wsprintf(g_cTxt, "GM Order(%s): FightzoneNumber(%d) FightzoneReserved", m_pClientList[iClientH]->m_cCharName, iNum );
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);

		m_iFightZoneReserve[iNum] = - 1 ;        												 
		SendNotifyMsg(NULL, iClientH, NOTIFY_FIGHTZONERESERVE, iNum+1, NULL, NULL, NULL);

	}  else {
		wsprintf(g_cTxt, "GM Order(%s): FightzoneNumber(%d) Cancel FightzoneReserved", m_pClientList[iClientH]->m_cCharName, iNum );
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);

		m_iFightZoneReserve[iNum] = 0 ;       
		SendNotifyMsg(NULL, iClientH, NOTIFY_FIGHTZONERESERVE, -3, NULL, NULL, NULL);

	}

	return;
}


void CGame::AdminOrder_CloseConn(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cTargetName[11], cBuff[256];
	register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

#ifdef TIAWAN
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
#else
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
#endif

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {

		if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
				if (m_pClientList[i]->m_bIsInitComplete == TRUE) {


					if (m_pClientList[iClientH]->m_iAdminUserLevel < m_pClientList[i]->m_iAdminUserLevel) {
						SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
						return ;
					}

					wsprintf(g_cTxt, "GM Order(%s): Close Connection PC(%s)",m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cCharName);

					bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);
#ifdef TAIWANLOG
					_bItemLog(ITEMLOG_CLOSECONN,i, m_pClientList[iClientH]->m_cCharName,NULL);
#endif
					DeleteClient(i, TRUE, TRUE, TRUE, TRUE);
				}

				return;
			}
			SendNotifyMsg(NULL, iClientH, NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	return;
}




void CGame::UserCommand_BanGuildsman(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cTargetName[11], cBuff[256];
	register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iGuildRank != 0 ) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_NOGUILDMASTERLEVEL, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {

		if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0) ) {

				if (memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[i]->m_cGuildName, 20) != 0)  {

					SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTBANGUILDMAN, NULL, NULL, NULL, NULL);
					return;
				}
				bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN, i);

#ifdef TAIWANLOG
				_bItemLog(ITEMLOG_BANGUILD,i,(char *)NULL,NULL) ;
#endif


				SendGuildMsg(i, NOTIFY_DISMISSGUILDSMAN, NULL, NULL, NULL);

				ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
				strcpy(m_pClientList[i]->m_cGuildName, "NONE");
				m_pClientList[i]->m_iGuildRank = -1; 
				m_pClientList[i]->m_iGuildGUID = -1;

				SendNotifyMsg(NULL, iClientH, NOTIFY_SUCCESSBANGUILDMAN, NULL, NULL, NULL, NULL);


				SendNotifyMsg(iClientH, i, COMMONTYPE_BANGUILD, NULL, NULL, NULL, NULL);


				SendEventToNearClient_TypeA(i, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTNULLACTION, NULL, NULL, NULL);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_CLEARGUILDNAME, m_pClientList[i]->m_cMapIndex,m_pClientList[i]->m_sX, m_pClientList[i]->m_sY,0, 0, 0);

				return;
			}
			SendNotifyMsg(NULL, iClientH, NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	return;
}



void CGame::UserCommand_DissmissGuild(int iClientH, char * pData, DWORD dwMsgSize)
{

}


int CGame::iCreateFish(char cMapIndex, short sX, short sY, short sType, class CItem * pItem, int iDifficulty, DWORD dwLastTime)
{
	register int i, iDynamicHandle;

	if (cMapIndex < 0 || cMapIndex >= MAXMAPS ||
		!m_pMapList[cMapIndex] ||
		!m_pMapList[cMapIndex]->bGetIsWater(sX, sY))
	{
		delete pItem;
		return NULL;
	}

	for (i = 1; i < MAXFISHS; i++) 
	{
		if (m_pFish[i] == NULL) {

			m_pFish[i] = new class CFish(cMapIndex, sX, sY, sType, pItem, iDifficulty);
			if (m_pFish[i] == NULL) return NULL;


			switch (pItem->m_sIDnum) {
			case 101: 
			case 102: 
			case 103: 
			case 570:
			case 571:
			case 572:
			case 573:
			case 574:
			case 575:
			case 576:
			case 577:
				iDynamicHandle = iAddDynamicObjectList(i, NULL, DYNAMICOBJECT_FISH, cMapIndex, sX, sY, dwLastTime);
				break;
			default: 
				iDynamicHandle = iAddDynamicObjectList(i, NULL, DYNAMICOBJECT_FISHOBJECT, cMapIndex, sX, sY, dwLastTime);
				break;
			}

			if (iDynamicHandle == NULL) {
				delete m_pFish[i];
				m_pFish[i] = NULL;
				return NULL;
			}
			m_pFish[i]->m_sDynamicObjectHandle = iDynamicHandle;
			m_pMapList[cMapIndex]->m_iCurFish++;

			return i;
		}
	}

	delete pItem;
	return NULL;
}


bool CGame::bDeleteFish(int iHandle, int iDelMode)
{
	register int i, iH;
	DWORD dwTime;

	if (m_pFish[iHandle] == NULL) return FALSE;

	dwTime = timeGetTime();

	iH = m_pFish[iHandle]->m_sDynamicObjectHandle;

	if (m_pDynamicObjectList[iH] != NULL) {
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, MSGTYPE_REJECT, m_pDynamicObjectList[iH]->m_cMapIndex, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, m_pDynamicObjectList[iH]->m_sType, iH, NULL);
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, dwTime);
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->m_iCurFish--;

		delete m_pDynamicObjectList[iH];
		m_pDynamicObjectList[iH] = NULL;
	}

	for (i = 1; i < MAXCLIENTS; i++) {
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) &&
			(m_pClientList[i]->m_iAllocatedFish == iHandle)) {
				SendNotifyMsg(NULL, i, NOTIFY_FISHCANCELED, iDelMode, NULL, NULL, NULL);
				ClearSkillUsingStatus(i); 
		}
	}


	delete m_pFish[iHandle];
	m_pFish[iHandle] = NULL;

	return TRUE;
}


int CGame::iCheckFish(int iClientH, char cMapIndex, short dX, short dY)
{
	register int i;
	short sDistX, sDistY;

	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if ((cMapIndex < 0)	|| (cMapIndex >= MAXMAPS)) return 0;

	for (i = 1; i < MAXDYNAMICOBJECTS; i++) 
		if (m_pDynamicObjectList[i] != NULL) {
			sDistX = abs(m_pDynamicObjectList[i]->m_sX - dX);
			sDistY = abs(m_pDynamicObjectList[i]->m_sY - dY);

			if ((m_pDynamicObjectList[i]->m_cMapIndex == cMapIndex) && 
				((m_pDynamicObjectList[i]->m_sType == DYNAMICOBJECT_FISH) || (m_pDynamicObjectList[i]->m_sType == DYNAMICOBJECT_FISHOBJECT)) &&
				(sDistX <= 2) && (sDistY <= 2)) {

					if (m_pFish[ m_pDynamicObjectList[i]->m_sOwner ] == NULL) return 0;
					if (m_pFish[ m_pDynamicObjectList[i]->m_sOwner ]->m_sEngagingCount >= MAXENGAGINGFISH) return 0;

					if (m_pClientList[iClientH]->m_iAllocatedFish != NULL) return 0;
					if (m_pClientList[iClientH]->m_cMapIndex != cMapIndex) return 0;
					m_pClientList[iClientH]->m_iAllocatedFish = m_pDynamicObjectList[i]->m_sOwner;
					m_pClientList[iClientH]->m_iFishChance = 1;
					m_pClientList[iClientH]->m_bSkillUsingStatus[1] = TRUE;

					SendNotifyMsg(NULL, iClientH, NOTIFY_EVENTFISHMODE, (m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_wPrice/2), m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSprite,
						m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSpriteFrame, m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_cName);


					m_pFish[ m_pDynamicObjectList[i]->m_sOwner ]->m_sEngagingCount++;

					return i;
			}
		}

		return 0;
}

void CGame::FishProcessor()
{
	register int i, iSkillLevel, iResult, iChangeValue;

	for (i = 1; i < MAXCLIENTS; i++) {
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && 
			(m_pClientList[i]->m_iAllocatedFish != NULL)) {

				if (m_pFish[ m_pClientList[i]->m_iAllocatedFish ] == NULL) break;

				iSkillLevel  = m_pClientList[i]->m_cSkillMastery[1];
				iSkillLevel -= m_pFish[m_pClientList[i]->m_iAllocatedFish]->m_iDifficulty;
				if (iSkillLevel <= 0) iSkillLevel = 1;

				iChangeValue = iSkillLevel / 10;
				if (iChangeValue <= 0) iChangeValue = 1;
				iChangeValue = dice(1, iChangeValue);

				iResult = dice(1, 100);
				if (iSkillLevel > iResult) {
					m_pClientList[i]->m_iFishChance += iChangeValue;
					if (m_pClientList[i]->m_iFishChance > 99) m_pClientList[i]->m_iFishChance = 99;

					SendNotifyMsg(NULL, i, NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, NULL, NULL, NULL);
				}
				else if (iSkillLevel < iResult) {
					m_pClientList[i]->m_iFishChance -= iChangeValue;
					if (m_pClientList[i]->m_iFishChance < 1) m_pClientList[i]->m_iFishChance = 1;

					SendNotifyMsg(NULL, i, NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, NULL, NULL, NULL);
				}
		}
	}
}



void CGame::AdminOrder_CreateFish(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256] ;
	class  CItem   * pItem;
	register int tX, tY, iType;
	int iItemID = 0 ;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	tX = tY = iType = 0;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();

	token = pStrTok->pGet();
	if (token != NULL) {
		tX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		tY = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		iType = atoi(token);
	}

	if ((tX != 0) && (tY != 0) && (iType != 0)) {
		pItem = new class CItem;
		if (pItem == NULL) {
			return;
		}

		iItemID = 100 ;

		if (_bInitItemAttr(pItem, iItemID) == TRUE) {
			iCreateFish(m_pClientList[iClientH]->m_cMapIndex, tX, tY, iType, pItem, 1, 60000*20);

			delete pItem;
			pItem = NULL ;
		}
		else {
			delete pItem;
			pItem = NULL ;
		}
	}

	return;
}

void CGame::AdminOrder_Teleport(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cMapName[256] ;
	register int dX, dY;
	bool   bFlag;

	dX = dY = -1;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;


	if (m_pClientList[iClientH]->m_bIsObserverMode == TRUE) return ;

#ifndef ALLOWPLAYERTP
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		//SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
#endif

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();

	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dY = atoi(token);
	}


	if(dY == -1)	dX = -1;

	bFlag = FALSE;
	if (strcmp("arefarm", cMapName) == 0) bFlag = TRUE;
	else if (strcmp(sideMap[ARESDEN], cMapName) == 0) bFlag = TRUE;
	else if (strcmp("aresdend1", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("cath_1", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("wrhus_1", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("bsmith_1", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("gshop_1", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("wrhus_1f", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("bsmith_1f", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("gshop_1f", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("gldhall_1", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("cityhall_1", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("CmdHall_1", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("wzdtwr_1", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("huntzone2", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("huntzone4", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("areuni", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("resurr1", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("arejail", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("arewrhus", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("arebrk11", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("arebrk12", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("arebrk21", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("arebrk22", cMapName) == 0) bFlag = TRUE;


	else if (strcmp("elvfarm", cMapName) == 0) bFlag = TRUE;
	else if (strcmp(sideMap[ELVINE], cMapName) == 0)      bFlag = TRUE;
	else if (strcmp("elvined1", cMapName) == 0)    bFlag = TRUE;
	else if (strcmp("cath_2", cMapName) == 0)      bFlag = TRUE;
	else if (strcmp("wrhus_2", cMapName) == 0)     bFlag = TRUE;
	else if (strcmp("gshop_2", cMapName) == 0)     bFlag = TRUE;
	else if (strcmp("bsmith_2", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("wrhus_2f", cMapName) == 0)     bFlag = TRUE;
	else if (strcmp("gshop_2f", cMapName) == 0)     bFlag = TRUE;
	else if (strcmp("bsmith_2f", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("gldhall_2", cMapName) == 0)   bFlag = TRUE;
	else if (strcmp("cityhall_2", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("CmdHall_2", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("wzdtwr_2", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("huntzone1", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("huntzone3", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("elvuni", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("resurr2", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("elvjail", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("elvwrhus", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("elvbrk11", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("elvbrk12", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("elvbrk21", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("elvbrk22", cMapName) == 0) bFlag = TRUE;


	else if (strcmp("istfarm", cMapName) == 0) bFlag = TRUE;
	else if (strcmp(sideMap[ISTRIA], cMapName) == 0)      bFlag = TRUE;
	//else if (strcmp("elvined1", cMapName) == 0)    bFlag = TRUE;
	else if (strcmp("cath_3", cMapName) == 0)      bFlag = TRUE;
	else if (strcmp("wrhus_3", cMapName) == 0)     bFlag = TRUE;
	else if (strcmp("gshop_3", cMapName) == 0)     bFlag = TRUE;
	else if (strcmp("bsmith_3", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("wrhus_3f", cMapName) == 0)     bFlag = TRUE;
	else if (strcmp("gshop_3f", cMapName) == 0)     bFlag = TRUE;
	else if (strcmp("bsmith_3f", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("gldhall_3", cMapName) == 0)   bFlag = TRUE;
	else if (strcmp("cityhall_3", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("CmdHall_3", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("wzdtwr_3", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("huntzone5", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("huntzone6", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("garden", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("resurr3", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("istjail", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("istwrhus", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("istbrk1", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("istbrk2", cMapName) == 0) bFlag = TRUE;


	else if (strcmp("dglv2", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("dglv3", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("dglv4", cMapName) == 0) bFlag = TRUE;

	else if (strcmp("bisle", cMapName) == 0)   bFlag = TRUE;
	else if (strcmp(sideMap[NEUTRAL], cMapName) == 0) bFlag = TRUE;


	else if (strcmp("fightzone1", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("fightzone2", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("fightzone3", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("fightzone4", cMapName) == 0) bFlag = TRUE;

	else if (strcmp("fightzone5", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("fightzone6", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("fightzone7", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("fightzone8", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("fightzone9", cMapName) == 0) bFlag = TRUE;

	else if (strcmp("middleland", cMapName) == 0) bFlag = TRUE;

	else if (strcmp("middled1n", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("middled1x", cMapName) == 0) bFlag = TRUE;

	else if (strcmp("toh1", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("toh2", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("toh3", cMapName) == 0) bFlag = TRUE;

	else if (strcmp("2ndmiddle", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("icebound", cMapName) == 0) bFlag = TRUE;

	else if (strcmp("barracks1", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("barracks2", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("bsmith", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("astoria", cMapName) == 0) bFlag = TRUE;

	else if (strcmp("test", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("inferniaA", cMapName) == 0) bFlag = TRUE; 
	else if (strcmp("inferniaB", cMapName) == 0) bFlag = TRUE; 
	else if (strcmp("maze", cMapName) == 0) bFlag = TRUE; 
	else if (strcmp("procella", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("abaddon", cMapName) == 0) bFlag = TRUE; 
	else if (strcmp("druncncity", cMapName) == 0) bFlag = TRUE; 
	else if (strcmp("GodH", cMapName) == 0)   bFlag = TRUE;
	else if (strcmp("BtField", cMapName) == 0) bFlag = TRUE;
	else if (strcmp("HRampart", cMapName) == 0)     bFlag = TRUE;


	if (!bFlag) 
		return; 

	if ((dX == - 1) && (dY == -1))
		wsprintf(g_cTxt, "GM Order(%s): teleport MapName(%s)",m_pClientList[iClientH]->m_cCharName, cMapName);
	else wsprintf(g_cTxt, "GM Order(%s): teleport MapName(%s)(%d %d)",m_pClientList[iClientH]->m_cCharName, cMapName,dX,dY);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);

	RequestTeleportHandler(iClientH, 2, cMapName, dX, dY);

	return;
}


void CGame::ReqGetFishThisTimeHandler(int iClientH)
{
	register int iResult, iFishH;
	class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iAllocatedFish == NULL) return;
	if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] == NULL) return;

	m_pClientList[iClientH]->m_bSkillUsingStatus[1] = FALSE;

	iResult = dice(1, 100);
	if (m_pClientList[iClientH]->m_iFishChance >= iResult) {


		GetExp(iClientH, dice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 6)); //m_pClientList[iClientH]->m_iExpStock += dice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 5);
		CalculateSSN_SkillIndex(iClientH, SKILL_FISHING, m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty);


		pItem = m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem;
		m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem = NULL;


		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, 
			m_pClientList[iClientH]->m_sY, 
			pItem);


		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
			pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 


		SendNotifyMsg(NULL, iClientH, NOTIFY_FISHSUCCESS, NULL, NULL, NULL, NULL);
		iFishH = m_pClientList[iClientH]->m_iAllocatedFish;
		m_pClientList[iClientH]->m_iAllocatedFish = NULL;

		bDeleteFish(iFishH, 1); 
		return;
	}


	m_pFish[ m_pClientList[iClientH]->m_iAllocatedFish ]->m_sEngagingCount--;
	SendNotifyMsg(NULL, iClientH, NOTIFY_FISHFAIL, NULL, NULL, NULL, NULL);

	m_pClientList[iClientH]->m_iAllocatedFish = NULL;
}


void CGame::FishGenerator()
{
	class CItem * pItem;
	int iP, tX, tY;
	int iItemID; 
	short sDifficulty;
	DWORD dwLastTime;

	for(int i = 0; i < MAXMAPS; i++) {
		if (dice(1,4) != 1 || !m_pMapList[i] || m_pMapList[i]->m_iCurFish >= m_pMapList[i]->m_iMaxFish)	
			continue;

		iP = dice(1, m_pMapList[i]->m_iTotalFishPoint) - 1;
		if (m_pMapList[i]->m_FishPointList[iP].x == -1 || m_pMapList[i]->m_FishPointList[iP].y == -1) break;

		tX = m_pMapList[i]->m_FishPointList[iP].x + (dice(1,3) - 2);
		tY = m_pMapList[i]->m_FishPointList[iP].y + (dice(1,3) - 2);

		pItem = new CItem;
		if (!pItem) break;


		iItemID = ITEM_NONE;
		switch (dice(1,9)) 
		{
		case 1:	iItemID = ITEM_REDCARP ; sDifficulty = dice(1,10) +  5; break;
		case 2:	iItemID = ITEM_GREENCARP ; sDifficulty = dice(1,5) + 15;  break;
		case 3:	iItemID = ITEM_GOLDCARP ; sDifficulty = dice(1,10) + 20; break;
		case 4:	iItemID = ITEM_CRUCIANCARP ; sDifficulty = 1;  break;
		case 5:	iItemID = ITEM_BLUESEABREAM ; sDifficulty = dice(1,15) + 1;  break;  
		case 6:	iItemID = ITEM_REDSEABREAM ; sDifficulty = dice(1,18) + 1;  break;  
		case 7:	iItemID = ITEM_SALMON ; sDifficulty = dice(1,12) + 1;  break;
		case 8:	iItemID = ITEM_GRAYMULLET ; sDifficulty = dice(1,10) + 1;  break;
		case 9:
			switch (dice(1,150)) 
			{
			case 1:
			case 2:
			case 3:
				iItemID = ITEM_POWERGREENPOTION;  
				sDifficulty = dice(4,4) + 20;
				break;

			case 10:
			case 11:
				iItemID = ITEM_SUPERGREENPOTION;  
				sDifficulty = dice(4,4) + 40;
				break;

			case 20:
				iItemID = ITEM_DAGGER_ADD2;  
				sDifficulty = dice(4,4) + 5;
				break;

			case 30:
				iItemID = ITEM_LONGSWORD_ADD2;  
				sDifficulty = dice(4,4) + 10;
				break;

			case 40:
				iItemID = ITEM_SCIMITAR_ADD2;  
				sDifficulty = dice(4,4) + 15;
				break;

			case 50:
				iItemID = ITEM_RAPIER_ADD2;  
				sDifficulty = dice(4,4) + 35;
				break;

			case 60:
				iItemID = ITEM_FLAMEBERGE_ADD2;  
				sDifficulty = dice(4,4) + 40;
				break;

			case 70:
				iItemID = ITEM_WARAXE_ADD2;  
				sDifficulty = dice(4,4) + 30;
				break;

			case 90:
				iItemID = ITEM_RUBY;  
				sDifficulty = dice(4,4) + 30;
				break;

			case 95:
				iItemID = ITEM_DIAMOND;  
				sDifficulty = dice(4,4) + 30;
				break;
			}
			break;
		}

		dwLastTime  = 10 _m + 10 _m * (dice(1,3) - 1);

		if (_bInitItemAttr(pItem, iItemID))
			iCreateFish(i, tX, tY, 1, pItem, sDifficulty, dwLastTime); 
		else{
			delete pItem;
			pItem = NULL;
		}
	}													  
}


// Calculates the number of players within a given radius.
int CGame::getPlayerNum(char cMapIndex, short dX, short dY, char cRadius)
{
	register int x, y, ret;
	class CTile * pTile;

	if ((cMapIndex < 0)	|| (cMapIndex > MAXMAPS)) return 0;
	if (m_pMapList[cMapIndex] == NULL) return 0;

	ret = 0;
	for (x = dX - cRadius; x <= dX + cRadius; x++)
		for (y = dY - cRadius; y <= dY + cRadius; y++) {
			if ( (x < 0) || (x >= m_pMapList[cMapIndex]->m_sSizeX) || 
				(y < 0) || (y >= m_pMapList[cMapIndex]->m_sSizeY) ) {
			}
			else {
				pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + x + y*m_pMapList[cMapIndex]->m_sSizeY);
				if ((pTile->m_sOwner != NULL) && (pTile->m_cOwnerClass == OWNERTYPE_PLAYER))
					ret++;
			}
		}

		return ret;
}


void CGame::WhetherProcessor()
{
	char cPrevMode;
	int i, j;
	DWORD dwTime;

	dwTime = timeGetTime();

	for (i = 0; i < MAXMAPS; i++) {
		if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bIsFixedDayMode == FALSE)) {

			cPrevMode = m_pMapList[i]->m_cWhetherStatus;

			if (m_pMapList[i]->m_cWhetherStatus != NULL) {
				if ((dwTime - m_pMapList[i]->m_dwWhetherStartTime) > m_pMapList[i]->m_dwWhetherLastTime) 
					m_pMapList[i]->m_cWhetherStatus = NULL;
			}
			else {
				if (dice(1,100) == 13) {
					m_pMapList[i]->m_cWhetherStatus = dice(1,3); 
					m_pMapList[i]->m_dwWhetherStartTime = dwTime;
					m_pMapList[i]->m_dwWhetherLastTime  = 60000*3 + 60000*dice(1,7);
				}
			}

			if (m_pMapList[i]->m_bIsFixedSnowMode == TRUE)
			{
				m_pMapList[i]->m_cWhetherStatus = dice(1,3) + 3;
				m_pMapList[i]->m_dwWhetherStartTime = dwTime;
				m_pMapList[i]->m_dwWhetherLastTime  = 60000*3 + 60000*dice(1,7);
			}

			if (cPrevMode != m_pMapList[i]->m_cWhetherStatus) {

				for (j = 1; j < MAXCLIENTS; j++) 
					if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == TRUE) && (m_pClientList[j]->m_cMapIndex == i)) 
						SendNotifyMsg(NULL, j, NOTIFY_WHETHERCHANGE, m_pMapList[i]->m_cWhetherStatus, NULL, NULL, NULL);
			}

		}
	}
}


void CGame::FightzoneReserveProcessor()
{
	register int i;

	//	PutLogList("CAN FIGHTZONE RESERVE!!");

	for (i=0 ; i < MAXFIGHTZONE ; i++ ) {
		if (m_iFightZoneReserve[i] == -1 ) continue ; 
		m_iFightZoneReserve[i] = 0 ;
	}

	for (i = 1; i < MAXCLIENTS; i++) {
		if((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iFightzoneNumber != 0))
			SendNotifyMsg(NULL, i, NOTIFY_FIGHTZONERESERVE, -2, NULL, NULL, NULL);
	}
}


int CGame::iGetWhetherMagicBonusEffect(short sType, char cWheatherStatus)
{
	int iWheatherBonus;

	iWheatherBonus = 0;
	switch (cWheatherStatus) {
	case 0: break;
	case 1:
	case 2:
	case 3:
		switch (sType) {
		case 10:
		case 37:
		case 43:
		case 51:
			//iWheatherBonus = 2*cWheatherStatus;
			iWheatherBonus = 1;
			break;

		case 20:
		case 30:
			//iWheatherBonus = -2*cWheatherStatus;
			iWheatherBonus = -1;
			break;
		}
		break;
	}

	return iWheatherBonus;
}

int CGame::iGetMapIndex(char * pMapName)
{
	int i, iMapIndex;

	iMapIndex = -1;
	for (i = 0; i < MAXMAPS; i++)
		if (m_pMapList[i] != NULL) {
			if (memcmp(m_pMapList[i]->m_cName, pMapName, 10) == 0) {
				iMapIndex = i;
				break;
		}
		}

	return iMapIndex;
}


int CGame::_iForcePlayerDisconect(int iNum)
{
	register int i, iCnt;

	iCnt = 0;
	for (i = 1; i < MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			if (m_pClientList[i]->m_bIsInitComplete == TRUE)
				DeleteClient(i, TRUE, TRUE);
			else DeleteClient(i, FALSE, FALSE);
			iCnt++;
			if (iCnt >= iNum) break;
		}

		return iCnt;
}

void CGame::SpecialEventHandler()
{
	DWORD dwTime;

	dwTime = timeGetTime();

	if ((dwTime - m_dwSpecialEventTime) < MOBEVENTTIME) return;
	m_dwSpecialEventTime  = dwTime;
	m_bIsSpecialEventTime = TRUE;

	switch (dice(1,350)) {
	case 98: m_cSpecialEventType = 2; break; 
	default: m_cSpecialEventType = 1; break;
	}
}

void CGame::AdminOrder_CheckIP(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cIP[21], cInfoString[500];
	register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {

		ZeroMemory(cIP, sizeof(cIP));
		strcpy(cIP, token);

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cIPaddress, cIP, strlen(cIP)) == 0)) {
				ZeroMemory(cInfoString, sizeof(cInfoString));
				wsprintf(cInfoString, "Name(%s/%s) Loc(%s: %d %d) Level(%d:%d) Init(%d) IP(%s)", 
					m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cMapName, 
					m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 
					m_pClientList[i]->m_iLevel, NULL/*m_pClientList[i]->m_cAccountStatus*/,
					m_pClientList[i]->m_bIsInitComplete, m_pClientList[i]->m_cIPaddress);

				SendNotifyMsg(NULL, iClientH, NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
			}
	}


}

void CGame::ToggleSafeAttackModeHandler(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;


	if (m_pClientList[iClientH]->m_bIsSafeAttackMode == TRUE) 
		m_pClientList[iClientH]->m_bIsSafeAttackMode = FALSE;
	else m_pClientList[iClientH]->m_bIsSafeAttackMode = TRUE;

	SendNotifyMsg(NULL, iClientH, NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
}

void CGame::NpcRequestAssistance(int iNpcH)
{
	register int ix, iy, sX, sY;
	short sOwnerH;
	char  cOwnerType;


	if (m_pNpcList[iNpcH] == NULL) return;

	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;

	for (ix = sX - 8; ix <= sX + 8; ix++)
		for (iy = sY - 8; iy <= sY + 8; iy++) {
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
			if ((sOwnerH != NULL) && (m_pNpcList[sOwnerH] != NULL) && (cOwnerType == OWNERTYPE_NPC) && 
				(iNpcH != sOwnerH) && (m_pNpcList[sOwnerH]->m_side == m_pNpcList[iNpcH]->m_side) &&
				(m_pNpcList[sOwnerH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[sOwnerH]->m_cBehavior == BEHAVIOR_MOVE)) {

					m_pNpcList[sOwnerH]->m_cBehavior          = BEHAVIOR_ATTACK;
					m_pNpcList[sOwnerH]->m_sBehaviorTurnCount = 0;
					m_pNpcList[sOwnerH]->m_iTargetIndex = m_pNpcList[iNpcH]->m_iTargetIndex;
					m_pNpcList[sOwnerH]->m_cTargetType  = m_pNpcList[iNpcH]->m_cTargetType;

					return;
			}
		}
}

void CGame::ForceDisconnectAccount(char *pAccountName, WORD wCount)
{
	bool bOK = FALSE;
 register int i;
 char G_cTxt[250];

	for (i = 1; i < MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cAccountName, pAccountName, 10) == 0)) 
	{	wsprintf(G_cTxt, "Force disconnect:  Acc(%s) PC(%s) Count(%d). (Asking client to close conn) \tIP(%s)"
			, pAccountName					
			, m_pClientList[i]->m_cCharName
			, wCount
			, m_pClientList[i]->m_cIPaddress);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
		SendNotifyMsg(NULL, i, NOTIFY_FORCEDISCONN, wCount, NULL, NULL, NULL);
		bOK = TRUE;
		break;
	}
	if (bOK == FALSE) // Add by snoopy
	{	DWORD dwTime = timeGetTime();
		{	for (i = 0; i < MAXCLIENTS; i++) 
			{	if (   (memcmp(m_stOldClientList[i].m_cAccountName, pAccountName, 10) == 0)
					&& (dwTime < (m_stOldClientList[i].m_dwDeleteTime + 59*1000))) // erased less than 60 sec ago
				{	wsprintf(G_cTxt, "Force disconnect:  Acc(%s) PC(%s) Count(%d). (Disconnected %dms ago!)"
						, pAccountName	
						, m_stOldClientList[i].m_cCharName
						, wCount
						, (dwTime - m_stOldClientList[i].m_dwDeleteTime));
					PutLogList(G_cTxt);
					PutLogFileList(G_cTxt);
					goto OUTDATED_PROUVED;						
		}	}	}		
		wsprintf(G_cTxt, "Force disconnect:  Acc(%s) PC(Not found) Count(%d). (Account not connected here!)"
			, pAccountName					
			, wCount);
		PutLogList(G_cTxt);	
		PutLogFileList(G_cTxt);
OUTDATED_PROUVED:;
		/*ZeroMemory(m_cBugText, sizeof(m_cBugText));
		wsprintf(m_cBugText, "IMPORTANT NOTICE: \"Character in use\" bug detected, on account: %s"
		, pAccountName);
		m_iBugWarning = 1;*/
	}
}


void CGame::AdminOrder_Polymorph(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 4) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if(!m_pClientList[iClientH]->m_sOriginalType)
		m_pClientList[iClientH]->m_sOriginalType = m_pClientList[iClientH]->m_sType;
	else
		m_pClientList[iClientH]->m_sType = m_pClientList[iClientH]->m_sOriginalType;

	if (token != NULL) {
		if (memcmp(token, "off", 3) == 0)
			m_pClientList[iClientH]->m_sType = m_pClientList[iClientH]->m_sOriginalType;

		else if (memcmp(token, "Slime", 5) == 0)
			m_pClientList[iClientH]->m_sType = 10;

		else if (memcmp(token, "Skeleton", 8) == 0)
			m_pClientList[iClientH]->m_sType = 11;

		else if (memcmp(token, "Stone-Golem", 11) == 0)
			m_pClientList[iClientH]->m_sType = 12;

		else if (memcmp(token, "Cyclops", 7) == 0)
			m_pClientList[iClientH]->m_sType = 13;

		else if (memcmp(token, "Orc", 3) == 0)
			m_pClientList[iClientH]->m_sType = 14;

		else if (memcmp(token, "ShopKeeper", 10) == 0)
			m_pClientList[iClientH]->m_sType = 15;

		else if (memcmp(token, "Giant-Ant", 9) == 0)
			m_pClientList[iClientH]->m_sType = 16;

		else if (memcmp(token, "Scorpion", 8) == 0)
			m_pClientList[iClientH]->m_sType = 17;

		else if (memcmp(token, "Zombie", 6) == 0)
			m_pClientList[iClientH]->m_sType = 18;

		else if (memcmp(token, "Gandlf", 6) == 0)
			m_pClientList[iClientH]->m_sType = 19;

		else if (memcmp(token, "Howard", 6) == 0)
			m_pClientList[iClientH]->m_sType = 20;

		else if (memcmp(token, "Gaurd", 5) == 0)
			m_pClientList[iClientH]->m_sType = 21;

		else if (memcmp(token, "Amphis", 6) == 0)
			m_pClientList[iClientH]->m_sType = 22;

		else if (memcmp(token, "Clay-Golem", 10) == 0)
			m_pClientList[iClientH]->m_sType = 23;

		else if (memcmp(token, "Tom", 3) == 0)
			m_pClientList[iClientH]->m_sType = 24;

		else if (memcmp(token, "William", 7) == 0)
			m_pClientList[iClientH]->m_sType = 25;

		else if (memcmp(token, "Kennedy", 7) == 0)
			m_pClientList[iClientH]->m_sType = 26;

		else if (memcmp(token, "Hellbound", 9) == 0)
			m_pClientList[iClientH]->m_sType = 27;

		else if (memcmp(token, "Troll", 5) == 0)
			m_pClientList[iClientH]->m_sType = 28;

		else if (memcmp(token, "Orge", 4) == 0)
			m_pClientList[iClientH]->m_sType = 29;

		else if (memcmp(token, "Liche", 5) == 0)
			m_pClientList[iClientH]->m_sType = 30;

		else if (memcmp(token, "Demon", 5) == 0)
			m_pClientList[iClientH]->m_sType = 31;

		else if (memcmp(token, "Unicorn", 7) == 0)
			m_pClientList[iClientH]->m_sType = 32;

		else if (memcmp(token, "WereWolf", 8) == 0)
			m_pClientList[iClientH]->m_sType = 33;

		else if (memcmp(token, "Dummy", 5) == 0)
			m_pClientList[iClientH]->m_sType = 34;

		else if (memcmp(token, "Energy-Sphere", 13) == 0)
			m_pClientList[iClientH]->m_sType = 35;

		else if (memcmp(token, "AGT", 3) == 0)
			m_pClientList[iClientH]->m_sType = 36;

		else if (memcmp(token, "CGT", 3) == 0)
			m_pClientList[iClientH]->m_sType = 37;

		else if (memcmp(token, "MS", 2) == 0)
			m_pClientList[iClientH]->m_sType = 38;

		else if (memcmp(token, "DT", 2) == 0)
			m_pClientList[iClientH]->m_sType = 39;

		else if (memcmp(token, "ESG", 3) == 0)
			m_pClientList[iClientH]->m_sType = 40;

		else if (memcmp(token, "GMG", 3) == 0)
			m_pClientList[iClientH]->m_sType = 41;

		else if (memcmp(token, "ManaStone", 9) == 0)
			m_pClientList[iClientH]->m_sType = 42;

		else if (memcmp(token, "LWB", 3) == 0)
			m_pClientList[iClientH]->m_sType = 43;

		else if (memcmp(token, "GHK", 3) == 0)
			m_pClientList[iClientH]->m_sType = 44;

		else if (memcmp(token, "GHC", 6) == 0)
			m_pClientList[iClientH]->m_sType = 45;

		else if (memcmp(token, "TK", 2) == 0)
			m_pClientList[iClientH]->m_sType = 46;

		else if (memcmp(token, "BG", 2) == 0)
			m_pClientList[iClientH]->m_sType = 47;

		else if (memcmp(token, "Stalker", 7) == 0)
			m_pClientList[iClientH]->m_sType = 48;

		else if (memcmp(token, "Hellclaw", 8) == 0)
			m_pClientList[iClientH]->m_sType = 49;

		else if (memcmp(token, "Tigerworm", 8) == 0)
			m_pClientList[iClientH]->m_sType = 50;

		else if (memcmp(token, "CP", 2) == 0)
			m_pClientList[iClientH]->m_sType = 51;

		else if (memcmp(token, "Gagoyle", 7) == 0)
			m_pClientList[iClientH]->m_sType = 52;

		else if (memcmp(token, "Beholder", 8) == 0)
			m_pClientList[iClientH]->m_sType = 53;

		else if (memcmp(token, "Dark-Elf", 8) == 0)
			m_pClientList[iClientH]->m_sType = 54;

		else if (memcmp(token, "Rabbit", 6) == 0)
			m_pClientList[iClientH]->m_sType = 55;

		else if (memcmp(token, "Cat", 3) == 0)
			m_pClientList[iClientH]->m_sType = 56;

		else if (memcmp(token, "Giant-Frog", 10) == 0)
			m_pClientList[iClientH]->m_sType = 57;

		else if (memcmp(token, "Mountain-Giant", 14) == 0)
			m_pClientList[iClientH]->m_sType = 58;

		else if (memcmp(token, "Ettin", 5) == 0)
			m_pClientList[iClientH]->m_sType = 59;

		else if (memcmp(token, "Cannibal-Plant", 13) == 0)
			m_pClientList[iClientH]->m_sType = 60;

		else if (memcmp(token, "Rudolph", 7) == 0)
			m_pClientList[iClientH]->m_sType = 61;

		else if (memcmp(token, "DireBoar", 8) == 0)
			m_pClientList[iClientH]->m_sType = 62;

		else if (memcmp(token, "Frost", 5) == 0)
			m_pClientList[iClientH]->m_sType = 63;

		else if (memcmp(token, "Crops", 5) == 0)
			m_pClientList[iClientH]->m_sType = 64;

		else if (memcmp(token, "Ice-Golem", 9) == 0)
			m_pClientList[iClientH]->m_sType = 65;

		else if (memcmp(token, "Wyvern", 6) == 0)
			m_pClientList[iClientH]->m_sType = 66;

		else if (memcmp(token, "McGaffin", 8) == 0)
			m_pClientList[iClientH]->m_sType = 67;

		else if (memcmp(token, "Perry", 5) == 0)
			m_pClientList[iClientH]->m_sType = 68;

		else if (memcmp(token, "Devlin", 6) == 0)
			m_pClientList[iClientH]->m_sType = 69;

		else if (memcmp(token, "Barlog", 6) == 0)
			m_pClientList[iClientH]->m_sType = 70;

		else if (memcmp(token, "Centaurus", 9) == 0)
			m_pClientList[iClientH]->m_sType = 71;

		else if (memcmp(token, "Claw-Turtle", 11) == 0)
			m_pClientList[iClientH]->m_sType = 72;

		else if (memcmp(token, "Fire-Wyvern", 11) == 0)
			m_pClientList[iClientH]->m_sType = 73;

		else if (memcmp(token, "Giant-Crayfish", 14) == 0)
			m_pClientList[iClientH]->m_sType = 74;

		else if (memcmp(token, "Giant-Lizard", 12) == 0)
			m_pClientList[iClientH]->m_sType = 75;

		else if (memcmp(token, "Giant-Plant", 11) == 0)
			m_pClientList[iClientH]->m_sType = 76;

		else if (memcmp(token, "MasterMage-Orc", 14) == 0)
			m_pClientList[iClientH]->m_sType = 77;

		else if (memcmp(token, "Minotaurs", 9) == 0)
			m_pClientList[iClientH]->m_sType = 78;

		else if (memcmp(token, "Nizie", 5) == 0)
			m_pClientList[iClientH]->m_sType = 79;

		else if (memcmp(token, "Tentocle", 8) == 0)
			m_pClientList[iClientH]->m_sType = 80;

		else if (memcmp(token, "Abaddon", 7) == 0)
			m_pClientList[iClientH]->m_sType = 81;

		else if (memcmp(token, "Sor", 3) == 0)
			m_pClientList[iClientH]->m_sType = 82;

		else if (memcmp(token, "ATK", 3) == 0)
			m_pClientList[iClientH]->m_sType = 83;

		else if (memcmp(token, "Elf", 3) == 0)
			m_pClientList[iClientH]->m_sType = 84;

		else if (memcmp(token, "DSK", 3) == 0)
			m_pClientList[iClientH]->m_sType = 85;

		else if (memcmp(token, "HBT", 3) == 0)
			m_pClientList[iClientH]->m_sType = 86;

		else if (memcmp(token, "CT", 2) == 0)
			m_pClientList[iClientH]->m_sType = 87;

		else if (memcmp(token, "Bar", 3) == 0)
			m_pClientList[iClientH]->m_sType = 88;

		else if (memcmp(token, "AGC", 3) == 0)
			m_pClientList[iClientH]->m_sType = 89;

		else if (memcmp(token, "Gail", 4) == 0)
			m_pClientList[iClientH]->m_sType = 90;

		else if (memcmp(token, "gate", 4) == 0)
			m_pClientList[iClientH]->m_sType = 91;
	}
	SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTNULLACTION, NULL, NULL, NULL);
}

void CGame::AdminOrder_SetInvi(int iClientH)
{
	if (!m_pClientList[iClientH]->IsGM()) {
		return;
	}

	m_pClientList[iClientH]->ToggleStatusFlag(STATUS_INVISIBILITY);
}

void CGame::AdminOrder_SetHP(int iClientH, uint32 val)
{
	if (!m_pClientList[iClientH]->IsGM()) {
		return;
	}

	m_pClientList[iClientH]->m_iHP = val;
}

void CGame::AdminOrder_SetMP(int iClientH, uint32 val)
{
	if (!m_pClientList[iClientH]->IsGM()) {
		return;
	}

	m_pClientList[iClientH]->m_iMP = val;
}

void CGame::AdminOrder_SetMag(int iClientH, uint32 val)
{
	if (!m_pClientList[iClientH]->IsGM()) {
		return;
	}

	m_pClientList[iClientH]->SetMag(val);
}

bool CGame::bOnClose()
{
	if (m_bIsServerShutdowned == FALSE) 
		if (MessageBox(NULL, "Player data not saved! Shutdown server now?", m_cServerName, MB_ICONEXCLAMATION | MB_YESNO) == IDYES) return TRUE;
		else return FALSE;
	else return TRUE;

	return FALSE;
}

void CGame::_CheckAttackType(int iClientH, short *spType)
{
	WORD wType;

	if (m_pClientList[iClientH] == NULL) return;
	wType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

	switch (*spType) {
	case 2:
		if (m_pClientList[iClientH]->m_cArrowIndex == -1) *spType = 0;
		if (wType < 40) *spType = 1;
		break;

	case 20:
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		//if (m_pClientList[iClientH]->m_cSkillMastery[SKILL_HANDATTACK] < 100) *spType = 1;
		break;

	case 21: 

		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		//if (m_pClientList[iClientH]->m_cSkillMastery[SKILL_SHORTSWORD] < 100) *spType = 1;
		break;

	case 22: 

		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		//if (m_pClientList[iClientH]->m_cSkillMastery[SKILL_FENCING] < 100) *spType = 1;
		break;

	case 23: 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)   *spType = 1;
		//if (m_pClientList[iClientH]->m_cSkillMastery[SKILL_LONGSWORD] < 100) *spType = 1;
		break;

	case 24: 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		//if (m_pClientList[iClientH]->m_cSkillMastery[SKILL_AXE] < 100) *spType = 1;
		break;

	case 25: 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 2;
		//if (m_pClientList[iClientH]->m_cSkillMastery[SKILL_ARCHERY] < 100) *spType = 2;
		if (m_pClientList[iClientH]->m_cArrowIndex == -1)      *spType = 0;
		if (wType < 40) *spType = 1;
		break;
	case 26: 

		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		//if (m_pClientList[iClientH]->m_cSkillMastery[SKILL_HAMMER] < 100) *spType = 1;
		break;

	case 27: 

		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		//if (m_pClientList[iClientH]->m_cSkillMastery[SKILL_STAFF] < 100) *spType = 1;
		break;
	}
}


void CGame::ReqCreatePotionHandler(int iClientH, char *pData)
{
	char  * cp, cI[6], cPotionName[21];
	int    i, j, iEraseReq, iSkillLimit, iSkillLevel, iResult, iDifficulty;
	short sItemIndex[6], sTemp;
	uint32  itemNumber[6];
	short sItemArray[12];
	bool   bDup, bFlag;
	class  CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	for (i = 0; i < 6; i++) {
		cI[i] = -1;
		sItemIndex[i]  = -1;
		itemNumber[i] = 0;
	}

	cp = (char *)(pData + 11);
	cI[0] = *cp;
	cp++;
	cI[1] = *cp;
	cp++;
	cI[2] = *cp;
	cp++;
	cI[3] = *cp;
	cp++;
	cI[4] = *cp;
	cp++;
	cI[5] = *cp;
	cp++;


	for (i = 0; i < 6; i++) {
		if (cI[i] >= MAXITEMS) return;
		if ((cI[i] >= 0) && (m_pClientList[iClientH]->m_pItemList[cI[i]] == NULL)) return;
	}

	for (i = 0; i < 6; i++)
		if (cI[i] >= 0) {
			bDup = FALSE;
			for (j = 0; j < 6; j++) 
				if (sItemIndex[j] == cI[i]) {
					itemNumber[j]++;
					bDup = TRUE;
				}
			if (bDup == FALSE) {
				for (j = 0; j < 6; j++) 
					if (sItemIndex[j] == -1) {
						sItemIndex[j] = cI[i];
						itemNumber[j]++;
						break;
					}
			}
		}

	for (i = 0; i < 6; i++) 
		if (sItemIndex[i] != -1) {
			if (sItemIndex[i] < 0) return;
			if ((sItemIndex[i] >= 0) && (sItemIndex[i] >= MAXITEMS)) return;
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]] == NULL) return;

			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount < itemNumber[i]) return;
		}


	bFlag = TRUE;
	while (bFlag == TRUE) {
		bFlag = FALSE;
		for (i = 0; i < 5; i++) 
			if ((sItemIndex[i] != -1) && (sItemIndex[i+1] != -1)) {
				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum) <
					(m_pClientList[iClientH]->m_pItemList[sItemIndex[i+1]]->m_sIDnum)) {
						sTemp = sItemIndex[i+1];
						sItemIndex[i+1] = sItemIndex[i];
						sItemIndex[i] = sTemp;
						sTemp = itemNumber[i+1];
						itemNumber[i+1] = itemNumber[i];
						itemNumber[i] = sTemp;
						bFlag = TRUE;
				}
			}
		}

		//testcode
		/*
		char cTemp[120];
		char cTxt1[120];
		char cTxt2[120];
		ZeroMemory(cTxt1, sizeof(cTxt1));
		ZeroMemory(cTxt2, sizeof(cTxt2));
		for (i = 0; i < 6; i++) {
		ZeroMemory(cTemp, sizeof(cTemp));
		if (sItemIndex[i] != -1)
		wsprintf(cTemp, "(%d) ", m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum);
		else strcpy(cTemp, "(*)");
		strcat(cTxt1, cTemp);

		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "(%d) ", itemNumber[i]);
		strcat(cTxt2, cTemp);
		}
		PutLogList(cTxt1);
		PutLogList(cTxt2);
		*/

	j = 0;
	for (i = 0; i < 6; i++) {
		if (sItemIndex[i] != -1)
			sItemArray[j] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum;
		else sItemArray[j] = sItemIndex[i];
		sItemArray[j+1] = itemNumber[i];
		j += 2;
	}

		//testcode
		/*
		char cTemp[120], cTxt1[120];
		ZeroMemory(cTxt1, sizeof(cTxt1));
		for (i = 0; i < 12; i++) {
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%d", sItemArray[i]);
		strcat(cTxt1, cTemp);
		}
		PutLogList(cTxt1);
		*/


	ZeroMemory(cPotionName, sizeof(cPotionName));

	for (i = 0; i < MAXPOTIONTYPES; i++) 
		if (m_pPotionConfigList[i] != NULL) {
			bFlag = FALSE;
			for (j = 0; j < 12; j++) 
				if (m_pPotionConfigList[i]->m_sArray[j] != sItemArray[j]) bFlag = TRUE;

			if (bFlag == FALSE) {

				ZeroMemory(cPotionName, sizeof(cPotionName));
				memcpy(cPotionName, m_pPotionConfigList[i]->m_cName, 20);
				iSkillLimit = m_pPotionConfigList[i]->m_iSkillLimit;
				iDifficulty = m_pPotionConfigList[i]->m_iDifficulty;
			}
		}


	if (strlen(cPotionName) == 0) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_NOMATCHINGPOTION, NULL, NULL, NULL, NULL);
		return;
	}

	iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[SKILL_ALCHEMY];
	if (iSkillLimit > iSkillLevel) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_LOWPOTIONSKILL, NULL, NULL, NULL, cPotionName);
		return;
	}


	iSkillLevel -= iDifficulty;
	if (iSkillLevel <= 0) iSkillLevel = 1;


	if( m_pClientList[iClientH]->m_cSkillMastery[SKILL_ALCHEMY] == 100 )
		iSkillLevel += 5;

	iResult = dice(1,100);
	if (iResult > iSkillLevel) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_POTIONFAIL, NULL, NULL, NULL, cPotionName);
		return;
	}

	/*
	if ((m_pClientList[iClientH]->m_iLevel < 20) && (iSkillLevel > 80 )) {
	SendNotifyMsg(NULL, iClientH, NOTIFY_POTIONFAIL, NULL, NULL, NULL, cPotionName);
	return;
	}
	*/

	CalculateSSN_SkillIndex(iClientH, SKILL_ALCHEMY, 1);

	if (strlen(cPotionName) != 0) {
		pItem = NULL;
		pItem = new class CItem;
		if (pItem == NULL) return;

		for (i = 0; i < 6; i++)
			if (sItemIndex[i] != -1) {
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == ITEMTYPE_CONSUME)

					SetItemCount(iClientH, sItemIndex[i], //     m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cName,
					m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount - itemNumber[i]);
				else ItemDepleteHandler(iClientH, sItemIndex[i], FALSE);
			}

		SendNotifyMsg(NULL, iClientH, NOTIFY_POTIONSUCCESS, NULL, NULL, NULL, cPotionName);

		GetExp(iClientH, dice(2, (iDifficulty/3))); //m_pClientList[iClientH]->m_iExpStock += dice(1, (iDifficulty/3));

		if ((_bInitItemAttr(pItem, cPotionName) == TRUE)) {

			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {

				SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);

				if (iEraseReq == 1) delete pItem;

				//if ((pItem->m_wPrice * pItem->m_dwCount) > 1000) 
				//	SendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, iClientH);
			}
			else {

				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
					m_pClientList[iClientH]->m_sY, pItem);

				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
					pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 

				SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
			}
		}
		else {
			delete pItem;
			pItem = NULL;
		}
	}
}



bool CGame::_bDecodePotionConfigFileContents(char *pData, DWORD dwMsgSize)
{
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iPotionConfigListIndex = 0;
	

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:

					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format(1).");
						delete[] pContents;
						return FALSE;
					}

					if (m_pPotionConfigList[atoi(token)] != NULL) {
					wsprintf(cTxt, "(!) POTION(Error Duplicate:%d)!", atoi(token));
					PutLogList(cTxt);
						delete[] pContents;
						return FALSE;
					}
					m_pPotionConfigList[atoi(token)] = new class CPotion;
					iPotionConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					ZeroMemory(m_pPotionConfigList[iPotionConfigListIndex]->m_cName, sizeof(m_pPotionConfigList[iPotionConfigListIndex]->m_cName));
					memcpy(m_pPotionConfigList[iPotionConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				default:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return FALSE;
					}
					m_pPotionConfigList[iPotionConfigListIndex]->m_sArray[cReadModeB - 3] = atoi(token);
					cReadModeB++;
					break;

			case 14:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pPotionConfigList[iPotionConfigListIndex]->m_sArray[11] = atoi(token);
				cReadModeB = 15;
				break;

			case 15:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pPotionConfigList[iPotionConfigListIndex]->m_iSkillLimit = atoi(token);
				cReadModeB = 16;
				break;

			case 16:

				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pPotionConfigList[iPotionConfigListIndex]->m_iDifficulty = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "potion", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}

		}
		token = pStrTok->pGet();
	}

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(ERROR) CRITICAL ERROR! POTION configuration file contents error!");
		return FALSE;
	}

	//wsprintf(cTxt, "(!) POTION(Total:%d) configuration - success!", iPotionConfigListIndex);
	//PutLogList(cTxt);

	return TRUE;
}

void CGame::LocalSavePlayerData(int iClientH)
{
	char * pData, * cp, cFn[256], cDir[256], cTxt[256], cCharDir[256];
	int    iSize;
	FILE * pFile;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;

	pData = new char[30000];
	if (pData == NULL) return;
	ZeroMemory(pData, 30000);

	cp = (char *)(pData);
	iSize = _iComposePlayerDataFileContents(iClientH, cp);

	GetLocalTime(&SysTime);
	ZeroMemory(cCharDir, sizeof(cDir));
	wsprintf(cCharDir, "Character_%d_%d_%d_%d", SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);

	ZeroMemory(cDir, sizeof(cDir));
	ZeroMemory(cFn, sizeof(cFn));
	strcat(cFn,cCharDir);
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	wsprintf(cTxt, "AscII%d", (unsigned char)m_pClientList[iClientH]->m_cCharName[0]);
	strcat(cFn, cTxt);
	strcpy(cDir, cFn);
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn, m_pClientList[iClientH]->m_cCharName);
	strcat(cFn, ".txt");

	_mkdir(cCharDir);
	_mkdir(cDir);


	if (iSize == 0) {
		PutLogList("(!) Character data body empty: Cannot create & save temporal player data file.");
		delete[] pData;
		return;
	}

	pFile = fopen(cFn, "wt");
	if (pFile == NULL) {
		wsprintf(cTxt, "(ERROR) Cannot create temporal player data file : Name(%s)", cFn);
		PutLogList(cTxt);
	}
	else {
		wsprintf(cTxt, "(!) temporal player data file saved : Name(%s)", cFn);
		PutLogList(cTxt);
		fwrite(cp, iSize, 1, pFile);
	}

	if (pFile != NULL) fclose(pFile);
	delete[] pData;
}

void CGame::MineralGenerator()
{
	register int i, iP, tX, tY, iRet;

	for (i = 0; i < MAXMAPS; i++) {

		if ((dice(1,4) == 1) && (m_pMapList[i] != NULL) && 
			(m_pMapList[i]->m_bMineralGenerator == TRUE) && 
			(m_pMapList[i]->m_iCurMineral < m_pMapList[i]->m_iMaxMineral)) {

				iP = dice(1, m_pMapList[i]->m_iTotalMineralPoint) - 1;
				if ((m_pMapList[i]->m_MineralPointList[iP].x == -1) || (m_pMapList[i]->m_MineralPointList[iP].y == -1)) break;

				tX = m_pMapList[i]->m_MineralPointList[iP].x;
				tY = m_pMapList[i]->m_MineralPointList[iP].y;

				iRet = iCreateMineral(i, tX, tY, m_pMapList[i]->m_cMineralGeneratorLevel);
		}
	}
}

int CGame::iCreateMineral(char cMapIndex, int tX, int tY, char cLevel)
{
	register int i, iDynamicHandle, iMineralType;

	if ((cMapIndex < 0) || (cMapIndex >= MAXMAPS)) return NULL;
	if (m_pMapList[cMapIndex] == NULL) return NULL;

	for (i = 1; i < MAXMINERALS; i++) 
		if (m_pMineral[i] == NULL) {

			iMineralType = dice(1, cLevel);
			m_pMineral[i] = new class CMineral(iMineralType, cMapIndex, tX, tY, 1);
			if (m_pMineral[i] == NULL) return NULL;

			iDynamicHandle = NULL;
			switch (iMineralType) {
			case 1: 		
			case 2:
			case 3:
			case 4:
				iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, NULL, i);
				break;

			case 5: 
			case 6:
				iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_MINERAL2, cMapIndex, tX, tY, NULL, i);
				break;

			default:
				iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, NULL, i);
				break;
			}

			if (iDynamicHandle == NULL) {
				delete m_pMineral[i];
				m_pMineral[i] = NULL;
				return NULL;
			}
			m_pMineral[i]->m_sDynamicObjectHandle = iDynamicHandle;
			m_pMineral[i]->m_cMapIndex = cMapIndex;


			switch (iMineralType) {
			case 1: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
			case 2: m_pMineral[i]->m_iDifficulty = 15; m_pMineral[i]->m_iRemain = 15; break;
			case 3: m_pMineral[i]->m_iDifficulty = 20; m_pMineral[i]->m_iRemain = 10; break;
			case 4: m_pMineral[i]->m_iDifficulty = 50; m_pMineral[i]->m_iRemain = 8; break;
			case 5: m_pMineral[i]->m_iDifficulty = 70; m_pMineral[i]->m_iRemain = 6; break;
			case 6: m_pMineral[i]->m_iDifficulty = 90; m_pMineral[i]->m_iRemain = 4; break;
			default: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
			}

			m_pMapList[cMapIndex]->m_iCurMineral++;

			return i;
		}

	return NULL;
}


void CGame::_CheckMiningAction(int iClientH, int dX, int dY)
{
	short sType;
	DWORD dwRegisterTime;
	int   iDynamicIndex, iSkillLevel, iResult;
	int   iMineralID = ITEM_COAL;
	class CItem * pItem;
	WORD  wWeaponType;

	if (m_pClientList[iClientH] == NULL)  return;


	m_pClientList[iClientH]->RemoveMagicEffect(MAGICTYPE_INVISIBILITY);


	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetDynamicObject(dX, dY, &sType, &dwRegisterTime, &iDynamicIndex);

	switch (sType) {
	case DYNAMICOBJECT_MINERAL1:
	case DYNAMICOBJECT_MINERAL2:

		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);
		if (wWeaponType == 25) {
		}
		else return;

		if ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) == 0) return;

		iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[SKILL_MINING];
		if (iSkillLevel == 0) break;

		if (m_pDynamicObjectList[iDynamicIndex] == NULL) break;

		iSkillLevel -= m_pMineral[ m_pDynamicObjectList[iDynamicIndex]->m_iV1 ]->m_iDifficulty;
		if (iSkillLevel <= 0) iSkillLevel = 1;

		iResult = dice(1, 100);
		if (iResult <= iSkillLevel) {
			CalculateSSN_SkillIndex(iClientH, SKILL_MINING, 1);

		switch (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_cType) {
				case 1: 
					switch (dice(1,6)) {
						case 1: 
						case 2: 
						case 3:    
						case 4: 
							iMineralID = ITEM_COAL; // Coal
							GetExp(iClientH, dice(1,3)); 
							break; 
						case 5:    
							iMineralID = ITEM_IRONORE; // IronOre
							GetExp(iClientH, dice(1,3)); 
							break; 
						case 6:
							iMineralID = ITEM_BLONDESTONE; // BlondeStone
							GetExp(iClientH, dice(1,3));
							break;
					} 
					break; 

				case 2: 
					switch (dice(1,7)) {
						case 1: 
						case 2: 
						case 3:
							iMineralID = ITEM_COAL; // Coal
							GetExp(iClientH, dice(1,3)); 
							break; 
						case 4:    
						case 5:  
						case 6:   
							iMineralID = ITEM_IRONORE; // IronOre
							GetExp(iClientH, dice(1,3)); 
							break; 
						case 7:
							if (dice(1,3) == 2) {
								iMineralID = ITEM_SILVERNUGGET; // SilverNugget
								GetExp(iClientH, dice(1,4)); 
							} 
							else { 
								iMineralID = ITEM_BLONDESTONE; // BlondeStone
								GetExp(iClientH, dice(1,3)); 
							} 
							break; 
					} 
					break; 

				case 3: 
					switch (dice(1,6)) {
						case 1:						 
							iMineralID = ITEM_COAL; // Coal
							GetExp(iClientH, dice(1,3)); 
							break; 
						case 2: 
						case 3:    
						case 4:    
						case 5: 
							iMineralID = ITEM_IRONORE; // IronOre
							GetExp(iClientH, dice(1,3)); 
							break; 
						case 6: 
							if (dice(1,8) == 3) {
								if (dice(1,2) == 1) {
									iMineralID = ITEM_SILVERNUGGET; // SilverNugget
									GetExp(iClientH, dice(1,4)); 
								} 
								else { 
									iMineralID = ITEM_BLONDESTONE; // BlondeStone
									GetExp(iClientH, dice(1,3)); 
								}
								break;
							} 
							else { 
								iMineralID = ITEM_IRONORE; // IronOre
								GetExp(iClientH, dice(1,3)); 
							} 
							break; 
					} 
					break; 

				case 4: 
					switch (dice(1,6)) {
						case 1:  
						case 2: 
							iMineralID = ITEM_COAL; // Coal
							GetExp(iClientH, dice(1,3)); 
							break;
						case 3:
							if (dice(1,3) == 2) {
								iMineralID =  ITEM_SILVERNUGGET; // SilverNugget
								GetExp(iClientH, dice(1,4)); 
							}
							else{
								iMineralID = ITEM_COAL; // Coal
								GetExp(iClientH, dice(1,3)); 
							}
							break;
						case 4:    
						case 5: 
							iMineralID = ITEM_IRONORE; // IronOre
							GetExp(iClientH, dice(1,3)); 
							break; 
						case 6: 
							if (dice(1,8) == 3) {
								if (dice(1,4) == 3) {
									if (dice(1,4) < 3) {
										iMineralID = ITEM_MITHRAL; // Mithral
										GetExp(iClientH, dice(1,15)); 
									} 
									else { 
										iMineralID =  ITEM_GOLDNUGGET; // GoldNugget
										GetExp(iClientH, dice(1,5)); 
									}
									break;
								} 
								else { 
									iMineralID =  ITEM_SILVERNUGGET; // SilverNugget
									GetExp(iClientH, dice(1,4)); 
								}
								break;
							} 
							else { 
								if (dice(1,2) == 1) {
									iMineralID = ITEM_GOLDNUGGET; // GoldNugget
									GetExp(iClientH, dice(1,5));
								}
								else {
									iMineralID = ITEM_IRONORE;  // IronOre
									GetExp(iClientH, dice(1,3)); 
								}
								break;
							} 
							break; 
					}
					break;

				case 5: 
					switch (dice(1,19)) {
						case 3: 
							iMineralID = ITEM_SAPPHIRE; // Sapphire
							GetExp(iClientH, dice(2,3)); 
							break; 
						default: 
							iMineralID = ITEM_CRYSTAL; // Crystal
							GetExp(iClientH, dice(2,3)); 
							break; 
					} 
					break; 

				case 6: 
					switch (dice(1,5)) {
						case 1: 
							if (dice(1,6) == 3) {
								iMineralID =  ITEM_EMERALD; // Emerald 
								GetExp(iClientH, dice(2,4)); 
							} 
							else { 
								iMineralID =  ITEM_CRYSTAL; // Crystal
								GetExp(iClientH, dice(2,3)); 
							} 
							break; 
						case 2: 
							if (dice(1,6) == 3) {
								iMineralID =  ITEM_SAPPHIRE; // Saphire
								GetExp(iClientH, dice(2,4)); 
							} 
							else { 
								iMineralID =  ITEM_CRYSTAL; // Crystal
								GetExp(iClientH, dice(2,3)); 
							} 
							break; 
						case 3: 
							if (dice(1,6) == 3) {
								iMineralID =  ITEM_RUBY; // Ruby
								GetExp(iClientH, dice(2,4)); 
							} 
							else { 
								iMineralID =  ITEM_CRYSTAL; // Crystal 
								GetExp(iClientH, dice(2,3)); 
							} 
							break; 
						case 4: 
							iMineralID =  ITEM_CRYSTAL; // Crystal 
							GetExp(iClientH, dice(2,3)); 
							break; 
						case 5: 
							if (dice(1,12) == 3) {
								iMineralID =  ITEM_DIAMOND; // Diamond
								GetExp(iClientH, dice(2,5)); 
							} 
							else { 
								iMineralID =  ITEM_CRYSTAL; // Crystal
								GetExp(iClientH, dice(2,3)); 
							} 
							break;
					} 
					break;

			} 

			pItem = new class CItem;
			if (_bInitItemAttr(pItem, iMineralID) == FALSE) {
				delete pItem;
			}
			else {

				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
					m_pClientList[iClientH]->m_sY, pItem);

				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
					pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 
			}

			m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain--;
			if (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain <= 0) {
				bDeleteMineral(m_pDynamicObjectList[iDynamicIndex]->m_iV1);
				delete m_pDynamicObjectList[iDynamicIndex];
				m_pDynamicObjectList[iDynamicIndex] = NULL;
			}
		}
		break;

	default: 
		break;
	}
}


bool CGame::bDeleteMineral(int iIndex)
{
	int iDynamicIndex;
	DWORD dwTime;

	dwTime = timeGetTime();

	if (m_pMineral[iIndex] == NULL) return FALSE;
	iDynamicIndex = m_pMineral[iIndex]->m_sDynamicObjectHandle;
	if (m_pDynamicObjectList[iDynamicIndex] == NULL) return FALSE;

	SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex, 
		m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, 
		m_pDynamicObjectList[iDynamicIndex]->m_sType, iDynamicIndex, NULL);
	m_pMapList[m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, dwTime);
	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->SetTempMoveAllowedFlag(m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, TRUE);

	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->m_iCurMineral--;

	delete m_pMineral[iIndex];
	m_pMineral[iIndex] = NULL;

	return TRUE;
}

void CGame::DeleteFlags()
{
	DWORD dwTime = timeGetTime(), dwRegisterTime;
	short sType;

	for (int i = 1; i < MAXDYNAMICOBJECTS; i++) 
	{ 
		if (m_pDynamicObjectList[i] && (m_pDynamicObjectList[i]->m_sType == DYNAMICOBJECT_ARESDENFLAG || 
			m_pDynamicObjectList[i]->m_sType == DYNAMICOBJECT_ELVINEFLAG)) 
		{
			m_pMapList[ m_pDynamicObjectList[i]->m_cMapIndex ]->bGetDynamicObject( 
				m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, &sType, &dwRegisterTime );

			SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, MSGTYPE_REJECT, m_pDynamicObjectList[i]->m_cMapIndex, 
				m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, m_pDynamicObjectList[i]->m_sType, i, NULL);
			m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->SetDynamicObject(NULL, NULL, 
				m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, dwTime);
			m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->SetTempMoveAllowedFlag(
				m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, TRUE);

			delete m_pDynamicObjectList[i];
			m_pDynamicObjectList[i] = NULL;
		}
	}
}

void CGame::NpcTalkHandler(int iClientH, int iWho)
{
	char cRewardName[21], cTargetName[21];
	int iResMode, iQuestNum, iQuestType, iRewardType, iRewardAmount, iContribution, iX, iY, iRange, iTargetType, iTargetCount;

	iQuestNum = 0;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	if (m_pClientList[iClientH] == NULL) return;
	switch (iWho) {
	case 1:			break;
	case 2:			break;
	case 3:			break;
	case 4:			iQuestNum = _iTalkToNpcResult_Cityhall(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange); 
		break;
	case 5:
		break;
	case 6:			break;

	case 32: 		break;
	case 67:
	case 68:
	case 69: 		break;

	case 21: 

		iQuestNum = _iTalkToNpcResult_Guard(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange); 
		if (iQuestNum >= 1000) return; 
		break;
	}

	ZeroMemory(cRewardName, sizeof(cRewardName));
	if (iQuestNum > 0) {
		if (iRewardType > 1) {

			strcpy(cRewardName, m_pItemConfigList[iRewardType]->m_cName);
		}
		else {
			switch (iRewardType) {
			case -10: strcpy(cRewardName, ""); break;
			}
		}


		m_pClientList[iClientH]->m_iAskedQuest        = iQuestNum;
		m_pClientList[iClientH]->m_iQuestRewardType   = iRewardType;
		m_pClientList[iClientH]->m_iQuestRewardAmount = iRewardAmount;

		SendNotifyMsg(NULL, iClientH, NOTIFY_NPCTALK, iQuestType, iResMode, iRewardAmount, cRewardName, iContribution,
			iTargetType, iTargetCount, iX, iY, iRange, cTargetName);
	}
	else {
		// Return Code

		switch (iQuestNum) {
		case  0: SendNotifyMsg(NULL, iClientH, NOTIFY_NPCTALK, (iWho+130), NULL, NULL, NULL, NULL); break;
		case -1:
		case -2:
		case -3:
		case -4: SendNotifyMsg(NULL, iClientH, NOTIFY_NPCTALK, abs(iQuestNum)+100, NULL, NULL, NULL, NULL); break;
		case -5: break;
		}
	}
}

void CGame::CheckFireBluring(char cMapIndex, int sX, int sY)
{
	register int ix, iy, iItemNum;
	register short sSpr, sSprFrame;
	char  cItemColor;
	class CItem * pItem;

	for (ix = sX -1; ix <= sX +1; ix++)
		for (iy = sY -1; iy <= sY +1; iy++) {
			iItemNum = m_pMapList[cMapIndex]->iCheckItem(ix, iy);

			switch (iItemNum) {
			case ITEM_COAL: 
				pItem = m_pMapList[cMapIndex]->pGetItem(ix, iy, &sSpr, &sSprFrame, &cItemColor);
				if (pItem != NULL) delete pItem;
				iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_FIRE, cMapIndex, ix, iy, 6000);

				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_SETITEM, cMapIndex,
					ix, iy, sSpr, sSprFrame, cItemColor);
				break;
			}
		}
}



void CGame::AdminOrder_GetNpcStatus(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cNpcName[256];
	register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));

	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy(cNpcName, token);
	}

	for (i = 0; i < MAXNPCS; i++) 
		if (m_pNpcList[i] != NULL) {
			if (memcmp(m_pNpcList[i]->m_cName, cNpcName, 5) == 0) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINIFO, 1, i, NULL, NULL);
			}
		}

}


int CGame::_iGetWeaponSkillType(int iClientH)
{
	WORD wWeaponType;

	if (m_pClientList[iClientH] == NULL) return 0;


	wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

	if (wWeaponType == 0) {
		return 5;
	}
	else if ((wWeaponType >= 1) && (wWeaponType <= 2)) {

		return 7;
	}
	else if ((wWeaponType > 2) && (wWeaponType < 20)) {
		if (wWeaponType == 7) 
			return 9; 
		else return 8; 	}
	else if ((wWeaponType >= 20) && (wWeaponType < 30)) {
		return 10;
	}
	else if ((wWeaponType >= 30) && (wWeaponType < 35)) {

		return 14; 	}
	else if ((wWeaponType >= 35) && (wWeaponType < 40)) {

		return 21;
	}
	else if (wWeaponType >= 40) {
		return 6;
	}

	return 1;
}



//                             1 2 3 
static int ___iCAB5[]  = {0,0, 0,1,2};
static int ___iCAB6[]  = {0,0, 0,0,0};
static int ___iCAB7[]  = {0,0, 1,2,3};
static int ___iCAB8[]  = {0,0, 1,3,5};
static int ___iCAB9[]  = {0,0, 2,4,8};
static int ___iCAB10[] = {0,0, 1,2,3};

int CGame::iGetComboAttackBonus(int iSkill, int iComboCount)
{
	if (iComboCount <= 1) return 0;
	if (iComboCount > 6) return 0;
	switch (iSkill) {
	case 5: 		return ___iCAB5[iComboCount];
		break;
	case 6: 		return ___iCAB6[iComboCount];
		break;
	case 7: 
		return ___iCAB7[iComboCount];
		break;
	case 8: 		return ___iCAB8[iComboCount];
		break;
	case 9: 
		return ___iCAB9[iComboCount];
		break;
	case 10: 		return ___iCAB10[iComboCount];
		break;
	case 14: 
		return ___iCAB6[iComboCount];
		break;
	case 21: 
		return ___iCAB10[iComboCount];
		break;
	}

	return 0;
}


void CGame::SetDownSkillIndexHandler(int iClientH, int iSkillIndex)
{
	if (m_pClientList[iClientH] == NULL) return;
	if ((iSkillIndex < 0) || (iSkillIndex >= MAXSKILLTYPE)) return;

	if (m_pClientList[iClientH]->m_cSkillMastery[iSkillIndex] > 0)
		m_pClientList[iClientH]->m_iDownSkillIndex = iSkillIndex;


	SendNotifyMsg(NULL, iClientH, NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
}


bool CGame::_bDepleteDestTypeItemUseEffect(int iClientH, int dX, int dY, short sItemIndex, short sDestItemID)
{
	bool bRet;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;

	switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
	case ITEMEFFECTTYPE_OCCUPYFLAG:

		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2)
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 = 100;

		bRet =  SetHeldenianFlag(m_pClientList[iClientH]->m_cMapIndex, dX, dY,
			                     m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
				 				 m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2, iClientH, 1);

		if (bRet == TRUE) {
		}
		else {
			SendNotifyMsg(NULL, iClientH, NOTIFY_NOTFLAGSPOT, NULL, NULL, NULL, NULL);
		}
		return bRet;

	case ITEMEFFECTTYPE_CONSTRUCTIONKIT:
		if(__bSetConstructionKit(m_pClientList[iClientH]->m_cMapIndex, dX, dY, 
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,
			iClientH))
		{
			if(--m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0)
				return TRUE;
		}
		return FALSE;

	case ITEMEFFECTTYPE_DYE:

		if ((sDestItemID >= 0) && (sDestItemID < MAXITEMS)) {
			if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != NULL) {
				if ( (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 11) ||
					(m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 12) ) {
						m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
						SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, NULL, NULL);
						return TRUE;
				}
				else {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, NULL, NULL);
					return FALSE;
				}
			}
		}
		break;
	case ITEMEFFECTTYPE_ITEMFARM:
		bRet = __bSetAgricultureItem(m_pClientList[iClientH]->m_cMapIndex, dX, dY,
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,
			iClientH); 		
		if (bRet == TRUE) {

		}
		else {

		}
		return bRet;
		break;

	default:
		break;
	}

	return TRUE;
}


bool CGame::__bSetOccupyFlag(char cMapIndex, int dX, int dY, int iSide, int iEKNum, int iClientH, bool bAdminFlag)
{
	register int ix,iy,tx,ty,fx,fy;
	int   iLocalSide, iLocalEKNum, iDynamicObjectIndex, iIndex, iPrevStatus;
	class CTile * pTile;
	bool  bFlag;
	DWORD dwTime = timeGetTime();

	return FALSE;


	if (cMapIndex != m_iMiddlelandMapIndex) return FALSE;

	if ((dX < 25) || (dX >= m_pMapList[cMapIndex]->m_sSizeX - 25) || 
		(dY < 25) || (dY >= m_pMapList[cMapIndex]->m_sSizeY - 25)) return FALSE;

	if ((iClientH > 0) && (m_pClientList[iClientH] != NULL)) {
		if ((bAdminFlag == FALSE) && (m_pClientList[iClientH]->m_side != iSide)) return FALSE;
	}


	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
	if (pTile->m_iOccupyFlagIndex != NULL) return FALSE;
	if (pTile->m_bIsMoveAllowed == FALSE)  return FALSE;


	for (ix = dX-5; ix <= dX+5; ix++) 
	{
		for (iy = dY-5; iy <= dY+5; iy++) {
			if (ix != dX || iy != dY)
{
				pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
				if ((pTile->m_iOccupyFlagIndex != NULL) && (pTile->m_iOccupyFlagIndex > 0) && 
					(pTile->m_iOccupyFlagIndex < MAXOCCUPYFLAG) && (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] != NULL)) {

						if (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_side == iSide) return FALSE;
				}
			}
		}
	}

	if (m_pMapList[cMapIndex]->m_iTotalOccupyFlags >= MAXOCCUPYFLAG) {

		return FALSE;
	}

	bFlag = FALSE;
	for (ix = dX - 10; ix <= dX + 10; ix++)
	{
		for (iy = dY - 8; iy <= dY + 8; iy++) {
			if (dX >= 0 && dX < m_pMapList[cMapIndex]->m_sSizeX && 
				dY >= 0 && dY < m_pMapList[cMapIndex]->m_sSizeY)
			{
				pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
				if (pTile->m_iOccupyFlagIndex && pTile->m_iOccupyFlagIndex > 0 && 
					pTile->m_iOccupyFlagIndex < MAXOCCUPYFLAG && 
					m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]) 
				{
						if (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_side == iSide) {
							bFlag = TRUE;
							goto SOF_LOOPBREAK1;
						}
				}
			}
		}
	}

SOF_LOOPBREAK1:;


	if ((bFlag == FALSE) && (bAdminFlag == FALSE)) return FALSE;

	// Crusade

	int iTemp, iDistance = 9999999;
	int iMinFlagIndex = -1;
	class CTile * pMinTile;

	for (ix = dX - 10; ix <= dX + 10; ix++)
	{
		for (iy = dY - 8; iy <= dY + 8; iy++) {
			if ((ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
				(iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY)) {
			}
			else {
				pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
				if ((pTile->m_iOccupyFlagIndex != NULL) && (pTile->m_iOccupyFlagIndex > 0) && 
					(pTile->m_iOccupyFlagIndex < MAXOCCUPYFLAG) && (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] != NULL) &&
					(m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_side != iSide)) {

						iTemp = (dX - ix)*(dX - ix) + (dY - iy)*(dY - iy);
						if (iTemp < iDistance) {
							iDistance = iTemp;
							iMinFlagIndex = pTile->m_iOccupyFlagIndex;
							pMinTile = pTile;
						}
				}
			}
		}
	}

	if (iMinFlagIndex != -1) {
		COccupyFlag *& minFlag = m_pMapList[cMapIndex]->m_pOccupyFlag[iMinFlagIndex];
		fx = minFlag->m_sX;
		fy = minFlag->m_sY;
		iLocalSide  = minFlag->m_side;
		iLocalEKNum = minFlag->m_iEKCount;

		m_pMapList[cMapIndex]->m_iTotalOccupyFlags--;

		iDynamicObjectIndex = minFlag->m_iDynamicObjectIndex;
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex, 
			m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, 
			m_pDynamicObjectList[iDynamicObjectIndex]->m_sType, iDynamicObjectIndex, NULL);
		m_pMapList[m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, dwTime);

		delete minFlag;
		minFlag = NULL;

		pMinTile->m_iOccupyFlagIndex = NULL;

		delete m_pDynamicObjectList[iDynamicObjectIndex];
		m_pDynamicObjectList[iDynamicObjectIndex] = NULL;
	}

	switch (iSide)
	{
	case ARESDEN:	iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_ARESDENFLAG, cMapIndex, dX, dY, NULL, NULL);	break;
	case ELVINE:	iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_ELVINEFLAG, cMapIndex, dX, dY, NULL, NULL);	break;
	}


	iEKNum = 1;
	iIndex = m_pMapList[cMapIndex]->iRegisterOccupyFlag(dX, dY, iSide, iEKNum, iDynamicObjectIndex);
	if (iIndex < 0) {

		return TRUE; 
	}

	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
	pTile->m_iOccupyFlagIndex = iIndex;

	m_pMapList[cMapIndex]->m_iTotalOccupyFlags++;

	_CheckStrategicPointOccupyStatus(cMapIndex);

	return TRUE;

					/*
					for (ix = dX - 10; ix <= dX + 10; ix++)
					for (iy = dY - 8; iy <= dY + 8; iy++) {
					if (iEKNum <= 0) goto SOF_LOOPBREAK2; 

					if ((ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
					(iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY)) {
					}
					else {
					pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
					if ((pTile->m_iOccupyFlagIndex != NULL) && (pTile->m_iOccupyFlagIndex > 0) && 
					(pTile->m_iOccupyFlagIndex < MAXOCCUPYFLAG) && (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] != NULL)) {

					if (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_side != iSide) {

					if (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iEKCount <= iEKNum) {

					// Crusade
					//if ((iClientH > 0) && (m_pClientList[iClientH] != NULL)) 
					//	m_pClientList[iClientH]->m_iExpStock += m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iEKCount * 40;


					fx = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_sX;
					fy = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_sY;
					iLocalSide  = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_side;
					iLocalEKNum = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iEKCount;

					m_pMapList[cMapIndex]->m_iTotalOccupyFlags--;

					iEKNum -= m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iEKCount;

					iDynamicObjectIndex = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iDynamicObjectIndex;
					SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex, 
					m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, 
					m_pDynamicObjectList[iDynamicObjectIndex]->m_sType, iDynamicObjectIndex, NULL);
					m_pMapList[m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, dwTime);

					delete m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex];
					m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] = NULL;

					pTile->m_iOccupyFlagIndex = NULL;

					delete m_pDynamicObjectList[iDynamicObjectIndex];
					m_pDynamicObjectList[iDynamicObjectIndex] = NULL;

					for (tx = fx - 10; tx <= fx + 10; tx++)
					for (ty = fy - 8; ty <= fy + 8; ty++) {
					if ((tx < 0) || (tx >= m_pMapList[cMapIndex]->m_sSizeX) || 
					(ty < 0) || (ty >= m_pMapList[cMapIndex]->m_sSizeY)) {
					}
					else {
					pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + tx + ty*m_pMapList[cMapIndex]->m_sSizeY);
					iPrevStatus = pTile->m_iOccupyStatus;

					switch (iLocalSide) {
					case 1: 
					pTile->m_iOccupyStatus += iLocalEKNum;
					if (pTile->m_iOccupyStatus > 0) pTile->m_iOccupyStatus = 0;
					break;
					case 2:
					pTile->m_iOccupyStatus -= iLocalEKNum;
					if (pTile->m_iOccupyStatus < 0) pTile->m_iOccupyStatus = 0;
					break;
					}
					}
					}
					}
					else {
					m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iEKCount -= iEKNum;
					iLocalSide = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_side;

					fx = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_sX;
					fy = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_sY;

					for (tx = fx - 10; tx <= fx + 10; tx++)
					for (ty = fy - 8; ty <= fy + 8; ty++) {
					if ((tx < 0) || (tx >= m_pMapList[cMapIndex]->m_sSizeX) || 
					(ty < 0) || (ty >= m_pMapList[cMapIndex]->m_sSizeY)) {
					}
					else {
					pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + tx + ty*m_pMapList[cMapIndex]->m_sSizeY);

					switch (iLocalSide) {
					case 1: 
					pTile->m_iOccupyStatus += iEKNum;
					if (pTile->m_iOccupyStatus > 0) pTile->m_iOccupyStatus = 0;
					break;
					case 2:
					pTile->m_iOccupyStatus -= iEKNum;
					if (pTile->m_iOccupyStatus < 0) pTile->m_iOccupyStatus = 0;
					break;
					}
					}
					}

					iEKNum = 0;
					}
					}
					}
					}
					}

					SOF_LOOPBREAK2:;



					if (iEKNum > 0) {

					switch (iSide) {
					case 1:	iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_ARESDENFLAG, cMapIndex, dX, dY, NULL, NULL);	break;
					case 2:	iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_ELVINEFLAG, cMapIndex, dX, dY, NULL, NULL);	break;
					}

					iIndex = m_pMapList[cMapIndex]->iRegisterOccupyFlag(dX, dY, iSide, iEKNum, iDynamicObjectIndex);
					if (iIndex < 0) {

					return TRUE; 
					}

					// Crusade
					//if ((iClientH > 0) && (m_pClientList[iClientH] != NULL)) 
					//	m_pClientList[iClientH]->m_iExpStock += iEKNum * 25;

					pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
					pTile->m_iOccupyFlagIndex = iIndex;

					m_pMapList[cMapIndex]->m_iTotalOccupyFlags++;

					for (ix = dX - 10; ix <= dX + 10; ix++)
					for (iy = dY - 8; iy <= dY + 8; iy++) {
					if ((ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
					(iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY)) {
					}
					else {
					pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);

					switch (iSide) {
					case 1: 
					pTile->m_iOccupyStatus -= iEKNum; 
					break;
					case 2:
					pTile->m_iOccupyStatus += iEKNum; 
					break;
					}
					}
					}
					}


					iPrevStatus = m_iStrategicStatus;
					_CheckStrategicPointOccupyStatus(cMapIndex);
					if ((iPrevStatus * m_iStrategicStatus) < 0) {

					}

					return TRUE;
					*/
}


void CGame::SetSummonMobAction(int iClientH, int iMode, DWORD dwMsgSize, char *pData)
{
	register int i, iTargetIndex;
	char   seps[] = "= \t\n";
	char   * token, cTargetName[11], cBuff[256];

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->IsNeutral()) return;

	switch (iMode) {
	case 0: 
	case 1: 
		for (i = 0; i < MAXNPCS; i++)
			if (m_pNpcList[i] != NULL) {
				if ( (m_pNpcList[i]->m_bIsSummoned == TRUE) && 
					(m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
					(m_pNpcList[i]->m_cFollowOwnerType == OWNERTYPE_PLAYER) &&
					!m_pNpcList[i]->IsDead()) {

						m_pNpcList[i]->m_iSummonControlMode = iMode;
						m_pNpcList[i]->m_bIsPermAttackMode  = FALSE;
						m_pNpcList[i]->m_cBehavior          = BEHAVIOR_MOVE;
						m_pNpcList[i]->m_sBehaviorTurnCount = 0;
						m_pNpcList[i]->m_iTargetIndex       = NULL;
				}
			}
			break;

	case 2:

		if ((dwMsgSize)	<= 0) return;
		memcpy(cBuff, pData, dwMsgSize);

		ZeroMemory(cTargetName, sizeof(cTargetName));
		StrTok pStrTok(new CStrTok(cBuff, seps));
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		iTargetIndex = 0;
		if (token != NULL) {

			if (strlen(token) > 10) 
				memcpy(cTargetName, token, 10);
			else memcpy(cTargetName, token, strlen(token));

			for (i = 1; i < MAXCLIENTS; i++) 
			{
				// if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) { // original
				if ((m_pClientList[i] != NULL) &&
					(memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0) &&
					(strcmp(m_pClientList[iClientH]->m_cMapName, m_pClientList[i]->m_cMapName) == 0 ) ) 
				{
					iTargetIndex = i;
					goto SSMA_SKIPSEARCH;
				}
			}
		}

SSMA_SKIPSEARCH:;

		if ( (iTargetIndex != 0) && (m_pClientList[iTargetIndex]->m_side != 0) && 
			(m_pClientList[iTargetIndex]->m_side != m_pClientList[iClientH]->m_side) ) {
				for (i = 0; i < MAXNPCS; i++)
					if (m_pNpcList[i] != NULL) {
						if ( (m_pNpcList[i]->m_bIsSummoned == TRUE) && 
							(m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
							(m_pNpcList[i]->m_cFollowOwnerType == OWNERTYPE_PLAYER) &&
							!m_pNpcList[i]->IsDead()) {
								m_pNpcList[i]->m_iSummonControlMode = iMode;
								m_pNpcList[i]->m_cBehavior          = BEHAVIOR_ATTACK;
								m_pNpcList[i]->m_sBehaviorTurnCount = 0;
								m_pNpcList[i]->m_iTargetIndex       = iTargetIndex;
								m_pNpcList[i]->m_cTargetType        = OWNERTYPE_PLAYER;
								m_pNpcList[i]->m_bIsPermAttackMode  = TRUE;
						}
					}
		}
		break;
	}
}

void CGame::GetOccupyFlagHandler(int iClientH)
{int   i, iNum, iRet, iEraseReq, iEKNum;
 char  * cp, cData[256], cItemName[21];
 class CItem * pItem;
 DWORD * dwp;
 short * sp;
 WORD  * wp;
  char cTxt[120];
 if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iEnemyKillCount < 2) return;
	if (!m_bHeldenianMode)						 return;
	if (m_pClientList[iClientH]->m_iGuildRank != 0)			 return;
 	ZeroMemory(cItemName, sizeof(cItemName));
	switch (m_pClientList[iClientH]->m_side) {
	case 1: strcpy(cItemName, "AresdenFlag"); break;
	case 2: strcpy(cItemName, "ElvineFlag");  break;
	}
	// ReqPurchaseItemHandler
	iNum = 1;
	for (i = 1; i <= iNum; i++) 
	{	pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) 
		{	delete pItem;
		}else 
		{	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
			{	if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				if (m_pClientList[iClientH]->m_iEnemyKillCount > 2) 
				{	iEKNum = 1;
					m_pClientList[iClientH]->m_iEnemyKillCount -= 2;
				}								
				// EKNum
				pItem->m_sItemSpecEffectValue2 = iEKNum;
				pItem->m_sTouchEffectType = ITET_UNIQUE_OWNER; 
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1; 
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2; 
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3; 
				//testcode 
				wsprintf(cTxt, "(*) Get Flag : Char(%s) Flag-EK(%d) Player-EK(%d)"
					, m_pClientList[iClientH]->m_cCharName
					, iEKNum
					, m_pClientList[iClientH]->m_iEnemyKillCount);
				PutLogList(cTxt);
				PutLogFileList(cTxt);
					
				PutLogFileList(cTxt); 
				dwp  = (DWORD *)(cData + INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + INDEX2_MSGTYPE);
				*wp  = NOTIFY_ITEMOBTAINED;
				cp = (char *)(cData + INDEX2_MSGTYPE + 2);
				*cp = 1;
				cp++;				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;				
				*cp = pItem->m_cItemType;
				cp++;				
				*cp = pItem->m_cEquipPos;
				cp++;				
				*cp = (char)0;  
				cp++;				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;				
				*cp = pItem->m_cGenderLimit;
				cp++;				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;
				*cp = pItem->m_cItemColor;
				cp++;
				*cp = (char)pItem->m_sItemSpecEffectValue2;
				cp++;					
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;
				/*
				*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item
				cp++;
				*/											
				if (iEraseReq == 1) delete pItem;				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				iCalcTotalWeight(iClientH);				
				switch (iRet) {
				case XSOCKEVENT_QUENEFULL:
				case XSOCKEVENT_SOCKETERROR:
				case XSOCKEVENT_CRITICALERROR:
				case XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				SendNotifyMsg(NULL, iClientH, NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL);
			}else 
			{	delete pItem;
				iCalcTotalWeight(iClientH);
				dwp  = (DWORD *)(cData + INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + INDEX2_MSGTYPE);
				*wp  = NOTIFY_CANNOTCARRYMOREITEM;				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case XSOCKEVENT_QUENEFULL:
				case XSOCKEVENT_SOCKETERROR:
				case XSOCKEVENT_CRITICALERROR:
				case XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
 	}	}	}	}
}







void CGame::GetFightzoneTicketHandler(int iClientH)
{
	int   iEraseReq, iMonth, iDay, iHour;
	char  cItemName[21];
	class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iFightZoneTicketNumber <= 0) {

		m_pClientList[iClientH]->m_iFightzoneNumber  *= -1;
		SendNotifyMsg(NULL, iClientH, NOTIFY_FIGHTZONERESERVE, -1, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cItemName, sizeof(cItemName));

	if (m_pClientList[iClientH]->m_iFightzoneNumber == 1) 
		strcpy(cItemName,ITEMNAME_ARENATICKET) ;
	else  wsprintf(cItemName,ITEMNAME_ARENATICKET2,m_pClientList[iClientH]->m_iFightzoneNumber ) ;

	pItem = new class CItem;
	if (_bInitItemAttr(pItem, cItemName) == FALSE) {
		delete pItem;
		return;
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

		m_pClientList[iClientH]->m_iFightZoneTicketNumber = m_pClientList[iClientH]->m_iFightZoneTicketNumber -1 ;

		pItem->m_sTouchEffectType   = ITET_DATE;

		iMonth = m_pClientList[iClientH]->m_iReserveTime / 10000 ;
		iDay = (m_pClientList[iClientH]->m_iReserveTime - iMonth*10000) /100 ;
		iHour = m_pClientList[iClientH]->m_iReserveTime - iMonth*10000 - iDay*100 ;

		pItem->m_sTouchEffectValue1 = iMonth ;
		pItem->m_sTouchEffectValue2 = iDay ;
		pItem->m_sTouchEffectValue3 = iHour ;

		_bItemLog(ITEMLOG_GET, iClientH, (int) -1, pItem);

		SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);

		if (iEraseReq == 1) 
		{
			delete pItem;
			pItem = NULL ;
		}
	}
	else {

		delete pItem;
		pItem = NULL ;

		iCalcTotalWeight(iClientH);

		SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
	}
}

int CGame::_iComposeFlagStatusContents(char * pData)
{
	SYSTEMTIME SysTime;
	char cTxt[120];
	int i;

	if (m_iMiddlelandMapIndex < 0) return 0;

	GetLocalTime(&SysTime);
	strcat(pData, "[FILE-DATE]\n\n");

	wsprintf(cTxt, "file-saved-date: %d %d %d %d %d\n", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");

	for (i = 1; i < MAXOCCUPYFLAG; i++) 
		if (m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i] != NULL) {

			wsprintf(cTxt,"flag = %d %d %d %d", m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_side,
				m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sX,
				m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sY,
				m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_iEKCount);
			strcat(pData, cTxt);
			strcat(pData, "\n");
		}

		strcat(pData, "\n\n");

		return strlen(pData);
}


bool CGame::_bDecodeOccupyFlagSaveFileContents(char * pData, DWORD dwMsgSize)
{
	char * pContents, * token;
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iSide;
	
	int dX, dY, iEKNum, iTotalFlags;

	if (m_iMiddlelandMapIndex < 0) {
		PutLogList("(!) This game server does not managing Middleland Map. OcuupyFlag data ignored.");
		return FALSE;
	}

	iTotalFlags = 0;

	pContents = new char[dwMsgSize+10];
	ZeroMemory(pContents, dwMsgSize+10);
	memcpy(pContents, pData, dwMsgSize - 9);

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();

	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
			case 1:
				// Side
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				iSide = atoi(token);
				cReadModeB = 2;
				break;

			case 2:

				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				dX = atoi(token);
				cReadModeB = 3;
				break;

			case 3:

				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				dY = atoi(token);
				cReadModeB = 4;
				break;

			case 4:
				// EKNum
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				iEKNum = atoi(token);

				if (__bSetOccupyFlag(m_iMiddlelandMapIndex, dX, dY, iSide, iEKNum, -1, TRUE) == TRUE)
					iTotalFlags++;

				cReadModeA = 0;
				cReadModeB = 0;
				break;
				}

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "flag", 4) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file contents error!");
		return FALSE;
	}

	wsprintf(g_cTxt, "(!) OccupyFlag save file decoding success! Total(%d)", iTotalFlags); 
	PutLogList(g_cTxt);

	return TRUE;
}


void CGame::GetHeroMantleHandler(int iClientH,int reqItem,char * pString) 
{ 
	int   i, iNum, iEraseReq; 
	char  cItemName[21]; 
	class CItem * pItem; 

	CClient * player = m_pClientList[iClientH];
	if (!player) return; 
	if (player->m_iEnemyKillCount < 100) return; 
	if (player->IsNeutral()) return; 
	if (_iGetItemSpaceLeft(iClientH) == 0) {
		SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, false);
		return;
	}

	if(reqItem < 0 || reqItem >= HR_MAX) return;

	uint32 iItemID = HeroItemID[reqItem][ player->m_side-1 ][ player->m_cSex-1 ];

	if(player->m_iEnemyKillCount < heroPrice[reqItem].EK ||
		player->m_iContribution < heroPrice[reqItem].contribution)
		return;

	if (!m_pItemConfigList[iItemID])  return;

	ZeroMemory(cItemName, sizeof(cItemName)); 
	memcpy(cItemName,m_pItemConfigList[iItemID]->m_cName,20); 
	// ReqPurchaseItemHandler
	iNum = 1; 
	for (i = 1; i <= iNum; i++) 
	{ 
		pItem = new class CItem; 
		if (_bInitItemAttr(pItem, cItemName) == FALSE) 
		{ 
			delete pItem; 
		} 
		else { 

			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {

				player->m_iEnemyKillCount -= heroPrice[reqItem].EK;
				player->m_iContribution -= heroPrice[reqItem].contribution;

				if (player->m_iCurWeightLoad < 0) player->m_iCurWeightLoad = 0; 

				wsprintf(g_cTxt, "(*) Get HeroItem : Char(%s) Player-EK(%d) Player-Contr(%d) Hero Obtained(%s)", player->m_cCharName, player->m_iEnemyKillCount, player->m_iContribution,cItemName); 
				PutLogFileList(g_cTxt); 

				pItem->m_sTouchEffectType = ITET_UNIQUE_OWNER; 
				pItem->m_sTouchEffectValue1 = player->m_sCharIDnum1; 
				pItem->m_sTouchEffectValue2 = player->m_sCharIDnum2; 
				pItem->m_sTouchEffectValue3 = player->m_sCharIDnum3; 

				SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);

				if (iEraseReq == 1) delete pItem; 

				SendNotifyMsg(NULL, iClientH, NOTIFY_ENEMYKILLS, player->m_iEnemyKillCount, NULL, NULL, NULL); 
			} 
			else 
			{ 
				delete pItem; 

				iCalcTotalWeight(iClientH); 

				SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
			} 
		} 
	} 
}

void CGame::_SetItemPos(int iClientH, char *pData)
{
	char * cp, cItemIndex;
	short * sp, sX, sY;

	if (m_pClientList[iClientH] == NULL) return;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	cItemIndex = *cp;
	cp++;

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	if (sY < -10) sY = -10; 

	if ((cItemIndex < 0) || (cItemIndex >= MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemIndex] != NULL) {
		m_pClientList[iClientH]->m_ItemPosList[cItemIndex].x = sX;
		m_pClientList[iClientH]->m_ItemPosList[cItemIndex].y = sY;
	}
}

void CGame::CheckUniqueItemEquipment(int iClientH)
{
	register int i, iDamage;

	if (m_pClientList[iClientH] == NULL) return;

	for (i = 0; i < MAXITEMS; i++) 
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
			if ( (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType == ITET_UNIQUE_OWNER) &&
				(m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE) ) {


					if ( (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
						(m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
						(m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3) ) {

					}
					else {
						SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos, i, NULL, NULL);
						ReleaseItemHandler(iClientH, i, TRUE);

						iDamage = dice(10, 10);
						m_pClientList[iClientH]->m_iHP -= iDamage;
						if (m_pClientList[iClientH]->m_iHP <= 0) {
							m_pClientList[iClientH]->KilledHandler(NULL, NULL, iDamage);
						}
					}
			}
		}
}


void CGame::_Manager_Init(int iClientH, char *  pData)
{
	if (m_pClientList[iClientH] == NULL) return;
	char cTemp[256] ;
	DWORD * dwp ;
	WORD * wp ;
	char * cp ;
	short * sp ;

	ZeroMemory(cTemp, sizeof(cTemp));

	cp = (char *)(pData + 6);

	memcpy(cTemp,cp,10) ;

	if (memcmp(cTemp,"?BWordMtr?",10) != 0) return ;

	m_pClientList[iClientH]->m_bIsManager = TRUE;
	m_iTotalClients-- ;

	ZeroMemory(cTemp, sizeof(cTemp));

	dwp = (DWORD *)cTemp;
	*dwp = MSGID_RESPONSE_CHECKCONNECTION;

	wp  = (WORD *)(cTemp + INDEX2_MSGTYPE);
	*wp = NULL;

	cp  = (char *)(cTemp + INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;

	if ((m_bIsGameStarted == TRUE) && (m_bIsItemAvailable == TRUE) && 
		(m_bIsNpcAvailable == TRUE) && (m_bIsMagicAvailable == TRUE) &&
		(m_bIsSkillAvailable == TRUE) && (m_bIsPotionAvailable == TRUE) &&
		(m_bIsQuestAvailable == TRUE)
		) {

			*sp =  1 ; 
	} 
	else 
	{
		*sp =  0 ; 
	}
	cp += 2 ;

	sp  = (short *)cp;
	*sp = m_iTotalClients ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = m_iMaxClients ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = m_iTotalGameServerClients ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = m_iTotalGameServerMaxClients ;
	cp += 2 ;

	m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, 16 );

	wsprintf(g_cTxt, "(*) Manager Program(%d) Registered.", iClientH);
	PutLogList(g_cTxt);
}


void CGame::_Manager_Shutdown(int iClientH, char * pData)
{
	return ;
	if (m_pClientList[iClientH] == NULL) return;
	char cTemp[256] ;
	char * cp ;


	ZeroMemory(cTemp, sizeof(cTemp));

	cp = (char *)(pData + 6);

	memcpy(cTemp,cp,10) ;

	if (memcmp(cTemp,"1dkld$#@01",10) != 0) return ;


	m_cShutDownCode      = 2;
	m_bOnExitProcess     = TRUE;
	m_dwExitProcessTime  = timeGetTime();

	PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Admin-Command)!!!");
	bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);

	wsprintf(g_cTxt, "(*) Manager Program(%d) Start Shutdown.", iClientH);
	PutLogList(g_cTxt);
}

void CGame::ExchangeItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, WORD wObjectID, char *pItemName)
{
	short sOwnerH;
	char  cOwnerType;
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount < iAmount) return;
	if (m_pClientList[iClientH]->m_isExchangeMode == TRUE) return;
	if (wObjectID >= MAXCLIENTS) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;	//DEBUG

	if(m_astoria.get() && m_astoria->GetRelicHolder() == m_pClientList[iClientH]) return;

#ifdef GUILDWARMODE
	return;
#endif

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

	if ((sOwnerH != NULL) && (cOwnerType == OWNERTYPE_PLAYER)) {

		if (wObjectID != NULL) {
			if (wObjectID < 10000) {
				if (m_pClientList[wObjectID] != NULL) {
					if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;
				}
			}
			else sOwnerH = NULL;
		}

		if ((sOwnerH == NULL) || (m_pClientList[sOwnerH] == NULL)) {
			_ClearExchangeStatus(iClientH); 
		}
		else {
			if ((m_pClientList[sOwnerH]->m_isExchangeMode == TRUE) || (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) ||
				(m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) {

					_ClearExchangeStatus(iClientH);
			}
			else {
				m_pClientList[iClientH]->m_isExchangeMode = TRUE;
				m_pClientList[iClientH]->m_exchangeH = sOwnerH;
				ZeroMemory(m_pClientList[iClientH]->m_exchangeName, sizeof(m_pClientList[iClientH]->m_exchangeName));
				strcpy(m_pClientList[iClientH]->m_exchangeName, m_pClientList[sOwnerH]->m_cCharName);

				m_pClientList[iClientH]->m_exchangeCount = 0;
				m_pClientList[sOwnerH]->m_exchangeCount = 0;

				for(i = 0; i < 4; i++){
					m_pClientList[iClientH]->m_exchangeItems[i].itemAmount = 0;
					m_pClientList[iClientH]->m_exchangeItems[i].itemIndex = -1;
					ZeroMemory(m_pClientList[iClientH]->m_exchangeItems[i].itemName, sizeof(m_pClientList[iClientH]->m_exchangeItems[i].itemName));

					m_pClientList[sOwnerH]->m_exchangeItems[i].itemAmount = 0;
					m_pClientList[sOwnerH]->m_exchangeItems[i].itemIndex = -1;
					ZeroMemory(m_pClientList[sOwnerH]->m_exchangeItems[i].itemName, sizeof(m_pClientList[sOwnerH]->m_exchangeItems[i].itemName));
				}


				m_pClientList[iClientH]->m_exchangeItems[m_pClientList[iClientH]->m_exchangeCount].itemIndex  = (char)sItemIndex;
				m_pClientList[iClientH]->m_exchangeItems[m_pClientList[iClientH]->m_exchangeCount].itemAmount = iAmount;
				memcpy(m_pClientList[iClientH]->m_exchangeItems[m_pClientList[iClientH]->m_exchangeCount].itemName, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, 20);

				m_pClientList[sOwnerH]->m_isExchangeMode  = TRUE;
				m_pClientList[sOwnerH]->m_exchangeH = iClientH;

				ZeroMemory(m_pClientList[sOwnerH]->m_exchangeName, sizeof(m_pClientList[sOwnerH]->m_exchangeName));
				strcpy(m_pClientList[sOwnerH]->m_exchangeName, m_pClientList[iClientH]->m_cCharName);

				m_pClientList[iClientH]->m_exchangeCount++;
				SendNotifyMsg(iClientH, iClientH, NOTIFY_OPENEXCHANGEWINDOW, sItemIndex + 1000, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, iAmount, 
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 +100,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute);

				SendNotifyMsg(iClientH, sOwnerH, NOTIFY_OPENEXCHANGEWINDOW, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, iAmount, 
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 +100,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute);
			}
		}
	}
	else {

		_ClearExchangeStatus(iClientH);
	}
}



void CGame::SetExchangeItem(int iClientH, int iItemIndex, int iAmount)
{
	int iExH, i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;	
	if (m_pClientList[iClientH]->m_exchangeCount > 4) return;

	if ((m_pClientList[iClientH]->m_isExchangeMode == TRUE) && (m_pClientList[iClientH]->m_exchangeH != NULL)) {
		iExH = m_pClientList[iClientH]->m_exchangeH;
		if (m_pClientList[iExH] != NULL && memcmp(m_pClientList[iClientH]->m_exchangeName, m_pClientList[iExH]->m_cCharName, 10) == 0 ) {

			if ((iItemIndex < 0) || (iItemIndex >= MAXITEMS)) return;
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return;
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount < iAmount) return;

			for(i = 0; i < m_pClientList[iClientH]->m_exchangeCount;i++){
				if (m_pClientList[iClientH]->m_exchangeItems[i].itemIndex == (char)iItemIndex) {
					_ClearExchangeStatus(iExH);
					_ClearExchangeStatus(iClientH);
					return;
				}
			}

			m_pClientList[iClientH]->m_exchangeItems[m_pClientList[iClientH]->m_exchangeCount].itemIndex  = (char)iItemIndex;
			m_pClientList[iClientH]->m_exchangeItems[m_pClientList[iClientH]->m_exchangeCount].itemAmount = iAmount;

			memcpy(m_pClientList[iClientH]->m_exchangeItems[m_pClientList[iClientH]->m_exchangeCount].itemName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, 20);

			m_pClientList[iClientH]->m_exchangeCount++;

			SendNotifyMsg(iClientH, iClientH, NOTIFY_SETEXCHANGEITEM, iItemIndex+1000, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame, 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, iAmount, 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 +100,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute); 

			SendNotifyMsg(iClientH, iExH, NOTIFY_SETEXCHANGEITEM, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame, 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, iAmount, 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 +100,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute);
		}
	}
}


void CGame::ConfirmExchangeItem(int iClientH)
{
	int iExH, i;
	int iItemWeightA, iItemWeightB, iWeightLeftA, iWeightLeftB, iAmountLeft;
	class CItem * pItemA[4], * pItemB[4], * pItemAcopy[4], * pItemBcopy[4];

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
	if(m_astoria.get() && m_astoria->GetRelicHolder() == m_pClientList[iClientH]) return;


	if ((m_pClientList[iClientH]->m_isExchangeMode == TRUE) && (m_pClientList[iClientH]->m_exchangeH != NULL)) {
		iExH = m_pClientList[iClientH]->m_exchangeH;
		if(m_astoria.get() && m_astoria->GetRelicHolder() == m_pClientList[iExH]) return;

		if(iClientH == iExH) return;	
		if (m_pClientList[iExH] != NULL) {
			if ( (memcmp(m_pClientList[iClientH]->m_exchangeName, m_pClientList[iExH]->m_cCharName, 10) != 0) ||
				(m_pClientList[iExH]->m_isExchangeMode != TRUE) ||
				(memcmp(m_pClientList[iExH]->m_exchangeName, m_pClientList[iClientH]->m_cCharName, 10) != 0) ) {
					_ClearExchangeStatus(iClientH);
					_ClearExchangeStatus(iExH);
					return;
			}
			else {
				m_pClientList[iClientH]->m_isExchangeConfirm = TRUE;
				if (m_pClientList[iExH]->m_isExchangeConfirm == TRUE) {
					for(i = 0; i < m_pClientList[iClientH]->m_exchangeCount; i++){
						if ((m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex] == NULL) ||
							(memcmp(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex]->m_cName, m_pClientList[iClientH]->m_exchangeItems[i].itemName, 20) != 0)) {
								_ClearExchangeStatus(iClientH);
								_ClearExchangeStatus(iExH);
								return;
						}
					}

					for(i = 0; i < m_pClientList[iExH]->m_exchangeCount; i++){
						if ((m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex] == NULL) ||
							(memcmp(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->m_cName, m_pClientList[iExH]->m_exchangeItems[i].itemName, 20) != 0)) {
								_ClearExchangeStatus(iClientH);
								_ClearExchangeStatus(iExH);
								return;
						}
					}

					iWeightLeftA = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);
					iWeightLeftB = _iCalcMaxLoad(iExH) - iCalcTotalWeight(iExH);

					iItemWeightA = 0;
					for(i = 0; i < m_pClientList[iClientH]->m_exchangeCount; i++){
						iItemWeightA = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex],
							m_pClientList[iClientH]->m_exchangeItems[i].itemAmount);
					}

					iItemWeightB = 0;
					for(i = 0; i < m_pClientList[iExH]->m_exchangeCount; i++){
						iItemWeightB = iGetItemWeight(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex],
							m_pClientList[iExH]->m_exchangeItems[i].itemAmount);
					}

					if ((iWeightLeftA < iItemWeightB) || (iWeightLeftB < iItemWeightA)) {
						_ClearExchangeStatus(iClientH);
						_ClearExchangeStatus(iExH);
						return;
					}
					
					if (_iGetItemSpaceLeft(iClientH) == 0 || _iGetItemSpaceLeft(iExH) == 0) {
						_ClearExchangeStatus(iClientH);
						_ClearExchangeStatus(iExH);
						return;
					}

					for(i = 0; i < m_pClientList[iClientH]->m_exchangeCount; i++){
						if ( (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex]->m_cItemType == ITEMTYPE_CONSUME) ||
							(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex]->m_cItemType == ITEMTYPE_ARROW) ) {

								if (m_pClientList[iClientH]->m_exchangeItems[i].itemAmount > m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex]->m_dwCount) {
									_ClearExchangeStatus(iClientH);
									_ClearExchangeStatus(iExH);
									return;		
								}

								pItemA[i] = new class CItem;
								_bInitItemAttr(pItemA[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex]->m_cName);
								pItemA[i]->m_dwCount = m_pClientList[iClientH]->m_exchangeItems[i].itemAmount;

								pItemAcopy[i] = new class CItem;
								_bInitItemAttr(pItemAcopy[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex]->m_cName);
								bCopyItemContents(pItemAcopy[i], pItemA[i]);
								pItemAcopy[i]->m_dwCount = m_pClientList[iClientH]->m_exchangeItems[i].itemAmount;
						}
						else {
							pItemA[i] = (class CItem *)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex];
							pItemA[i]->m_dwCount = m_pClientList[iClientH]->m_exchangeItems[i].itemAmount;
 
							pItemAcopy[i] = new class CItem;
							_bInitItemAttr(pItemAcopy[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex]->m_cName);
							bCopyItemContents(pItemAcopy[i], pItemA[i]);
							pItemAcopy[i]->m_dwCount = m_pClientList[iClientH]->m_exchangeItems[i].itemAmount;
						}
					}

					for(i = 0; i < m_pClientList[iExH]->m_exchangeCount; i++){
						if ( (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->m_cItemType == ITEMTYPE_CONSUME) ||
							(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->m_cItemType == ITEMTYPE_ARROW) ) {

								if (m_pClientList[iExH]->m_exchangeItems[i].itemAmount > m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->m_dwCount) {
									_ClearExchangeStatus(iClientH);
									_ClearExchangeStatus(iExH);
									return;		
								}

								pItemB[i] = new class CItem;
								_bInitItemAttr(pItemB[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->m_cName);
								pItemB[i]->m_dwCount = m_pClientList[iExH]->m_exchangeItems[i].itemAmount;

								pItemBcopy[i] = new class CItem;
								_bInitItemAttr(pItemBcopy[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->m_cName);
								bCopyItemContents(pItemBcopy[i], pItemB[i]);
								pItemBcopy[i]->m_dwCount = m_pClientList[iExH]->m_exchangeItems[i].itemAmount;
						}
						else {
							pItemB[i] = (class CItem *)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex];
							pItemB[i]->m_dwCount = m_pClientList[iExH]->m_exchangeItems[i].itemAmount;

							pItemBcopy[i] = new class CItem;
							_bInitItemAttr(pItemBcopy[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->m_cName);
							bCopyItemContents(pItemBcopy[i], pItemB[i]);
							pItemBcopy[i]->m_dwCount = m_pClientList[iExH]->m_exchangeItems[i].itemAmount;
						}
					}


					for(i = 0; i < m_pClientList[iExH]->m_exchangeCount; i++){
						bAddItem(iClientH, pItemB[i]);
						_bItemLog(ITEMLOG_EXCHANGE, iExH, iClientH, pItemBcopy[i]);
						delete pItemBcopy[i];
						pItemBcopy[i] = NULL;
						if ( (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->m_cItemType == ITEMTYPE_CONSUME) ||
							(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->m_cItemType == ITEMTYPE_ARROW) ) {

							iAmountLeft = (int)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->m_dwCount - m_pClientList[iExH]->m_exchangeItems[i].itemAmount;
							if (iAmountLeft < 0) iAmountLeft = 0;	  

							SetItemCount(iExH, m_pClientList[iExH]->m_exchangeItems[i].itemIndex, iAmountLeft);
						}
						else {
							ReleaseItemHandler(iExH, m_pClientList[iExH]->m_exchangeItems[i].itemIndex, TRUE);
							SendNotifyMsg(NULL, iExH, NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iExH]->m_exchangeItems[i].itemIndex, m_pClientList[iExH]->m_exchangeItems[i].itemAmount, NULL, m_pClientList[iClientH]->m_cCharName);
							m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex] = NULL;
						}
					}

					for(i = 0; i < m_pClientList[iClientH]->m_exchangeCount; i++){
						bAddItem(iExH, pItemA[i]);
						_bItemLog(ITEMLOG_EXCHANGE, iClientH, iExH, pItemAcopy[i]);
						delete pItemAcopy[i];
						pItemAcopy[i] = NULL;

						if ( (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex]->m_cItemType == ITEMTYPE_CONSUME) ||
							(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex]->m_cItemType == ITEMTYPE_ARROW) ) {

							iAmountLeft = (int)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex]->m_dwCount - m_pClientList[iClientH]->m_exchangeItems[i].itemAmount;
							if (iAmountLeft < 0) iAmountLeft = 0;	 

							SetItemCount(iClientH, m_pClientList[iClientH]->m_exchangeItems[i].itemIndex, iAmountLeft);
						}
						else {
							ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_exchangeItems[i].itemIndex, TRUE);
							SendNotifyMsg(NULL, iClientH, NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iClientH]->m_exchangeItems[i].itemIndex, m_pClientList[iClientH]->m_exchangeItems[i].itemAmount, NULL, m_pClientList[iExH]->m_cCharName);
							m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex] = NULL;
						}
					}

					m_pClientList[iClientH]->m_isExchangeMode = FALSE;
					m_pClientList[iClientH]->m_isExchangeConfirm = FALSE;
					ZeroMemory(m_pClientList[iClientH]->m_exchangeName, sizeof(m_pClientList[iClientH]->m_exchangeName));
					m_pClientList[iClientH]->m_exchangeH = NULL;
					m_pClientList[iClientH]->m_exchangeCount = 0;

					m_pClientList[iExH]->m_isExchangeMode = FALSE;
					m_pClientList[iExH]->m_isExchangeConfirm = FALSE;
					ZeroMemory(m_pClientList[iExH]->m_exchangeName, sizeof(m_pClientList[iExH]->m_exchangeName));
					m_pClientList[iExH]->m_exchangeH = NULL;
					m_pClientList[iClientH]->m_exchangeCount = 0;

					for(i = 0; i < 4; i++){
						m_pClientList[iClientH]->m_exchangeItems[i].itemIndex = -1;
						m_pClientList[iExH]->m_exchangeItems[i].itemIndex = -1;
					}

					SendNotifyMsg(NULL, iClientH, NOTIFY_EXCHANGEITEMCOMPLETE, NULL, NULL, NULL, NULL);
					SendNotifyMsg(NULL, iExH,     NOTIFY_EXCHANGEITEMCOMPLETE, NULL, NULL, NULL, NULL);

					iCalcTotalWeight(iClientH);
					iCalcTotalWeight(iExH);
					return;									
				}
			}
		}
		else {
			_ClearExchangeStatus(iClientH);
			return;
		}
	}
}



int CGame::_iGetItemSpaceLeft(int iClientH)
{
	int i, iTotalItem;

	iTotalItem = 0;
	for (i = 0; i < MAXITEMS; i++) 
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) iTotalItem++;

	return (MAXITEMS - iTotalItem);
}

bool CGame::bAddItem(int iClientH, CItem * pItem)
{
	char cData[256];
	int iEraseReq;


	ZeroMemory(cData, sizeof(cData));
	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {

		SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);

		if (iEraseReq == 1) {
			delete pItem;
			pItem = NULL;
		}

		return TRUE;
	}
	else {

		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			m_pClientList[iClientH]->m_sY, 
			pItem);

		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
			pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);

		SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, false);

		return TRUE;
	}

	return FALSE;
}


void CGame::CancelExchangeItem(int iClientH)
{
	int iExH;

	iExH = m_pClientList[iClientH]->m_exchangeH;
	_ClearExchangeStatus(iExH);
	_ClearExchangeStatus(iClientH);
}


void CGame::_ClearExchangeStatus(int iClientH)
{
	if ((iClientH <= 0) || (iClientH >= MAXCLIENTS)) return;
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_isExchangeMode == TRUE) 
		SendNotifyMsg(NULL, iClientH, NOTIFY_CANCELEXCHANGEITEM, NULL, NULL, NULL, NULL);

	m_pClientList[iClientH]->m_isExchangeMode    = FALSE;
	m_pClientList[iClientH]->m_isExchangeConfirm = FALSE;
	m_pClientList[iClientH]->m_exchangeH = NULL;

	ZeroMemory(m_pClientList[iClientH]->m_exchangeName, sizeof(m_pClientList[iClientH]->m_exchangeName));
}

int CGame::_iTalkToNpcResult_Cityhall(int iClientH, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
	int iQuest, iEraseReq, iExp;
	class CItem * pItem;

	// Return Code

	if (m_pClientList[iClientH] == NULL) return 0;

	if (m_pClientList[iClientH]->m_iQuest != NULL) {
		if (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest] == NULL) return -4;
		else if (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iFrom == 4) {
			if (m_pClientList[iClientH]->m_bIsQuestCompleted == TRUE) {

				if ( (m_pClientList[iClientH]->m_iQuestRewardType > 0) &&
					(m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType] != NULL) ) {

						pItem = new class CItem;
						_bInitItemAttr(pItem, m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName);
						pItem->m_dwCount = m_pClientList[iClientH]->m_iQuestRewardAmount;
						if (_bCheckItemReceiveCondition(iClientH, pItem) == TRUE) {

							_bAddClientItemList(iClientH, pItem, &iEraseReq);
							SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, false);
							if (iEraseReq == 1) {
								delete pItem;
								pItem = NULL;
							}

							m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

							SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTREWARD, 4, 1, m_pClientList[iClientH]->m_iQuestRewardAmount, 
								m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName, m_pClientList[iClientH]->m_iContribution);

							_ClearQuestStatus(iClientH);
							return -5;
						} 
						else {
							delete pItem;
							pItem = NULL;

							SendItemNotifyMsg(iClientH,	NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, false);

							SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTREWARD, 4, 0, m_pClientList[iClientH]->m_iQuestRewardAmount, 
								m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName, m_pClientList[iClientH]->m_iContribution);

							return -5;
						}
				}
				else if (m_pClientList[iClientH]->m_iQuestRewardType == -1) {
					GetExp(iClientH, m_pClientList[iClientH]->m_iQuestRewardAmount); //m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iQuestRewardAmount;
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;
					SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTREWARD, 4, 1, m_pClientList[iClientH]->m_iQuestRewardAmount, 
						"              ", m_pClientList[iClientH]->m_iContribution);


					_ClearQuestStatus(iClientH);
					return -5;
				}
				else if (m_pClientList[iClientH]->m_iQuestRewardType == -2) {


					iExp = dice(1, (10*m_pClientList[iClientH]->m_iLevel));
					iExp = iExp * m_pClientList[iClientH]->m_iQuestRewardAmount;

					GetExp(iClientH, iExp); //m_pClientList[iClientH]->m_iExpStock += iExp;

					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTREWARD, 4, 1, iExp, 
						"              ", m_pClientList[iClientH]->m_iContribution);


					_ClearQuestStatus(iClientH);
					return -5;
				}
				else {
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTREWARD, 4, 1, 0, 
						"                     ", m_pClientList[iClientH]->m_iContribution);

					_ClearQuestStatus(iClientH);
					return -5;
				}
			}
			else return -1;
		}

		return -4;
	}

	if( m_pClientList[iClientH]->m_iIsOnTown == NONPK ) {
		if (m_pClientList[iClientH]->m_iPKCount > 0) return -3;

		iQuest = __iSearchForQuest(iClientH, 4, pQuestType, pMode, pRewardType, pRewardAmount, pContribution, pTargetName, pTargetType, pTargetCount, pX, pY, pRange);
		if (iQuest <= 0) return -4;

		return iQuest;
	}
	else return -2; 
	return -4;
}


int CGame::_iTalkToNpcResult_Guard(int iClientH, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{

	if (m_pClientList[iClientH] == NULL) return 0;

	if (m_pClientList[iClientH]->m_side == ARESDEN ) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ARESDEN], 7) == 0) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_NPCTALK, (200), NULL, NULL, NULL, NULL);
			return 1000;
		}
		else if (memcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ELVINE], 6) == 0) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_NPCTALK, (201), NULL, NULL, NULL, NULL);
			return 1001;
		}
	}
	else if (m_pClientList[iClientH]->m_side == ELVINE ) {
			if (memcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ARESDEN], 7) == 0) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_NPCTALK, (202), NULL, NULL, NULL, NULL);
				return 1002;
			}
			else if (memcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ELVINE], 6) == 0) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_NPCTALK, (203), NULL, NULL, NULL, NULL);
				return 1003;
			}
	}
	else if (m_pClientList[iClientH]->IsNeutral()) {
			if (memcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ARESDEN], 7) == 0) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_NPCTALK, (204), NULL, NULL, NULL, NULL);
				return 1004;
			}
			else if (memcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ELVINE], 6) == 0) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_NPCTALK, (205), NULL, NULL, NULL, NULL);
				return 1005;
			}
			else if (memcmp(m_pClientList[iClientH]->m_cMapName, sideMap[NEUTRAL], 7) == 0) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_NPCTALK, (206), NULL, NULL, NULL, NULL);
				return 1006;
			}
	}

	return 0;
}


bool CGame::_bDecodeQuestConfigFileContents(char * pData, DWORD dwMsgSize)
{
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iQuestConfigListIndex = 0;
	

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();

	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
			case 1:

				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				if (m_pQuestConfigList[atoi(token)] != NULL) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Duplicate quest number.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[atoi(token)] = new class CQuest;
				iQuestConfigListIndex = atoi(token);

				cReadModeB = 2;
				break;

			case 2:

				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_side = atoi(token);
				cReadModeB = 3;
				break;

			case 3:

				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iType = atoi(token);
				cReadModeB = 4;
				break;

			case 4:
				// TargetType
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iTargetType = atoi(token);
				cReadModeB = 5;
				break;

			case 5:
				// MaxCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxCount= atoi(token);
				cReadModeB = 6;
				break;

			case 6:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iFrom = atoi(token);
				cReadModeB = 7;
				break;

			case 7:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iMinLevel = atoi(token);
				cReadModeB = 8;
				break;

			case 8:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxLevel = atoi(token);
				cReadModeB = 9;
				break;

			case 9:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillNum = atoi(token);
				cReadModeB = 10;
				break;

			case 10:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillLevel = atoi(token);
				cReadModeB = 11;
				break;

			case 11:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iTimeLimit = atoi(token);
				cReadModeB = 12;
				break;

			case 12:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iAssignType = atoi(token);
				cReadModeB = 13;
				break;

			case 13:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[1] = atoi(token);
				cReadModeB = 14;
				break;

			case 14:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[1] = atoi(token);
				cReadModeB = 15;
				break;

			case 15:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[2] = atoi(token);
				cReadModeB = 16;
				break;

			case 16:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[2] = atoi(token);
				cReadModeB = 17;
				break;

			case 17:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[3] = atoi(token);
				cReadModeB = 18;
				break;

			case 18:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[3] = atoi(token);
				cReadModeB = 19;
				break;

			case 19:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iContribution = atoi(token);
				cReadModeB = 20;
				break;

			case 20:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iContributionLimit = atoi(token);
				cReadModeB = 21;
				break;

			case 21:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iResponseMode = atoi(token);
				cReadModeB = 22;
				break;

			case 22:
				ZeroMemory(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, sizeof(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName));
				strcpy(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, token);
				cReadModeB = 23;
				break;

			case 23:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_sX = atoi(token);
				cReadModeB = 24;
				break;

			case 24:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_sY = atoi(token);
				cReadModeB = 25;
				break;

			case 25:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iRange = atoi(token);
				cReadModeB = 26;
				break;

			case 26:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iQuestID = atoi(token);
				cReadModeB = 27;
				break;

			case 27:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iReqContribution = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "quest", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(ERROR) CRITICAL ERROR! QUEST configuration file contents error!");
		return FALSE;
	}

	//wsprintf(cTxt, "(!) QUEST(Total:%d) configuration - success!", iQuestConfigListIndex);
	//PutLogList(cTxt);

	return TRUE;
}


int CGame::__iSearchForQuest(int iClientH, int iWho, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
	int i, iQuestList[MAXQUESTTYPE], iIndex, iQuest, iReward, iQuestIndex;

	if (m_pClientList[iClientH] == NULL) return -1;

	iIndex = 0;
	for (i = 0; i < MAXQUESTTYPE; i++)
		iQuestList[i] = -1;

	for (i = 1; i < MAXQUESTTYPE; i++) 
		if (m_pQuestConfigList[i] != NULL) {

			if (m_pQuestConfigList[i]->m_iFrom != iWho) continue;
			if (m_pQuestConfigList[i]->m_side != m_pClientList[iClientH]->m_side) continue;
			if (m_pQuestConfigList[i]->m_iMinLevel > m_pClientList[iClientH]->m_iLevel) continue;
			if (m_pQuestConfigList[i]->m_iMaxLevel < m_pClientList[iClientH]->m_iLevel) continue;
			if (m_pQuestConfigList[i]->m_iReqContribution > m_pClientList[iClientH]->m_iContribution) continue;

			if (m_pQuestConfigList[i]->m_iRequiredSkillNum != -1) {
				if (m_pClientList[iClientH]->m_cSkillMastery[m_pQuestConfigList[i]->m_iRequiredSkillNum] < 
					m_pQuestConfigList[i]->m_iRequiredSkillLevel) continue;
			}

			if ((m_bIsCrusadeMode == TRUE) && (m_pQuestConfigList[i]->m_iAssignType != 1)) continue;
			if ((m_bIsCrusadeMode == FALSE) && (m_pQuestConfigList[i]->m_iAssignType == 1)) continue;

			if (m_pQuestConfigList[i]->m_iContributionLimit < m_pClientList[iClientH]->m_iContribution) continue;

			iQuestList[iIndex] = i;
			iIndex++;
		}


	if (iIndex == 0) return -1;
	iQuest		 = (dice(1, iIndex)) - 1;
	iQuestIndex  = iQuestList[iQuest];

	iReward = dice(1,3);
	*pMode = m_pQuestConfigList[iQuestIndex]->m_iResponseMode;
	*pRewardType   = m_pQuestConfigList[iQuestIndex]->m_iRewardType[iReward];
	*pRewardAmount = m_pQuestConfigList[iQuestIndex]->m_iRewardAmount[iReward];
	*pContribution = m_pQuestConfigList[iQuestIndex]->m_iContribution;

	strcpy(pTargetName, m_pQuestConfigList[iQuestIndex]->m_cTargetName);
	*pX     = m_pQuestConfigList[iQuestIndex]->m_sX;
	*pY     = m_pQuestConfigList[iQuestIndex]->m_sY;
	*pRange = m_pQuestConfigList[iQuestIndex]->m_iRange;

	*pTargetType  = m_pQuestConfigList[iQuestIndex]->m_iTargetType;
	*pTargetCount = m_pQuestConfigList[iQuestIndex]->m_iMaxCount;
	*pQuestType   = m_pQuestConfigList[iQuestIndex]->m_iType;

	return iQuestIndex;
}


void CGame::QuestAcceptedHandler(int iClientH)
{
	int iIndex;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iAssignType == 1) {
		switch (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iType) {
		case 10: 			
			_ClearQuestStatus(iClientH);
			RequestTeleportHandler(iClientH, 2, m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_cTargetName,
				m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sX, m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sY);
			return;
		}
	}

	m_pClientList[iClientH]->m_iQuest = m_pClientList[iClientH]->m_iAskedQuest;
	iIndex = m_pClientList[iClientH]->m_iQuest;
	m_pClientList[iClientH]->m_iQuestID = m_pQuestConfigList[iIndex]->m_iQuestID;
	m_pClientList[iClientH]->m_iCurQuestCount    = 0;
	m_pClientList[iClientH]->m_bIsQuestCompleted = FALSE;

	_CheckQuestEnvironment(iClientH);
	_SendQuestContents(iClientH);
}


void CGame::_SendQuestContents(int iClientH)
{
	int iWho, iIndex, iQuestType, iContribution, iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted, cQuestRemain;
	char cTargetName[21];

	if (m_pClientList[iClientH] == NULL) return;

	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == NULL) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTCONTENTS, NULL, NULL, NULL, NULL,  
			NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	}
	else {
		if (m_pQuestConfigList[iIndex] == NULL) return ;

		iWho          = m_pQuestConfigList[iIndex]->m_iFrom;
		iQuestType    = m_pQuestConfigList[iIndex]->m_iType;
		iContribution = m_pQuestConfigList[iIndex]->m_iContribution;
		iTargetType   = m_pQuestConfigList[iIndex]->m_iTargetType;
		iTargetCount  = m_pQuestConfigList[iIndex]->m_iMaxCount;
		iX            = m_pQuestConfigList[iIndex]->m_sX;
		iY            = m_pQuestConfigList[iIndex]->m_sY;
		iRange        = m_pQuestConfigList[iIndex]->m_iRange;
		ZeroMemory(cTargetName, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
		iQuestCompleted = (int)m_pClientList[iClientH]->m_bIsQuestCompleted;
		SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTCONTENTS, iWho, iQuestType, iContribution, NULL,  
			iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted, cTargetName);

		cQuestRemain = (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iMaxCount - m_pClientList[iClientH]->m_iCurQuestCount);
		SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTCOUNTER, cQuestRemain, NULL, NULL, NULL);

	}
}

void CGame::_CheckQuestEnvironment(int iClientH)
{
	int iIndex;
	char cTargetName[21];

	if (m_pClientList[iClientH] == NULL) return;

	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == NULL) return;


	if (iIndex >= 35 && iIndex <= 40 ){
		m_pClientList[iClientH]->m_iQuest   = NULL;
		m_pClientList[iClientH]->m_iQuestID = NULL;
		m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
		m_pClientList[iClientH]->m_iQuestRewardType   = NULL;

		SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
		return;
	}

	if (m_pQuestConfigList[iIndex] == NULL) return;

	if (m_pQuestConfigList[iIndex]->m_iQuestID != m_pClientList[iClientH]->m_iQuestID) {

		m_pClientList[iClientH]->m_iQuest   = NULL;
		m_pClientList[iClientH]->m_iQuestID = NULL;
		m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
		m_pClientList[iClientH]->m_iQuestRewardType   = NULL;

		SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
		return;
	}

	switch (m_pQuestConfigList[iIndex]->m_iType) {
	case QUESTTYPE_MONSTERHUNT:
	case QUESTTYPE_GOPLACE:
		ZeroMemory(cTargetName, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
		if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, cTargetName, 10) == 0)
			m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = TRUE;
		else m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = FALSE;
		break;
	}
}

bool CGame::_bCheckIsQuestCompleted(int iClientH)
{
	int iQuestIndex;


	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_bIsQuestCompleted == TRUE) return FALSE;
	iQuestIndex = m_pClientList[iClientH]->m_iQuest;
	if (iQuestIndex == NULL) return FALSE;

	if (m_pQuestConfigList[iQuestIndex] != NULL) {
		switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
		case QUESTTYPE_MONSTERHUNT:
			if ( (m_pClientList[iClientH]->m_bQuestMatchFlag_Loc == TRUE) && 
				(m_pClientList[iClientH]->m_iCurQuestCount >= m_pQuestConfigList[iQuestIndex]->m_iMaxCount) ) {
					m_pClientList[iClientH]->m_bIsQuestCompleted = TRUE;
					SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTCOMPLETED, NULL, NULL, NULL, NULL);
					return TRUE;
			}
			break;

		case QUESTTYPE_GOPLACE:
			if ( (m_pClientList[iClientH]->m_bQuestMatchFlag_Loc == TRUE) && 				 
				(m_pClientList[iClientH]->m_sX >= m_pQuestConfigList[iQuestIndex]->m_sX - m_pQuestConfigList[iQuestIndex]->m_iRange) && 
				(m_pClientList[iClientH]->m_sX <= m_pQuestConfigList[iQuestIndex]->m_sX + m_pQuestConfigList[iQuestIndex]->m_iRange) &&
				(m_pClientList[iClientH]->m_sY >= m_pQuestConfigList[iQuestIndex]->m_sY - m_pQuestConfigList[iQuestIndex]->m_iRange) &&
				(m_pClientList[iClientH]->m_sY <= m_pQuestConfigList[iQuestIndex]->m_sY + m_pQuestConfigList[iQuestIndex]->m_iRange) ) {

					m_pClientList[iClientH]->m_bIsQuestCompleted = TRUE;
					SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTCOMPLETED, NULL, NULL, NULL, NULL);
					return TRUE;
			}
			break;
		}
	}

	return FALSE;
}

int CGame::_iTalkToNpcResult_GuildHall(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_GShop(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_BSmith(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_WHouse(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_WTower(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

void CGame::SendItemNotifyMsg(int iClientH, WORD wMsgType, CItem *pItem, int iV1, bool deleteOnError)
{
	char  * cp, cData[512];
	DWORD * dwp;
	WORD  * wp;
	int     iRet;

	if (m_pClientList[iClientH] == NULL) return;

	dwp  = (DWORD *)(cData + INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (WORD *)(cData + INDEX2_MSGTYPE);
	*wp  = wMsgType;
	cp = (char *)(cData + INDEX2_MSGTYPE + 2);

	switch (wMsgType) {
	case NOTIFY_ITEMOBTAINED:
		cp += WriteItemData(cp, pItem);

		*cp = (char)pItem->m_sItemSpecEffectValue2; 
		cp++;

		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(pItem->m_dwAttribute & 0x00000001); 
		cp++;
		*/

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		break;

	case NOTIFY_ITEMPURCHASED:
		cp += WriteItemData(cp, pItem);

		wp  = (WORD *)cp;
		*wp = iV1; // (iCost - iDiscountCost);

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 48);
		break;

	case NOTIFY_CANNOTCARRYMOREITEM:
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		break;
	}

	if (deleteOnError){
		switch (iRet) {
		case XSOCKEVENT_QUENEFULL:
		case XSOCKEVENT_SOCKETERROR:
		case XSOCKEVENT_CRITICALERROR:
		case XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}
}

bool CGame::_bCheckItemReceiveCondition(int iClientH, CItem *pItem)
{
	int i;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	/*
	if ((pItem->m_cItemType == ITEMTYPE_CONSUME) || (pItem->m_cItemType == ITEMTYPE_ARROW)) {
	if ((m_pClientList[iClientH]->m_iCurWeightLoad + (pItem->m_wWeight * pItem->m_dwCount)) > _iCalcMaxLoad(iClientH)) 
	return FALSE;
	}
	else {
	if ((m_pClientList[iClientH]->m_iCurWeightLoad + pItem->m_wWeight) > _iCalcMaxLoad(iClientH)) 
	return FALSE;
	}
	*/
	if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount) > _iCalcMaxLoad(iClientH)) 
		return FALSE;

	for (i = 0; i < MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] == NULL) return TRUE;

	return FALSE;
}

void CGame::_ClearQuestStatus(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	m_pClientList[iClientH]->m_iQuest   = NULL;
	m_pClientList[iClientH]->m_iQuestID = NULL;
	m_pClientList[iClientH]->m_iQuestRewardType   = NULL;
	m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
	m_pClientList[iClientH]->m_bIsQuestCompleted  = FALSE;
}

void CGame::GetMapInitialPoint(int iMapIndex, short *pX, short *pY, char * pPlayerLocation)
{
	int i, iTotalPoint;
	POINT  pList[MAXINITIALPOINT];

	if (m_pMapList[iMapIndex] == NULL) return;

	iTotalPoint = 0;
	for (i = 0; i < MAXINITIALPOINT; i++)
		if (m_pMapList[iMapIndex]->m_pInitialPoint[i].x != -1) {
			pList[iTotalPoint].x = m_pMapList[iMapIndex]->m_pInitialPoint[i].x;
			pList[iTotalPoint].y = m_pMapList[iMapIndex]->m_pInitialPoint[i].y;
			iTotalPoint++;
		}

	if (iTotalPoint == 0) return;

	if ((pPlayerLocation != NULL) && (memcmp(pPlayerLocation, "NONE", 4) == 0)) 
		i = 0;
	else i = dice(1, iTotalPoint) - 1;
	*pX = pList[i].x;
	*pY = pList[i].y;
}



void CGame::_CheckStrategicPointOccupyStatus(char cMapIndex)
{
	class CTile * pTile;
	int i, iX, iY, iSide, iValue;

	m_iStrategicStatus = 0;

	for (i = 0; i < MAXSTRATEGICPOINTS; i++)
		if (m_pMapList[cMapIndex]->m_pStrategicPointList[i] != NULL) {

			iSide  = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iSide;
			iValue = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iValue;
			iX = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iX;
			iY = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iY;

			pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + iX + iY*m_pMapList[cMapIndex]->m_sSizeY);

			m_iStrategicStatus += pTile->m_iOccupyStatus * iValue;
		}
}

void CGame::OnSubLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
	UINT iTmp;
	register int iLogSockH, iRet;

	iTmp = (WM_ONLOGSOCKETEVENT + 1);
	iLogSockH = message - iTmp;

	if (m_pSubLogSock[iLogSockH] == NULL) return;

	iRet = m_pSubLogSock[iLogSockH]->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case XSOCKEVENT_UNSENTDATASENDCOMPLETE:
		//wsprintf(g_cTxt, "(!!!) Log Socket Connection Established Log#(%d) Address:%s  Port:%d", iLogSockH, m_cLogServerAddr, m_iGateServerPort);
		//PutLogList(g_cTxt);

		m_bIsSubLogSockAvailable[iLogSockH] = TRUE;
		if((m_iSubLogSockFailCount + m_iSubLogSockActiveCount) > MAXSUBLOGSOCK && m_iSubLogSockFailCount > 0) m_iSubLogSockFailCount--;
		break;

	case XSOCKEVENT_CONNECTIONESTABLISH:
		//wsprintf(g_cTxt, "(!!!) Sub-log-socket(%d) connected.", iLogSockH);
		//PutLogList(g_cTxt);
		m_iCurSubLogSockIndex = iLogSockH;
		if(!m_bIsGameServerRegistered) bSendMsgToLS(MSGID_REQUEST_REGISTERGAMESERVER, NULL);
		else bSendMsgToLS(MSGID_REQUEST_REGISTERGAMESERVERSOCKET, NULL);
		m_bIsSocketConnected[iLogSockH] = TRUE;
		m_iSubLogSockActiveCount++;
		m_iSubLogSockInitIndex++;
		break;

	case XSOCKEVENT_READCOMPLETE:
		OnSubLogRead(iLogSockH);
		break;

	case XSOCKEVENT_BLOCK:
		wsprintf(g_cTxt, "(ERROR) Sub-log-socket(%d) BLOCKED!", iLogSockH);
		PutLogList(g_cTxt);
		break;

	case XSOCKEVENT_CONFIRMCODENOTMATCH:
	case XSOCKEVENT_MSGSIZETOOLARGE:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		delete m_pSubLogSock[iLogSockH];
		m_pSubLogSock[iLogSockH] = NULL;
		m_bIsSubLogSockAvailable[iLogSockH] = FALSE;

		m_iSubLogSockFailCount++;
		m_iSubLogSockActiveCount--;

		if(m_iSubLogSockActiveCount == 0) m_bIsGameServerRegistered = FALSE;
		wsprintf(g_cTxt, "(ERROR) Sub-log-socket(%d) connection lost!", iLogSockH);
		PutLogList(g_cTxt);
		m_bIsSocketConnected[iLogSockH] = FALSE;
		break;
	}
}





void CGame::OnSubLogRead(int iIndex)
{
	DWORD dwMsgSize;
	char * pData, cKey;

	pData = m_pSubLogSock[iIndex]->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(MSGFROM_LOGSERVER, pData, dwMsgSize, NULL, cKey) == FALSE) {
		PutLogList("(ERROR) CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}
}
#ifdef TAIWANLOG
bool CGame::_bItemLog(int iAction,int iGiveH, int iRecvH, class CItem * pItem,bool bForceItemLog)
{
	char  cTxt[1024], cTemp1[120], cTemp2[120];
	int iItemCount ;
	if (pItem == NULL) return FALSE;


	if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;

	if (iAction == ITEMLOG_DUPITEMID) {

		if (m_pClientList[iGiveH] == NULL) return FALSE;
		if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;
		wsprintf(g_cTxt, "(!) Delete-DupItem(%s %d %d %d %d) Owner(%s)", pItem->m_cName, pItem->m_dwCount, pItem->m_sTouchEffectValue1,
			pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3,
			m_pClientList[iGiveH]->m_cCharName);
		//	PutItemLogFileList(iGiveH,g_cTxt);
		bSendMsgToLS(MSGID_GAMEITEMLOG, iGiveH, NULL,g_cTxt);
		return TRUE;
	}

	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	ZeroMemory(cTemp2, sizeof(cTemp2));

	switch (iAction) {
		case ITEMLOG_EXCHANGE:
			if (m_pClientList[iRecvH]->m_cCharName == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tExchange\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName);
			break;

		case ITEMLOG_GIVE:
			if (m_pClientList[iRecvH]->m_cCharName == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tGive\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName);
			break;

		case ITEMLOG_DROP:
			wsprintf(cTxt, "PC(%s)\tDrop\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case ITEMLOG_GET:
			wsprintf(cTxt, "PC(%s)\tGet\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;
		case ITEMLOG_CREATE:
			wsprintf(cTxt, "PC(%s)\tCreate\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;
		case ITEMLOG_MAKE:
			wsprintf(cTxt, "PC(%s)\tMake\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case ITEMLOG_DEPLETE:
			wsprintf(cTxt, "PC(%s)\tDeplete\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case ITEMLOG_BUY:
			iItemCount = iRecvH ;
			wsprintf(cTxt, "PC(%s)\tBuy\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, iItemCount , 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case ITEMLOG_SELL:
			wsprintf(cTxt, "PC(%s)\tSell\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case ITEMLOG_RETRIEVE:
			wsprintf(cTxt, "PC(%s)\tRetrieve\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case ITEMLOG_DEPOSIT:
			wsprintf(cTxt, "PC(%s)\tDeposit\t%s(%d %d %d %d %x)\t%s(%d %d)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case ITEMLOG_UPGRADEFAIL:
			wsprintf(cTxt, "PC(%s)\tUpgrade Fail\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case ITEMLOG_UPGRADESUCCESS:
			wsprintf(cTxt, "PC(%s)\tUpgrade Success\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;
		default:
			return FALSE ;
	}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iGiveH, NULL,cTxt);
	return TRUE;
}


bool CGame::_bItemLog(int iAction,int iClientH , char * cName, class CItem * pItem)
{
	char  cTxt[200];

	ZeroMemory(cTxt, sizeof(cTxt));

	switch (iAction) {

		case ITEMLOG_APPLY:
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"PC(%s)\tApply\t(%s)\t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cLocation,
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break ;

		case ITEMLOG_CLOSECONN:
			if (cName == NULL) return FALSE;
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"PC(%s)\tKicked\t \t%s(%d %d)\tGM(%s)",m_pClientList[iClientH]->m_cCharName, 
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY,cName);
			break ;

		case ITEMLOG_CREATEGUILD:
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tCreate Guild\t(%s)", m_pClientList[iClientH]->m_cCharName,m_pClientList[iClientH]->m_cGuildName );
			break ;


		case ITEMLOG_GUILDDISMISS: // guild 
			if (cName == NULL) return FALSE;
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tGuild Dismiss\t(%s)", m_pClientList[iClientH]->m_cCharName,cName );
			break ;

		case ITEMLOG_BANGUILD:
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"PC(%s)\tRemove\t(%s)\t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cGuildName,
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break ;

		case ITEMLOG_JOINGUILD:
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"PC(%s)\tJoin\t(%s)\t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cGuildName,
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break ;

		case ITEMLOG_REPAIR:
			if (cName == NULL) return FALSE;
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"PC(%s)\tRepair\t(%s)\t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, cName,
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break; 

		case ITEMLOG_RESERVEFIGZONE:
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"PC(%s)\tReserve\t(%s)\t%s(%d %d)\t(%d)",m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cGuildName,
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_iFightzoneNumber);
			break ;

		case ITEMLOG_SKILLLEARN:
		case ITEMLOG_MAGICLEARN:
			if (cName == NULL) return FALSE; 
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tLearn\t(%s)\t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, cName,
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break; 

		case ITEMLOG_SPELLFIELD:
			if (cName == NULL) return FALSE; 
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tSpell\t(%s)\t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, cName,
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break; 

		case ITEMLOG_SUMMONMONSTER:
			if (cName == NULL) return FALSE;
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"PC(%s)\tSummon\t(%s)\t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, cName,
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break ;
		case ITEMLOG_SUMMONPLAYER:
			if (cName == NULL) return FALSE;
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"PC(%s)\tSummoned\t \t%s(%d %d)\tGM(%s)",m_pClientList[iClientH]->m_cCharName,
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY ,cName);
			break ;

		case ITEMLOG_SHUTUP:
			if (cName == NULL) return FALSE;
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"PC(%s)\tShut up\t(%d)\t%s(%d %d)\tGM(%s)",m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iTimeLeft_ShutUp/20,
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY,cName);
			break ;

		case ITEMLOG_POISONED:
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt,"PC(%s)\tBe Poisoned\t \t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, 
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break; 

		case ITEMLOG_NEWGENDROP:
			if (pItem == NULL) return FALSE;
			wsprintf(cTxt, "NPC(%s)\tDrop\t%s(%d %d %d %d %x)",cName, pItem->m_cName, pItem->m_dwCount,  
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute) ;
			break;

		default:
			return FALSE;
	}

	bSendMsgToLS(MSGID_GAMEITEMLOG, iClientH, NULL,cTxt);
	return TRUE ;
}




#else  
bool CGame::_bItemLog(int iAction,int iGiveH, int iRecvH, class CItem * pItem,bool bForceItemLog)
{
	if (!pItem || !m_pClientList[iGiveH]->m_cCharName) 
		return FALSE;

	if (!bForceItemLog) {
		if (!pItem->IsLogged() || iAction == ITEMLOG_RETRIEVE) 
			return FALSE;
	}

	char  cTxt[1024], cTemp1[120], cTemp2[120];
	int iItemCount ;

	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	ZeroMemory(cTemp2, sizeof(cTemp2));
	m_pClientList[iGiveH]->m_pXSock->iGetPeerAddress(cTemp1);

	switch (iAction) {
		case ITEMLOG_EXCHANGE:
			if (m_pClientList[iRecvH]->m_cCharName == NULL) return FALSE;
			m_pClientList[iRecvH]->m_pXSock->iGetPeerAddress(cTemp2);
			wsprintf(cTxt, "PC(%s)\tExchange\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)\tIP(%s->%s)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName, cTemp1, cTemp2);
			break;

		case ITEMLOG_GIVE:
			if (m_pClientList[iRecvH]->m_cCharName == NULL) return FALSE;
			m_pClientList[iRecvH]->m_pXSock->iGetPeerAddress(cTemp2);
			wsprintf(cTxt, "PC(%s)\tGive\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)\tIP(%s->%s)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName, cTemp1, cTemp2);
			break;

		case ITEMLOG_DROP:

			wsprintf(cTxt, "PC(%s)\tDrop\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;

		case ITEMLOG_GET:

			wsprintf(cTxt, "PC(%s)\tGet\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;
		case ITEMLOG_MAKE:

			wsprintf(cTxt, "PC(%s)\tMake\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;

		case ITEMLOG_DEPLETE:

			wsprintf(cTxt, "PC(%s)\tDeplete\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;

		case ITEMLOG_BUY:
			iItemCount = iRecvH ;
			wsprintf(cTxt, "PC(%s)\tBuy\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				iItemCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;

		case ITEMLOG_SELL:
			wsprintf(cTxt, "PC(%s)\tSell\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;

		case ITEMLOG_RETRIEVE:
			wsprintf(cTxt, "PC(%s)\tRetrieve\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;

		case ITEMLOG_DEPOSIT:
			wsprintf(cTxt, "PC(%s)\tDeposit\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;
		case ITEMLOG_DUPITEMID:

			wsprintf(cTxt, "PC(%s)\tHaveDupItem\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;
		case ITEMLOG_UPGRADEFAIL:
			wsprintf(cTxt, "PC(%s)\tUpgrade Fail\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;
		case ITEMLOG_UPGRADESUCCESS:
			wsprintf(cTxt, "PC(%s)\tUpgrade Success\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
			break;


		default:
			return FALSE ;
	}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iGiveH, NULL,cTxt);
	return TRUE;
}


bool CGame::_bItemLog(int iAction,int iClientH , char * cName, class CItem * pItem)
{
	if(!pItem || !pItem->IsLogged()) return FALSE;

	if(iAction != ITEMLOG_NEWGENDROP)
	{
		if( m_pClientList[iClientH] == NULL ) return FALSE;
	}
	char  cTxt[200], cTemp1[120];
	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	if( m_pClientList[iClientH] != NULL ) m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp1);

	switch (iAction) {
	case ITEMLOG_NEWGENDROP:
		if (pItem == NULL) return FALSE;
		wsprintf(cTxt, "NPC(%s)\tDrop\t%s(%d %d %d %d)",cName, pItem->m_cName, pItem->m_dwCount,  
			pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3);
		break;
	case ITEMLOG_SKILLLEARN:
	case ITEMLOG_MAGICLEARN:
		if (cName == NULL) return FALSE; 
		if (m_pClientList[iClientH] == NULL) return FALSE;
		wsprintf(cTxt, "PC(%s)\tLearn\t(%s)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, cName,
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break; 
	case ITEMLOG_SUMMONMONSTER:
		if (cName == NULL) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		wsprintf(cTxt,"PC(%s)\tSummon\t(%s)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, cName,
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break ;
	case ITEMLOG_POISONED:
		if (m_pClientList[iClientH] == NULL) return FALSE;
		wsprintf(cTxt,"PC(%s)\tBe Poisoned\t \t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, 
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break; 

	case ITEMLOG_REPAIR:
		if (cName == NULL) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		wsprintf(cTxt,"PC(%s)\tRepair\t(%s)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, cName,
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break; 

	default:
		return FALSE;
	}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iClientH, NULL,cTxt);
	return TRUE ;
}
#endif // #ifdef TAIWANLOG

bool CGame::_bCrusadeLog(int iAction,int iClientH,int iData, char * cName)
{
	char  cTxt[200];

	ZeroMemory(cTxt, sizeof(cTxt));

	switch (iAction) {

		case CRUSADELOG_ENDCRUSADE:
			if (cName == NULL) return FALSE;
			wsprintf(cTxt,"\tEnd Crusade\t%s",cName);
			break;

		case CRUSADELOG_SELECTDUTY :
			if (cName == NULL) return FALSE;
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tSelect Duty\t(%s)\t \t(%s)", m_pClientList[iClientH]->m_cCharName,cName,m_pClientList[iClientH]->m_cGuildName);
			break ;

		case CRUSADELOG_GETEXP :
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tGet Exp\t(%d)\t \t(%s)", m_pClientList[iClientH]->m_cCharName,iData,m_pClientList[iClientH]->m_cGuildName);
			break ;

		case CRUSADELOG_STARTCRUSADE:
			wsprintf(cTxt,"\tStart Crusade");
			break ;

		case CRUSADELOG_APOCALYPSE:
			wsprintf(cTxt,"\tStart Apocalypse");
			break ;
		default:
			return FALSE;
	}

	bSendMsgToLS(MSGID_GAMECRUSADELOG, iClientH, NULL,cTxt);
	return TRUE ;
}


bool CGame::_bPKLog(int iAction,int iAttackerH , int iVictumH, char * pNPC)
{
	char  cTxt[1024], cTemp1[120], cTemp2[120];

	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	ZeroMemory(cTemp2, sizeof(cTemp2));

	if ( m_pClientList[iVictumH] == NULL) return FALSE ;

	switch (iAction) {

		case PKLOG_REDUCECRIMINAL: 
			wsprintf(cTxt, "PC(%s)\tReduce\tCC(%d)\t%s(%d %d)\t", m_pClientList[iVictumH]->m_cCharName, m_pClientList[iVictumH]->m_iPKCount,
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY);
			break; 

		case PKLOG_BYPLAYER:
			if ( m_pClientList[iAttackerH] == NULL) return FALSE ;
			wsprintf(cTxt, "PC(%s)\tKilled by PC\t \t%s(%d %d)\tPC(%s)", m_pClientList[iVictumH]->m_cCharName, 
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,m_pClientList[iAttackerH]->m_cCharName);
			break;
		case PKLOG_BYPK:
			if ( m_pClientList[iAttackerH] == NULL) return FALSE ;
			wsprintf(cTxt, "PC(%s)\tKilled by PK\tCC(%d)\t%s(%d %d)\tPC(%s)", m_pClientList[iVictumH]->m_cCharName, m_pClientList[iAttackerH]->m_iPKCount,
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,m_pClientList[iAttackerH]->m_cCharName);
			break; 
		case PKLOG_BYENERMY:
			if ( m_pClientList[iAttackerH] == NULL) return FALSE ;
			wsprintf(cTxt, "PC(%s)\tKilled by EN\t \t%s(%d %d)\tPC(%s)", m_pClientList[iVictumH]->m_cCharName, 
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,m_pClientList[iAttackerH]->m_cCharName);
			break; 
		case PKLOG_BYNPC:
			if(pNPC==NULL) return FALSE ;
			wsprintf(cTxt, "PC(%s)\tKilled by NPC\t \t%s(%d %d)\tNPC(%s)", m_pClientList[iVictumH]->m_cCharName, 
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,pNPC);
			break; 
		case PKLOG_BYOTHER:
			wsprintf(cTxt, "PC(%s)\tKilled by Other\t \t%s(%d %d)\tUnKnown", m_pClientList[iVictumH]->m_cCharName, 
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY);
			break; 
		default:
			return FALSE;
	}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iVictumH, NULL,cTxt);
	return TRUE ;
}

bool CGame::_bCheckSubLogSocketIndex()
{
	int  iCnt;
	bool bLoopFlag;

	m_iCurSubLogSockIndex++;
	if (m_iCurSubLogSockIndex >= MAXSUBLOGSOCK) m_iCurSubLogSockIndex = 0;

	iCnt = 0;
	bLoopFlag = FALSE;
	while (bLoopFlag == FALSE) {
		if ((m_pSubLogSock[m_iCurSubLogSockIndex] != NULL) && (m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] == TRUE)) 
			bLoopFlag = TRUE;
		else m_iCurSubLogSockIndex++;

		iCnt++;
		if (iCnt >= MAXSUBLOGSOCK) {

			if (m_bOnExitProcess == FALSE) {
				m_cShutDownCode      = 3;
				m_bOnExitProcess     = TRUE;
				m_dwExitProcessTime  = timeGetTime();

				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Log-server connection Lost)!!!");
			}
			return FALSE;
		}
	}

	return TRUE;
}
/*bool CGame::_bCheckSubLogSocketIndex()
{
for(BYTE b = 0; b < MAXSUBLOGSOCK; b++){
if ((m_pSubLogSock[b] != NULL) && (m_bIsSubLogSockAvailable[b] == TRUE)) break; 
if(b >= (MAXSUBLOGSOCK-1)){
if(m_bOnExitProcess == FALSE){
m_cShutDownCode      = 3;
m_bOnExitProcess     = TRUE;
m_dwExitProcessTime  = timeGetTime();
PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by Log-server connection Lost)!!!");
}
return FALSE;
}
}
m_iCurSubLogSockIndex++;
while(1){
if(m_iCurSubLogSockIndex >= MAXSUBLOGSOCK || m_iCurSubLogSockIndex == 0) m_iCurSubLogSockIndex = 1;
if ((m_pSubLogSock[m_iCurSubLogSockIndex] != NULL) && (m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] == TRUE)) break;
else m_iCurSubLogSockIndex++;
}
return TRUE;
}*/

bool CGame::_bDecodeBuildItemConfigFileContents(char *pData, DWORD dwMsgSize)
{
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  i, iIndex = 0;
	
	class CItem * pItem;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
			case 1:

				ZeroMemory(m_pBuildItemList[iIndex]->m_cName, sizeof(m_pBuildItemList[iIndex]->m_cName));
				memcpy(m_pBuildItemList[iIndex]->m_cName, token, strlen(token));

				cReadModeB = 2;
				break;

			case 2:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format(1).");
					delete[] pContents;
					return FALSE;
				}

				m_pBuildItemList[iIndex]->m_iSkillLimit = atoi(token);
				cReadModeB = 3;
				break;

			case 3:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemID[0] = atoi(token);
				cReadModeB = 4;
				break;

			case 4:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemCount[0] = atoi(token);
				cReadModeB = 5;
				break;

			case 5:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemValue[0] = atoi(token);
				cReadModeB = 6;
				break;

			case 6:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemID[1] = atoi(token);
				cReadModeB = 7;
				break;

			case 7:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemCount[1] = atoi(token);
				cReadModeB = 8;
				break;

			case 8:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemValue[1] = atoi(token);
				cReadModeB = 9;
				break;

			case 9:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemID[2] = atoi(token);
				cReadModeB = 10;
				break;

			case 10:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemCount[2] = atoi(token);
				cReadModeB = 11;
				break;

			case 11:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemValue[2] = atoi(token);
				cReadModeB = 12;
				break;


			case 12:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemID[3] = atoi(token);
				cReadModeB = 13;
				break;

			case 13:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemCount[3] = atoi(token);
				cReadModeB = 14;
				break;

			case 14:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemValue[3] = atoi(token);
				cReadModeB = 15;
				break;

			case 15:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemID[4] = atoi(token);
				cReadModeB = 16;
				break;

			case 16:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pBuildItemList[iIndex]->m_iMaterialItemCount[4] = atoi(token);

				cReadModeB = 17;
				break;

			case 17:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemValue[4] = atoi(token);

				cReadModeB = 18;
				break;


			case 18:
				// 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemID[5] = atoi(token);
				cReadModeB = 19;
				break;

			case 19:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pBuildItemList[iIndex]->m_iMaterialItemCount[5] = atoi(token);

				cReadModeB = 20;
				break;

			case 20:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemValue[5] = atoi(token);

				cReadModeB = 21;
				break;



			case 21:
				// m_iAverageValue
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				m_pBuildItemList[iIndex]->m_iAverageValue = atoi(token);

				cReadModeB = 22;
				break;

			case 22:
				// m_iMaxSkill
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				m_pBuildItemList[iIndex]->m_iMaxSkill = atoi(token);

				cReadModeB = 23;
				break;

			case 23:
				// m_wAttribute
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				m_pBuildItemList[iIndex]->m_wAttribute = atoi(token);

				cReadModeA = 0;
				cReadModeB = 0;

				pItem = new class CItem;
				if (_bInitItemAttr(pItem, m_pBuildItemList[iIndex]->m_cName) == TRUE) {

					m_pBuildItemList[iIndex]->m_sItemID = pItem->m_sIDnum;


					for (i = 0; i < 6; i++)
						m_pBuildItemList[iIndex]->m_iMaxValue += (m_pBuildItemList[iIndex]->m_iMaterialItemValue[i]*100);

					iIndex++;
				}
				else {
					wsprintf(g_cTxt, "(!!!) CRITICAL ERROR! BuildItem configuration file error - Not Existing Item(%s)", m_pBuildItemList[iIndex]->m_cName);
					PutLogList(g_cTxt);

					delete m_pBuildItemList[iIndex];
					m_pBuildItemList[iIndex] = NULL;

					delete[] pContents;
					return FALSE;
				}
				delete pItem;
				break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "BuildItem", 9) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
				m_pBuildItemList[iIndex] = new class CBuildItem;
			}

		}
		token = pStrTok->pGet();
	}

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(ERROR) CRITICAL ERROR! BuildItem configuration file contents error!");
		return FALSE;
	}

	//wsprintf(cTxt, "(!) BuildItem(Total:%d) configuration - success!", iIndex);
	//PutLogList(cTxt);

	return TRUE;
}

void CGame::BuildItemHandler(int iClientH, char *pData)
{
	char * cp, cName[21], cElementItemID[6];
	int    i, x, z, iMatch, iCount, iPlayerSkillLevel, iResult, iTotalValue, iResultValue, iTemp, iItemCount[MAXITEMS];
	class  CItem * pItem;
	bool   bFlag, bItemFlag[6];
	double dV1, dV2, dV3;
	DWORD  dwTemp, dwTemp2;
	WORD   wTemp;

	if (m_pClientList[iClientH] == NULL) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	cp = (char *)(pData + 11);
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	ZeroMemory(cElementItemID, sizeof(cElementItemID));
	cElementItemID[0] = *cp;
	cp++;
	cElementItemID[1] = *cp;
	cp++;
	cElementItemID[2] = *cp;
	cp++;
	cElementItemID[3] = *cp;
	cp++;
	cElementItemID[4] = *cp;
	cp++;
	cElementItemID[5] = *cp;
	cp++;

	bFlag = TRUE;
	while (bFlag == TRUE) {
		bFlag = FALSE;
		for (i = 0; i <= 4; i++) 
			if ((cElementItemID[i] == -1) && (cElementItemID[i+1] != -1)) {
				cElementItemID[i] = cElementItemID[i+1];
				cElementItemID[i+1] = -1;
				bFlag = TRUE;
			}
	}

	for (i = 0; i < 6; i++) bItemFlag[i] = FALSE;

	iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[SKILL_MANUFACTURING];
	iResult = dice(1, 100);

	if (iResult > iPlayerSkillLevel) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
		return;
	}

	for (i = 0; i < 6; i++)
		if (cElementItemID[i] != -1) {
			if ((cElementItemID[i] < 0) || (cElementItemID[i] > MAXITEMS)) return;
			if (m_pClientList[iClientH]->m_pItemList[cElementItemID[i]] == NULL) return;
		}

		for (i = 0; i < MAXBUILDITEMS; i++)
			if (m_pBuildItemList[i] != NULL) {
				if (memcmp(m_pBuildItemList[i]->m_cName, cName, 20) == 0) {


					if (m_pBuildItemList[i]->m_iSkillLimit > m_pClientList[iClientH]->m_cSkillMastery[SKILL_MANUFACTURING]) return;

					for (x = 0; x < MAXITEMS; x++) 
						if (m_pClientList[iClientH]->m_pItemList[x] != NULL) 
							iItemCount[x] = m_pClientList[iClientH]->m_pItemList[x]->m_dwCount;
						else iItemCount[x] = 0;

						iMatch = 0;
						iTotalValue = 0;

						for (x = 0; x < 6; x++) {
							if (m_pBuildItemList[i]->m_iMaterialItemCount[x] == 0) {
								iMatch++;
							}
							else {
								for (z = 0; z < 6; z++) 
									if ((cElementItemID[z] != -1) && (bItemFlag[z] == FALSE)) {

										if ((m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sIDnum  == m_pBuildItemList[i]->m_iMaterialItemID[x]) &&
											(m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_dwCount >= m_pBuildItemList[i]->m_iMaterialItemCount[x]) &&
											(iItemCount[cElementItemID[z]] > 0)) {
												iTemp = m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sItemSpecEffectValue2;
												if (iTemp > m_pClientList[iClientH]->m_cSkillMastery[SKILL_MANUFACTURING]) {
													iTemp = iTemp - (iTemp - m_pClientList[iClientH]->m_cSkillMastery[SKILL_MANUFACTURING])/2;
												}

												iTotalValue += (iTemp * m_pBuildItemList[i]->m_iMaterialItemValue[x]);
												iItemCount[cElementItemID[z]] -= m_pBuildItemList[i]->m_iMaterialItemCount[x];
												iMatch++;
												bItemFlag[z] = TRUE;

												goto BIH_LOOPBREAK;
										}
									}
BIH_LOOPBREAK:;
							}
						}

						if (iMatch != 6) {
							SendNotifyMsg(NULL, iClientH, NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
							return;
						}

						dV2 = (double)m_pBuildItemList[i]->m_iMaxValue;
						if (iTotalValue <= 0) 
							dV3 = 1.0f;
						else dV3 = (double)iTotalValue;
						dV1 = (double)(dV3/dV2)*100.0f;

						iTotalValue = (int)dV1;


						pItem = new class CItem;
						if (_bInitItemAttr(pItem, m_pBuildItemList[i]->m_cName) == FALSE) {
							delete pItem;
							return;
						}

						dwTemp = pItem->m_dwAttribute;
						dwTemp = dwTemp & 0xFFFFFFFE;
						dwTemp = dwTemp | 0x00000001;
						pItem->m_dwAttribute = dwTemp;

						if (pItem->m_cItemType == ITEMTYPE_MATERIAL) {
							iTemp = dice(1, (iPlayerSkillLevel/2)+1) -1;
							pItem->m_sItemSpecEffectValue2 = (iPlayerSkillLevel/2) + iTemp;

							pItem->m_sTouchEffectType   = ITET_ID;
							pItem->m_sTouchEffectValue1 = dice(1,100000);
							pItem->m_sTouchEffectValue2 = dice(1,100000);
							pItem->m_sTouchEffectValue3 = timeGetTime();

						}
						else {

							dwTemp = pItem->m_dwAttribute;
							dwTemp = dwTemp & 0x0000FFFF;

							dwTemp2 = (WORD)m_pBuildItemList[i]->m_wAttribute;
							dwTemp2 = dwTemp2 << 16;

							dwTemp  = dwTemp | dwTemp2;
							pItem->m_dwAttribute = dwTemp;

							iResultValue = (iTotalValue - m_pBuildItemList[i]->m_iAverageValue);



							if (iResultValue > 0) {
								dV2 = (double)iResultValue;
								dV3 = (double)(100 - m_pBuildItemList[i]->m_iAverageValue);
								dV1 = (dV2/dV3)*100.0f;
								pItem->m_sItemSpecEffectValue2 = (int)dV1;
							}
							else if (iResultValue < 0) {
								dV2 = (double)(iResultValue);
								dV3 = (double)(m_pBuildItemList[i]->m_iAverageValue);
								dV1 = (dV2/dV3)*100.0f;
								pItem->m_sItemSpecEffectValue2 = (int)dV1;
							}
							else pItem->m_sItemSpecEffectValue2 = 0;


							dV2 = (double)pItem->m_sItemSpecEffectValue2;
							dV3 = (double)pItem->m_wMaxLifeSpan;
							dV1 = (dV2/100.0f)*dV3;

							iTemp  = (int)pItem->m_wMaxLifeSpan;
							iTemp += (int)dV1;


							pItem->m_sTouchEffectType   = ITET_ID;
							pItem->m_sTouchEffectValue1 = dice(1,100000);
							pItem->m_sTouchEffectValue2 = dice(1,100000);
							pItem->m_sTouchEffectValue3 = timeGetTime();

							if (iTemp <= 0) 
								wTemp = 1;
							else wTemp = (WORD)iTemp;

							if (wTemp <= pItem->m_wMaxLifeSpan*2) {
								pItem->m_wMaxLifeSpan = wTemp;
								pItem->m_sItemSpecEffectValue1 = (short)wTemp;
								pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
							}
							else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;


							pItem->m_cItemColor = 2;
						}

						bAddItem(iClientH, pItem);
						SendNotifyMsg(NULL, iClientH, NOTIFY_BUILDITEMSUCCESS, pItem->m_sItemSpecEffectValue2, pItem->m_cItemType, NULL, NULL); 

#ifdef TAIWANLOG

						_bItemLog(ITEMLOG_MAKE, iClientH, (int) -1, pItem);
#endif

						for (x = 0; x < 6; x++)
							if (cElementItemID[x] != -1) {
								if (m_pClientList[iClientH]->m_pItemList[cElementItemID[x]] == NULL) {
									// ### BUG POINT!!!
									wsprintf(g_cTxt, "(?) Char(%s) ElementItemID(%d)", m_pClientList[iClientH]->m_cCharName, cElementItemID[x]);
									PutLogFileList(g_cTxt);
								}
								else {
									iCount = m_pClientList[iClientH]->m_pItemList[cElementItemID[x]]->m_dwCount - m_pBuildItemList[i]->m_iMaterialItemCount[x];
									if (iCount < 0) iCount = 0;
									SetItemCount(iClientH, cElementItemID[x], iCount);
								}
							}

							if (m_pBuildItemList[i]->m_iMaxSkill > m_pClientList[iClientH]->m_cSkillMastery[SKILL_MANUFACTURING])
								CalculateSSN_SkillIndex(iClientH, SKILL_MANUFACTURING, 1);


							GetExp(iClientH, dice(2, (m_pBuildItemList[i]->m_iSkillLimit/4))); //m_pClientList[iClientH]->m_iExpStock += dice(1, (m_pBuildItemList[i]->m_iSkillLimit/4));

							return;
				}
			}

			/*
			for (i = 0; i < MAXBUILDITEMS; i++)
			if (m_pBuildItemList[i] != NULL) {
			if (memcmp(m_pBuildItemList[i]->m_cName, cName, 20) == 0) {

			if (m_pBuildItemList[i]->m_iSkillLimit > m_pClientList[iClientH]->m_cSkillMastery[SKILL_MANUFACTURING]) return;

			iMatch = 0;


			for (x = 0; x < 6; x++) m_pBuildItemList[i]->m_iIndex[x] = -1;
			for (x = 0; x < MAXITEMS; x++) bItemFlag[x] = FALSE;


			iTotalValue = 0;
			for (x = 0; x < 6; x++) 
			if (m_pBuildItemList[i]->m_iMaterialItemCount[x] == 0) iMatch++; 
			else {
			bFlag = FALSE;
			for (z = 0; z < MAXITEMS; z++)
			if (m_pClientList[iClientH]->m_pItemList[z] != NULL) {
			if ((m_pClientList[iClientH]->m_pItemList[z]->m_sIDnum  == m_pBuildItemList[i]->m_iMaterialItemID[x]) &&
			(m_pClientList[iClientH]->m_pItemList[z]->m_dwCount >= m_pBuildItemList[i]->m_iMaterialItemCount[x]) &&
			(bItemFlag[z] == FALSE)) {

			m_pBuildItemList[i]->m_iIndex[x] = z;
			bItemFlag[z] = TRUE;
			iTotalValue += (m_pClientList[iClientH]->m_pItemList[z]->m_sItemSpecEffectValue1 * m_pBuildItemList[i]->m_iMaterialItemValue[x]);

			bFlag = TRUE;
			goto BIH_LOOPBREAK;
			}
			}

			BIH_LOOPBREAK:;

			if (bFlag == TRUE) iMatch++;
			}

			if (iMatch != 6) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
			return;
			}

			dV2 = (double)m_pBuildItemList[i]->m_iMaxValue;
			if (iTotalValue <= 0) 
			dV3 = 1.0f;
			else dV3 = (double)iTotalValue;
			dV1 = (double)(dV3/dV2)*100.0f;

			iTotalValue = (int)dV1;


			for (x = 0; x < 6; x++)
			if (m_pBuildItemList[i]->m_iIndex[x] != -1) {
			iIndex = m_pBuildItemList[i]->m_iIndex[x];
			iCount = m_pClientList[iClientH]->m_pItemList[iIndex]->m_dwCount - m_pBuildItemList[i]->m_iMaterialItemCount[x];
			if (iCount < 0) iCount = 0;
			SetItemCount(iClientH, iIndex, iCount);
			}


			pItem = new class CItem;
			if (_bInitItemAttr(pItem, m_pBuildItemList[i]->m_cName) == FALSE) {
			delete pItem;
			return;
			}

			if (pItem->m_cItemType == ITEMTYPE_MATERIAL) {
			pItem->m_sItemSpecEffectValue1 = dice(1, iPlayerSkillLevel);

			if (pItem->m_sItemSpecEffectValue1 < (iPlayerSkillLevel/2))
			pItem->m_sItemSpecEffectValue1 = (iPlayerSkillLevel/2);
			}
			else {


			dwTemp = pItem->m_dwAttribute;
			dwTemp = dwTemp | 0x00000001;
			pItem->m_dwAttribute = dwTemp;

			iResultValue = (iTotalValue - m_pBuildItemList[i]->m_iAverageValue);


			if (iResultValue == 0) 
			dV2 = 1.0f;
			else dV2 = (double)iResultValue;
			dV3 = (double)pItem->m_wMaxLifeSpan;
			dV1 = (dV2/100.0f)*dV3;

			iTemp  = (int)pItem->m_wMaxLifeSpan;
			iTemp += (int)dV1;

			if (iTemp <= 0) 
			wTemp = 1;
			else wTemp = (WORD)iTemp;

			if (wTemp <= pItem->m_wMaxLifeSpan*2) {
			pItem->m_wMaxLifeSpan = wTemp;
			pItem->m_wCurLifeSpan = wTemp;
			pItem->m_sItemSpecEffectValue1 = (short)wTemp;
			}
			else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;


			if (iResultValue > 0) {
			dV2 = (double)iResultValue;
			dV3 = (double)(100 - m_pBuildItemList[i]->m_iAverageValue);
			dV1 = (dV2/dV3)*100.0f;
			pItem->m_sItemSpecEffectValue2 = (int)dV1;
			}
			else if (iResultValue < 0) {
			dV2 = (double)abs(iResultValue);
			dV3 = (double)(m_pBuildItemList[i]->m_iAverageValue);
			dV1 = (dV2/dV3)*100.0f;
			pItem->m_sItemSpecEffectValue2 = -1*abs(100 - (int)dV1);
			}
			else pItem->m_sItemSpecEffectValue2 = 0;
			}

			//testcode
			wsprintf(g_cTxt, "Custom-Item(%s) Value(%d)", pItem->m_cName, pItem->m_sItemSpecEffectValue2);
			PutLogList(g_cTxt);


			bAddItem(iClientH, pItem, NULL);
			SendNotifyMsg(NULL, iClientH, NOTIFY_BUILDITEMSUCCESS, NULL, NULL, NULL, NULL);
			}
			}

			*/
}

void CGame::AdminOrder_EventSpell(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cMagicName[31]; 
	int    i, unused, magicID;
	bool disabling = false, toggling = false;
	CMagic * spell;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 12) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)	return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) return;
	ZeroMemory(cMagicName, sizeof(cMagicName));
	memcpy(cMagicName, token, 30);

	token = pStrTok->pGet();
	if (token != NULL){
		if (token[0] == '1') disabling = FALSE;
		else if(token[0] == '0') disabling = TRUE;
	} 
	else {
		toggling = true;
	}
		
	magicID = _iGetMagicNumber(cMagicName, &unused, &unused);
	if (magicID > -1) {
		spell = g_magicConfigList[magicID];
		bool *magicLimited = &(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_magicLimited[magicID]);
		if (toggling){
			*magicLimited = !(*magicLimited);
		} else {
			*magicLimited = disabling;
		}
		for (i = 1; i < MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) {
				if(*magicLimited && !m_pClientList[i]->IsGM() && m_pClientList[i]->m_cMagicEffectStatus[spell->m_sType] == spell->m_sValue[MAGICV_TYPE]){
					m_pClientList[i]->RemoveMagicEffect(spell->m_sType);
				}
				SendNotifyMsg(NULL, i, NOTIFY_EVENTSPELL, *magicLimited, magicID, NULL, NULL, NULL);
			}
		}
	}
}

void CGame::AdminOrder_EventArmor(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	int    i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)	return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		if (token[0] == '1'){
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isArmorDisabled = FALSE;
		}else if (token[0] == '0'){
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isArmorDisabled = TRUE;
		}
	} 
	else {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isArmorDisabled = !m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isArmorDisabled;
	}

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isArmorDisabled == FALSE) { //Enable armor use
		for (i = 1; i < MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) {
				SendNotifyMsg(NULL, i, NOTIFY_EVENTARMOR, FALSE, NULL, NULL, NULL, NULL);
			}
		}
	}
	else //Disable armor use
	{
		for (i = 1; i < MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) {
				if(!m_pClientList[i]->IsGM() && !m_pClientList[i]->IsDead()){
					if ( m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_HEAD ] != -1){
						SendNotifyMsg(NULL, i, NOTIFY_ITEMRELEASED, EQUIPPOS_HEAD, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_HEAD ], NULL, NULL);
						ReleaseItemHandler(i, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_HEAD ], FALSE);
					}
					if ( m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_BODY ] != -1) {
						SendNotifyMsg(NULL, i, NOTIFY_ITEMRELEASED, EQUIPPOS_BODY, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_BODY ], NULL, NULL);
						ReleaseItemHandler(i, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_BODY ], FALSE);
					}
					if ( m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_ARMS ] != -1) {
						SendNotifyMsg(NULL, i, NOTIFY_ITEMRELEASED, EQUIPPOS_ARMS, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_ARMS ], NULL, NULL);
						ReleaseItemHandler(i, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_ARMS ], FALSE);
					}
					if ( m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_LEGGINGS ] != -1) {
						SendNotifyMsg(NULL, i, NOTIFY_ITEMRELEASED, EQUIPPOS_LEGGINGS, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_LEGGINGS ], NULL, NULL);
						ReleaseItemHandler(i, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_LEGGINGS ], FALSE);
					}
					if ( m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_PANTS ] != -1) {
						SendNotifyMsg(NULL, i, NOTIFY_ITEMRELEASED, EQUIPPOS_PANTS, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_PANTS ], NULL, NULL);
						ReleaseItemHandler(i, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_PANTS ], FALSE);
					}
					/*if ( m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_BACK ] != -1) {
						SendNotifyMsg(NULL, i, NOTIFY_ITEMRELEASED, EQUIPPOS_BACK, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_BACK ], NULL, NULL);
						ReleaseItemHandler(i, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_BACK ], FALSE);
						
					}*/ 
					SendEventToNearClient_TypeA(i, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTNULLACTION, NULL, NULL, NULL);
				}
				SendNotifyMsg(NULL, i, NOTIFY_EVENTARMOR, TRUE, NULL, NULL, NULL, NULL);
			}
		}
	}
}

void CGame::AdminOrder_EventSheild(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	int    i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)	return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		if (token[0] == '1'){
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isShieldDisabled = FALSE;
		}else if (token[0] == '0'){
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isShieldDisabled = TRUE;
		}
	} 
	else {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isShieldDisabled = !m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isShieldDisabled;
	}

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isShieldDisabled == FALSE) { //Enable shield use
		for (i = 1; i < MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) {
				SendNotifyMsg(NULL, i, NOTIFY_EVENTSHIELD, FALSE, NULL, NULL, NULL, NULL);
			}
		}
	}
	else //Disable shield
	{
		for (i = 1; i < MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) {
				if (!m_pClientList[i]->IsGM() && !m_pClientList[i]->IsDead() && m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_LHAND ] != -1){
					SendNotifyMsg(NULL, i, NOTIFY_ITEMRELEASED, EQUIPPOS_LHAND, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_LHAND ], NULL, NULL);
					ReleaseItemHandler(i, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_LHAND ], TRUE);
				}
				SendNotifyMsg(NULL, i, NOTIFY_EVENTSHIELD, TRUE, NULL, NULL, NULL, NULL);
			}
		}
	}
}

void CGame::AdminOrder_EventChat(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	int    i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)	return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		if (token[0] == '1'){
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isChatDisabled = FALSE;
		}else if (token[0] == '0'){
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isChatDisabled = TRUE;
		}
	} 
	else {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isChatDisabled = !m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isChatDisabled;
	}

	for (i = 1; i < MAXCLIENTS; i++) {
		if(m_pClientList[i] != NULL && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)
			SendNotifyMsg(NULL, i, NOTIFY_EVENTCHAT, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isChatDisabled, NULL, NULL, NULL, NULL);
	}
}

void CGame::AdminOrder_EventParty(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	int    i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)	return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		if (token[0] == '1'){
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPartyDisabled = FALSE;
		}else if (token[0] == '0'){
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPartyDisabled = TRUE;
		}
	} 
	else {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPartyDisabled = !m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPartyDisabled;
	}


	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPartyDisabled == FALSE) { //Enable
		for (i = 1; i < MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) {
				SendNotifyMsg(NULL, i, NOTIFY_EVENTPARTY, FALSE, NULL, NULL, NULL, NULL);
			}
		}
	}
	else //Disable
	{
		for (i = 1; i < MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) {
				if (!m_pClientList[i]->IsGM() && m_pClientList[i]->m_iPartyID != NULL){
					RequestDismissPartyHandler(i);
				}
				SendNotifyMsg(NULL, i, NOTIFY_EVENTPARTY, TRUE, NULL, NULL, NULL, NULL);
			}
		}
	}
}


void CGame::AdminOrder_EventReset(int iClientH)
{
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)	return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	for(i = 0; i < MAXMAGICTYPE; i++)
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_magicLimited[i] = false;

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPartyDisabled = false;
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isShieldDisabled = false;
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isArmorDisabled = false;
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isChatDisabled = false;
	
	for (i = 1; i < MAXCLIENTS; i++) {
		if (m_pClientList[i] != NULL && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) {
			if(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPermIllusionOn) m_pClientList[i]->RemoveMagicEffect(MAGICTYPE_CONFUSE);
			SendNotifyMsg(NULL, i, NOTIFY_EVENTRESET, NULL, NULL, NULL, NULL, NULL);
		}
	}

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPermIllusionOn = false;
}

void CGame::AdminOrder_EventTP(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	int    i, j;
	bool   enabling = TRUE;


	if (m_pClientList[iClientH] == NULL) return;
	if (dwMsgSize <= 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)	return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		if (token[0] == '1'){
			enabling = TRUE;
		}else if (token[0] == '0'){
			enabling = FALSE;
		}
	} 
	else {
		for(i = 0; i < MAXTELEPORTLIST; i++)
			if(m_pTeleportConfigList[i] != NULL && m_pTeleportConfigList[i]->m_adminCreated == TRUE 
				&& strcmp(m_pTeleportConfigList[i]->m_cTargetMap, m_pClientList[iClientH]->m_cMapName) == 0)
					enabling = FALSE;
	}

	if (enabling) { //Enable teleports
		for(j = 1; j < MAXSIDES; j++){
			for(i = 0; i < MAXTELEPORTLIST; i++)
			{
				if(m_pTeleportConfigList[i] == NULL)
				{ 
					m_pTeleportConfigList[i] = new class CTeleport;
					m_pTeleportConfigList[i]->m_bNetural = FALSE;
					strcpy(m_pTeleportConfigList[i]->m_cNpcname, "William");
					wsprintf(m_pTeleportConfigList[i]->m_cSourceMap, "cityhall_%d", j);
					strcpy(m_pTeleportConfigList[i]->m_cTargetMap,m_pClientList[iClientH]->m_cMapName);
					m_pTeleportConfigList[i]->m_iX = -1;
					m_pTeleportConfigList[i]->m_iY = -1;
					m_pTeleportConfigList[i]->m_iSide = j;
					m_pTeleportConfigList[i]->m_iMinLvl = 0;
					m_pTeleportConfigList[i]->m_iMaxLvl = MAXLEVEL;	
					m_pTeleportConfigList[i]->m_adminCreated = TRUE;
					break;
				}
			}
		}
		for(i = 1; i < MAXCLIENTS; i++)
			SendNotifyMsg(NULL, i, NOTIFY_EVENTTP, 1, NULL, NULL, NULL);
	}
	else //Disable teleports
	{
		for(j = 1; j < MAXSIDES; j++){
			for(i = 0; i < MAXTELEPORTLIST; i++)
			{
				if(m_pTeleportConfigList[i] != NULL && m_pTeleportConfigList[i]->m_adminCreated == TRUE 
					&& strcmp(m_pTeleportConfigList[i]->m_cTargetMap, m_pClientList[iClientH]->m_cMapName) == 0){
					delete m_pTeleportConfigList[i];
					m_pTeleportConfigList[i] = NULL;
					break;
				}
			}
		}
		for(i = 1; i < MAXCLIENTS; i++)
			SendNotifyMsg(NULL, i, NOTIFY_EVENTTP, 0, NULL, NULL, NULL);
	}
}

void CGame::AdminOrder_EventIllusion(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	int    i;

	if (m_pClientList[iClientH] == NULL) return;
	if (dwMsgSize <= 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)	return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		if (token[0] == '1'){
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPermIllusionOn = TRUE;
		}else if (token[0] == '0'){
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPermIllusionOn = FALSE;
		}
	} 
	else {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPermIllusionOn = !m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPermIllusionOn;
	}


	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPermIllusionOn) { //Enable permanent illusion
		for (i = 1; i < MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex){
				if(!m_pClientList[i]->IsGM()){
					m_pClientList[i]->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ] = 3; //Illusion
					//m_pClientList[i]->SetStatusFlag(STATUS_ILLUSION, TRUE);
					SendNotifyMsg(NULL, i, NOTIFY_MAGICEFFECTON, MAGICTYPE_CONFUSE, 3, iClientH, NULL);
				}
				SendNotifyMsg(NULL, i, NOTIFY_EVENTILLUSION, TRUE, NULL, NULL, NULL, NULL);
			}
		}
	}
	else // Disable permanent illusion
	{
		for (i = 1; i < MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex){
				if(!m_pClientList[i]->IsGM())
					m_pClientList[i]->RemoveMagicEffect(MAGICTYPE_CONFUSE);

				SendNotifyMsg(NULL, i, NOTIFY_EVENTILLUSION, FALSE, NULL, NULL, NULL, NULL);
			}
		}
	}
}


void CGame::AdminOrder_SetAttackMode(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	int    i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;


	if ( memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 4) != 0 ) {
		return;
	}

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();


	if (token != NULL) {
		if (token[0] == '1') {
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled = TRUE;

			for (i = 1; i < MAXCLIENTS; i++) 
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)) 
					SendNotifyMsg(NULL, i, NOTIFY_GLOBALATTACKMODE, (int)m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled, NULL, NULL, NULL);
		}
		else if (token[0] == '0') {
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled = FALSE;


			for (i = 1; i < MAXCLIENTS; i++) 
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)) 
					SendNotifyMsg(NULL, i, NOTIFY_GLOBALATTACKMODE, (int)m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled, NULL, NULL, NULL);
		}
	}

}

void CGame::AdminOrder_ToggleInvincible(int iClientH)
{
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 4)	return;

	m_pClientList[iClientH]->m_GMFlags ^= GMFLAG_INVENCIBLE;
}

void CGame::AdminOrder_ToggleNoAggro(int iClientH)
{
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 4)	return;

	m_pClientList[iClientH]->m_GMFlags ^= GMFLAG_NOAGGRO;
}


void CGame::AdminOrder_SetForceRecallTime(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256],* cp; 
	WORD * wp ;
	int    iTime;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {

		if (token == NULL) 
			iTime = 0;
		else iTime = atoi(token);

		if (iTime < 0) iTime = 0;

		m_sForceRecallTime = iTime ;

		ZeroMemory(cBuff, sizeof(cBuff));
		cp = (char *)cBuff;
		*cp = GSM_REQUEST_SETFORCERECALLTIME;
		cp++;

		wp = (WORD *)cp;
		*wp = iTime ;
		cp += 2;

		bStockMsgToGateServer(cBuff, 3);

		wsprintf(g_cTxt,"(!) Admin Set Force Recall Time (%d)min",m_sForceRecallTime) ;
		PutLogList(g_cTxt) ;
	}

	return ;
}

void CGame::AdminOrder_UnsummonAll(int iClientH)
{
	int i;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	
	for (i = 1; i < MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) {
			//0.3-> kill summoned monsters only, by Elimos
			if ((m_pNpcList[i]->m_bIsSummoned == TRUE) && (m_pNpcList[i]->m_bIsKilled == FALSE)) 
				NpcKilledHandler(iClientH, OWNERTYPE_PLAYER, i, 0);
		}
}



void CGame::AdminOrder_UnsummonBoss(int iClientH)
{
	int i;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	for (i = 1; i < MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) {
			if (((m_pNpcList[i]->m_sType == 31) || (m_pNpcList[i]->m_sType == 49)  || (m_pNpcList[i]->m_sType == 45)  || (m_pNpcList[i]->m_sType == 47) || (m_pNpcList[i]->m_sType == 50) || (m_pNpcList[i]->m_sType == 52)) && 
				(m_pNpcList[i]->m_bIsKilled == FALSE)) {
					m_pNpcList[i]->m_bIsSummoned = TRUE ; 
					NpcKilledHandler(iClientH, OWNERTYPE_PLAYER, i, 0);
		}
	}
}

char CGame::_cGetSpecialAbility(int iKindSA)
{
	char cSA;

	switch (iKindSA) {
	case 1: 
		switch (dice(1,2)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		}
		break;

	case 2:
		switch (dice(1,3)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 5; break;
		}
		break;

	case 3:
		switch (dice(1,4)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 5; break;
		case 4: cSA = 6; break;
		}
		break;

	case 4:
		switch (dice(1,3)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 7; break;
		}
		break;

	case 5:
		switch (dice(1,4)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 7; break;
		case 4: cSA = 8; break;
		}
		break;

	case 6:
		switch (dice(1,3)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 5; break;
		}
		break;

	case 7:
		switch (dice(1,3)) {
		case 1: cSA = 1; break;
		case 2: cSA = 2; break;
		case 3: cSA = 4; break;
		}
		break;

	case 8:
		switch (dice(1,5)) {
		case 1: cSA = 1; break;
		case 2: cSA = 2; break;
		case 3: cSA = 4; break;
		case 4: cSA = 3; break;
		case 5: cSA = 8; break;
		}
		break;

	case 9:
		cSA = dice(1,8);
		break;

	case 10:
		cSA = 1;
		break;
	}

	return cSA;
}

void CGame::AdminOrder_Summon(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cName_Master[10], cName_Slave[10], cNpcName[256], cWaypoint[11], cSA; 
	int    pX, pY, j, iNum, iNamingValue;
	bool   bMaster, bSummoned;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		return;
	}

	ZeroMemory(cNpcName, sizeof(cNpcName));
	strcpy(cNpcName, token);

	token = pStrTok->pGet();

	if (token != NULL) 
		iNum = atoi(token);
	else iNum = 1;

	if (iNum <= 0)  iNum = 1;
	if (iNum >= 50)  iNum = 50;

	bSummoned = FALSE;
	token = pStrTok->pGet();
	if (token != NULL)
		if (token[0]=='1')bSummoned = TRUE;

	token = pStrTok->pGet();
	if (token != NULL){
		cSA = token[0] - '0';
		if(cSA < 0 || cSA > 8){
			cSA = 0;
		}
	} else cSA = 0;

	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;

	wsprintf(g_cTxt, "(!) Admin Order: Summon(%s)-(%d)", cNpcName, iNum);
	PutLogList(g_cTxt);

	wsprintf(g_cTxt, "GM Order(%s): Summon NPC(%s)-Count(%d)",m_pClientList[iClientH]->m_cCharName, cNpcName, iNum);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);

	iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
	if (iNamingValue != -1) {

		ZeroMemory(cName_Master, sizeof(cName_Master));
		wsprintf(cName_Master, "XX%d", iNamingValue);
		cName_Master[0] = '_';
		cName_Master[1] = m_pClientList[iClientH]->m_cMapIndex + 65;

		if ((bMaster = bCreateNewNpc( cNpcName, cName_Master, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, cSA, MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, bSummoned, FALSE, TRUE)) == FALSE) {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
		}
	}

	for (j = 0; j < (iNum - 1); j++) {
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {

			ZeroMemory(cName_Slave, sizeof(cName_Slave));
			wsprintf(cName_Slave, "XX%d", iNamingValue);
			cName_Slave[0] = '_';
			cName_Slave[1] = m_pClientList[iClientH]->m_cMapIndex + 65;



			if (bCreateNewNpc( cNpcName, cName_Slave, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, cSA, MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, bSummoned, FALSE) == FALSE) {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
				break;
			}
			else {
				bSetNpcFollowMode(cName_Slave, cName_Master, OWNERTYPE_NPC);
			}
		}
	}

}


void CGame::AdminOrder_SummonPlayer(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * cp, * token, cName[11], cBuff[256];
	WORD   * wp;
	register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		if (strlen(token) > 10)
			memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));


		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {

				if (i == iClientH) {
					return;
				}

#ifdef TAIWANLOG
				short sX = 0,sY = 0 ;
				char cMapName[22] ; 

				ZeroMemory(cMapName,sizeof(cMapName)) ;

				sX = m_pClientList[i]->m_sX ;
				sY = m_pClientList[i]->m_sY ;
				strcpy(cMapName, m_pClientList[i]->m_cMapName) ;

				m_pClientList[i]->m_sX = m_pClientList[iClientH]->m_sX;
				m_pClientList[i]->m_sY = m_pClientList[iClientH]->m_sY;
				strcpy(m_pClientList[i]->m_cMapName, m_pClientList[iClientH]->m_cMapName) ;

				_bItemLog(ITEMLOG_SUMMONPLAYER, i, m_pClientList[iClientH]->m_cCharName,NULL) ;

				m_pClientList[i]->m_sY = sY ; 
				m_pClientList[i]->m_sX = sX ;

				strcpy(m_pClientList[i]->m_cMapName,cMapName) ;

#endif 

				RequestTeleportHandler(i, 2, m_pClientList[iClientH]->m_cMapName ,m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
				return;
			}

			wsprintf(g_cTxt, "GM Order(%s): PC(%s) Summoned to (%s)",m_pClientList[iClientH]->m_cCharName, cName,m_pClientList[iClientH]->m_cMapName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);

			ZeroMemory(cBuff, sizeof(cBuff));
			cp = (char *)cBuff;
			*cp = GSM_REQUEST_SUMMONPLAYER;
			cp++;

			memcpy(cp, cName, 10);
			cp += 10;

			memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10);
			cp += 10;

			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_sX ;
			cp += 2;

			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_sY;
			cp += 2;


			bStockMsgToGateServer(cBuff, 25);

			return;
	}

}

void CGame::AdminOrder_CleanMap(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cMapName[11], cBuff[256];
	BOOL bFlag = FALSE;	//Used to check if we are on the map we wanna clear
	int i;
	CItem *pItem;
	short sRemainItemSprite, sRemainItemSpriteFrame, dX, dY;
	char cRemainItemColor, len;


	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 4) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);

		for (i = 0; i < MAXMAPS; i++)	//Enum all maps
			if (m_pMapList[i] != NULL) {	//Is allocated map
				if (memcmp(m_pMapList[i]->m_cName, cMapName, 10) == 0) {	//is map same name
					bFlag = TRUE; //Set flag
					//Get X and Y coords
					int m_x = m_pMapList[i]->m_sSizeX;
					int m_y = m_pMapList[i]->m_sSizeY;
					for(int j = 1; j < m_x; j++)
						for(int k = 1; k < m_y; k++){
							do {	//Delete all items on current tile
								pItem = m_pMapList[i]->pGetItem(j, k, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor); // v1.4
								if (pItem != NULL) {
									delete pItem;	//Delete item;
								}
							} while(pItem != NULL);
						}
					break;	//Break outo f loop
				}
			}

		if (!bFlag) {	//Notify GM he has to be on the map he clears
		}
		else{	//Notify GM that all items have been cleared
			for(int i = 1; i < MAXCLIENTS; i++){
				if (m_pClientList[i] != NULL) {
				len = strlen(cMapName);
				if(len > 10) len = 10;
				if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, cMapName, len) != 0) return;
				dX = m_pClientList[i]->m_sX;
				dY = m_pClientList[i]->m_sY;
				ZeroMemory(cMapName,sizeof(cMapName));
				strcpy(cMapName, m_pClientList[i]->m_cMapName);
				RequestTeleportHandler(i, 2, cMapName, dX, dY);
				}
			}
		}
	}

	return;
}

void CGame::AdminOrder_DisconnectAll(int iClientH)
{
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 4) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	_iForcePlayerDisconect(MAXCLIENTS);
}

void CGame::NpcDeadItemGenerator(int iNpcH, short sAttackerH, char cAttackerType)
{
	class CItem * pItem = NULL;
	char  cItemName[21], cTemp[20];
	bool  bIsGold;
	int   iGenLevel = 0, iResult, iItemID = 0;
	double dTmp1, dTmp2, dTmp3;
	DWORD dwValue;
	SYSTEMTIME SysTime;

	CNpc *& npc = m_pNpcList[iNpcH];
	if (!npc) return;

	if ((cAttackerType != OWNERTYPE_PLAYER) || (npc->m_bIsSummoned == TRUE)) return;

	ZeroMemory(cItemName, sizeof(cItemName));
	bIsGold = FALSE;

	switch (npc->m_sType) {
	case NPC_GUARD:
	case NPC_DUMMY:
	case NPC_AGT:
	case NPC_CGT:
	case NPC_DT:
		return;
	}

	if( NpcDeadItemGeneratorWithItemEvent(iNpcH, sAttackerH, cAttackerType) == TRUE)
		return;

	int iItemprobability = m_iPrimaryDropRate;

	iItemprobability += m_cRepDropModifier;

	if ((m_pClientList[sAttackerH] != NULL) && (m_pClientList[sAttackerH]->m_iPartyStatus != PARTYSTATUS_PROCESSING))
	{
		iItemprobability += 1500;
	}

	if(m_pClientList[sAttackerH]->IsHeldWinner())
	{
		iItemprobability += 1500;
	}

	if (iItemprobability > dice(1,10000)) 
	{

		if (dice(1,10000) <= 3000) {
			strcpy(cItemName, "Gold");

			pItem = new class CItem;
			if (_bInitItemAttr(pItem, cItemName) == FALSE) {
				delete pItem;
				return;
			}
			// Gold ratio
			if(npc->dwGoldDropValue == 0) {
				delete pItem;
				return;
			}
			else if(npc->dwGoldDropValue <= 4) pItem->m_dwCount = dice(1, npc->dwGoldDropValue);
			else
				switch(dice(1,2)){
				case 1:
					pItem->m_dwCount = (DWORD)(npc->dwGoldDropValue + dice(1, npc->dwGoldDropValue/5));
					break;

				case 2:
					pItem->m_dwCount = (DWORD)(npc->dwGoldDropValue - dice(1, npc->dwGoldDropValue/5));
					break;
			}

			//if npc had an attribute, double gold
			if(npc->m_cSpecialAbility != NULL) pItem->m_dwCount *= 2;

			// check for items that give +gold%
			if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_iAddGold != NULL)) {
				dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddGold;
				dTmp2 = (double)pItem->m_dwCount;
				dTmp3 = (dTmp1/100.0f)*dTmp2;
				pItem->m_dwCount += (int)dTmp3;
			}
		}
		else {

			if(m_drops.HasPrimaryDrop(npc))
			{
				iItemID = m_drops.Roll(npc);

				if(iItemID == ITEM_NONE) return;

				pItem = new class CItem;
				if (!_bInitItemAttr(pItem, iItemID)) {
					delete pItem;
					return;
				}
			}else { if (dice(1,10000) <= m_iSecondaryDropRate + m_cRepDropModifier) {
				// pots/zem/stones/etc...
				iResult = dice(1,10000);  
				if ((iResult >= 1) && (iResult <= 3000))          dwValue = 1;   
				else if ((iResult >= 3001) && (iResult <= 4000))  dwValue = 2;
				else if ((iResult >= 4001) && (iResult <= 5500))  dwValue = 3;
				else if ((iResult >= 5501) && (iResult <= 7000))  dwValue = 4;
				else if ((iResult >= 7001) && (iResult <= 8500))  dwValue = 5;
				else if ((iResult >= 8501) && (iResult <= 9100))  dwValue = 6;
				else if ((iResult >= 9101) && (iResult <= 9900))  dwValue = 7;
				else if ((iResult >= 9901) && (iResult <= 10000)) dwValue = 8;

				switch (dwValue) 
				{
				case 1: iItemID = 95 ;  break; 
				case 2: iItemID = 91 ;  break; 
				case 3: iItemID = 93 ;  break; 
				case 4: iItemID = 96 ;  break; 
				case 5: iItemID = 92 ;  break; 
				case 6: iItemID = 94 ;  break; 
				case 7: 
					if (dice(1,3) == 1) 
						iItemID = 390; 
					else iItemID = 95 ; 
					break; 
				case 8:

					switch (dice(1,8)) 
					{
					case 1:
					case 2: 
						if(dice(1,3) == 1)
							iItemID = ITEM_ZEM;
						break;
					case 3:
					case 4: 
					case 5: 
					case 6: 
						if (dice(1,3) == 1) 
							iItemID = 391; 
						else iItemID = 95 ; 
						break;
					case 7:
					case 8: 
						switch (dice(1,8)) 
						{ 
						case 1: 
						case 2: 
						case 3:
						case 4:
						case 5:
							iItemID = 95; 
							break ;
						case 6:
							if (dice(1,2) == 1) 
								iItemID = ITEM_STONEOFXELIMA;  
							break;
						case 7:
							if (dice(1,2) == 1) 
								iItemID = ITEM_STONEOFMERIEN; 
							break;
						case 8:
							break;
						}
					}
				}

				pItem = new class CItem;
				if (_bInitItemAttr(pItem, iItemID) == FALSE) {
					delete pItem;
					return;
				}
		}else{
				iGenLevel = npc->GetGenLevel(); 

				if (iGenLevel == 0) return;

				if (dice(1,10000) <= 8000) {
					// weapons
					if (dice(1,10000) <= 8000) {
						// regular
						switch (iGenLevel) {
						case 1:
							switch (dice(1,3)) {
							case 1: iItemID = 1; break;   // Dagger
							case 2: iItemID = 8; break;   // ShortSword
							case 3: iItemID = 59; break;  // LightAxe
							}
							break;

						case 2:
							switch (dice(1,6)) {
							case 1: iItemID = 12; break;  //MainGauche
							case 2: iItemID = 15; break;  //Gradius
							case 3: iItemID = 65; break;  //SexonAxe
							case 4: iItemID = 62; break;  //Tomahoc
							case 5: iItemID = 23; break;  //Sabre
							case 6: iItemID = 31; break;  //Esterk
							}
							break;

						case 3: 
							switch (dice(1,4)) {
							case 1: iItemID = 17; break;  //LongSword
							case 2: iItemID = 68; break;  //DoubleAxe
							case 3: iItemID = 23; break;  //Sabre
							case 4: iItemID = 31; break;  //Esterk
							}
							break;

						case 4: 
							switch (dice(1,5)) {
							case 1: iItemID = 23; break;   //Sabre
							case 2: iItemID = 25; break;   //Scimitar
							case 3: iItemID = 28; break;   //Falchion
							case 4: iItemID = 31; break;   //Esterk
							case 5: iItemID = 34; break;   //Rapier
							}
							break;

						case 5:
							switch (dice(1,3)) {
							case 1: iItemID = 31; break;   //Esterk
							case 2: iItemID = 34; break;   //Rapier
							case 3: iItemID = 71; break;   //WarAxe
							}
							break;

						case 6:
							switch (dice(1,5)) {
							case 1: iItemID = 50; break;   //GreatSword
							case 2: iItemID = 54; break;   //Flameberge
							case 3: iItemID = 46; break;   //Claymore
							case 4: iItemID = 31; break;   //Esterk
							case 5: iItemID = 34; break;   //Rapier
							}
							break;

						case 7:
							switch (dice(1,4)) {
							case 1: iItemID = 50; break;   //GreatSword
							case 2: iItemID = 54; break;   //Flameberge
							case 3: iItemID = 31; break;   //Esterk
							case 4: iItemID = 34; break;   //Rapier
							}
							break;

						case 8:
							switch (dice(1,7)) {
							case 1: iItemID = 50; break;   //GreatSword
							case 2: iItemID = 54; break;   //Flameberge
							case 3: iItemID = 560; break;  //BattleAxe
							case 4: iItemID = 31; break;   //Esterk
							case 5: iItemID = 34; break;   //Rapier
							case 6: iItemID = 55; break;   //Flameberge+1
							case 7: iItemID = 615; break;  //GiantSword
							}
							break;

						case 9: // Mountain-Giant
							switch( dice(1, 6) ) {
							case 1: iItemID = 23; break;   //Sabre
							case 2: iItemID = 25; break;   //Scimitar
							case 3: iItemID = 28; break;   //Falchion
							case 4: iItemID = 31; break;   //Esterk
							case 5: iItemID = 34; break;   //Rapier
							case 6: iItemID = 760; break;  //Hammer
							default: break;
							}
							break;

						case 10: // Ettin
							switch( dice(1, 5) ) {
							case 1: iItemID = 46; break;   //Claymore
							case 2: iItemID = 31; break;   //Esterk
							case 3: iItemID = 34; break;   //Rapier
							case 4: iItemID = 760; break;  //Hammer
							case 5: iItemID = 761; break;  //BattleHammer
							default: break;
							}
							break;


						}
					}
					else {
						// wands
						switch (iGenLevel) {
						case 1:	break;
						case 2:
						case 3:	iItemID = 258; break;  // MagicWand(MS0)
						case 4:
						case 5:
						case 6: iItemID = 257; break;  // MagicWand(MS10)
						case 7:
						case 8:	iItemID = 256; break;  // MagicWand(MS20)
						}
					}
				}
				else {
					// armors
					switch (dice(1, iGenLevel)) {
					case 1:
					case 2:
						switch (dice(1,2)) {
						case 1: iItemID = 79; break; // WoodShield
						case 2: iItemID = 81; break; // TargeShield
						}
						break;

					case 3:
						iItemID = 81;  break;   // TargeShield
						break;

					case 4:
						switch (dice(1,5)) {
						case 1: iItemID = 454; break; // Hauberk(M)
						case 2: iItemID = 472; break; // Hauberk(W)
						case 3: iItemID = 461; break; // ChainHose(M)
						case 4: iItemID = 482; break; // ChainHose(W)
						case 5: iItemID = 83;  break; // BlondeShield
						}
						break;

					case 5:
						switch (dice(1,3)) {
						case 1: iItemID = 455; break; // LeatherArmor(M)
						case 2: iItemID = 475; break; // LeatherArmor(W)
						case 3: iItemID = 84;  break; // IronShield
						}
						break;

					case 6:
						switch (dice(1,3)) 
						{
						case 1: 
							switch (dice(1,2)) 
							{
							case 1: iItemID = 456; break; // ChainMail(M)
							case 2: iItemID = 476; break; // ChainMail(W)
							}
							break;
						case 2: 
							switch (dice(1,2)) 
							{
							case 1: iItemID = 458; break; // PlateMail(M)
							case 2: iItemID = 478; break; // PlateMail(W)
							}
							break;
						case 3: iItemID = 85; break; // LagiShield
						}
						break;

					case 7:
						switch (dice(1,6)) 
						{
						case 1: 
							switch (dice(1,2)) 
							{
							case 1: iItemID = 457; break; // ScaleMail(M)
							case 2: iItemID = 477; break; // ScaleMail(W)
							}
							break;
						case 2: 
							switch (dice(1,2)) 
							{
							case 1: iItemID = 458; break; // PlateMail(M)
							case 2: iItemID = 478; break; // PlateMail(W)
							}
							break;
						case 3: iItemID = 86; break; // KnightShield
						case 4: iItemID = 87; break; // TowerShield
						case 5:
							switch (dice(1,2)) 
							{
							case 1: iItemID = 600; break; // Helm(M)
							case 2: iItemID = 602; break; // Helm(W)
							}
							break;
						case 6: 
							switch (dice(1,2)) 
							{
							case 1: iItemID = 601; break; // FullHelm(M)
							case 2: iItemID = 603; break; // FullHelm(W)
							}
							break;
						}
						break;

					case 8:	iItemID = 402; break; 
					}
				}

				}

				if(!iItemID)
					return;

				pItem = new class CItem;
				if (_bInitItemAttr(pItem, iItemID) == FALSE) {
					delete pItem;
					return;
				}

				if( bCheckInItemEventList(iItemID, iNpcH) == TRUE ) {
					delete pItem;
					return;
				}
			}
		}

		pItem->InitStats( npc->GetGenLevel() );


		pItem->m_sTouchEffectType   = ITET_ID;
		pItem->m_sTouchEffectValue1 = dice(1,100000);
		pItem->m_sTouchEffectValue2 = dice(1,100000);
#ifdef LOGTIME
		pItem->m_sTouchEffectValue3 = timeGetTime();
#else 
		GetLocalTime(&SysTime);
		ZeroMemory(cTemp, sizeof(cTemp));
		//		wsprintf(cTemp, "%d%02d%02d",  (short)SysTime.wMonth, (short)SysTime.wDay,(short) SysTime.wHour);
		wsprintf(cTemp, "%d%02d%",  (short)SysTime.wMonth, (short)SysTime.wDay);

		pItem->m_sTouchEffectValue3 = atoi(cTemp);
#endif

		if(m_pMapList[ npc->m_cMapIndex ]->iCheckItem(
			npc->m_sX, npc->m_sY) == ITEMTYPE_RELIC)
		{
			delete pItem;
		}
		else
		{
			m_pMapList[ npc->m_cMapIndex ]->bSetItem(npc->m_sX, 
				npc->m_sY, 
				pItem);


			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, npc->m_cMapIndex,
				npc->m_sX, npc->m_sY,
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);

			_bItemLog(ITEMLOG_NEWGENDROP, 0, npc->m_cNpcName, pItem);

			AddGroundItem(pItem, npc->m_sX, npc->m_sY, npc->m_cMapIndex, TILECLEANTIME);
		}
	}
} 


/*
; mapdata  
;item-event = index	item_name	amount	TotalNumber	month	day		type	mob_list[Max:5]
;	type = 0 :       .
;	       1 : Item Event       .

item-event = 	1		1		10			11		1		0		Cannibal-Plant Ettin EOL
item-event = 	2		1		10			11		1		0		Giant-Frog Scorpion EOL
*/
bool CGame::NpcDeadItemGeneratorWithItemEvent(int iNpcH, short sAttackerH, char cAttackerType)
{
	class CItem * pItem;
	char  cTemp[20];
	int   i, j, iT1, iT2, iT3;
	int	iNumMob;
	SYSTEMTIME SysTime;


	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalItemEvents != NULL)
	{
		GetLocalTime(&SysTime);
		for ( i = 0; i < m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalItemEvents; i++ )
			if (
				( SysTime.wMonth == m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iMonth) &&
				( SysTime.wDay   == m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iDay) &&

				( m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iCurNum < m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iTotalNum )
				)
			{

				iNumMob = m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iNumMob;


				for( j=0; j<iNumMob; j++) {
					if( strcmp(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].cMob[j], m_pNpcList[iNpcH]->m_cNpcName) == 0)
						break;
				}

				if( j == iNumMob )
					continue;

				if (SysTime.wHour < 12 ) {
					if(dice(1,9000) != 6433)
						continue;
				} else if (SysTime.wHour < 18 ) {
					if(dice(1,3000) != 1433)  
						continue;
				} 


				iT1 = 1440 / m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iTotalNum;
				iT2 = iT1 * m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iCurNum;
				iT3 = (SysTime.wHour*60) + SysTime.wMinute;


				if ( (iT1 / 2) > iT3 )
					continue;

				if ( ((iT2 <= iT3) && (iT3 <= iT2 + iT1)) || (iT2+iT1 < iT3) ) {

					int	iT4 = iT1 / 4;
					if( (iT4 > 10) && dice(1, iT4) != 5 )
						continue;

					pItem = new class CItem;
					if (_bInitItemAttr(pItem, m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].cItemName) == FALSE) {
						delete pItem;
						pItem = NULL;
					}
					else {

						pItem->m_sTouchEffectType   = ITET_ID;
						pItem->m_sTouchEffectValue1 = dice(1,100000);
						pItem->m_sTouchEffectValue2 = dice(1,100000);

#ifdef LOGTIME
						pItem->m_sTouchEffectValue3 = timeGetTime();
#else 
						ZeroMemory(cTemp, sizeof(cTemp));
						//					wsprintf(cTemp, "%d%02d%02d",  (short)SysTime.wMonth, (short)SysTime.wDay,(short) SysTime.wHour);
						wsprintf(cTemp, "%d%02d",  (short)SysTime.wMonth, (short)SysTime.wDay);
						pItem->m_sTouchEffectValue3 = atoi(cTemp);
#endif


						/*
						.			if( pItem->m_sIDnum >= 651 &&  pItem->m_sIDnum <= 655 )
						{
						if(  SysTime.wYear == 2002 && SysTime.wMonth == 11 && (SysTime.wDay >= 1 && SysTime.wDay <=7 ) )
						pItem->m_sItemSpecEffectValue2 = 113; 
						}
						*/ 


						m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX,
							m_pNpcList[iNpcH]->m_sY,
							pItem);


						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
							m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY,
							pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);

						_bItemLog(ITEMLOG_NEWGENDROP, 0, m_pNpcList[iNpcH]->m_cNpcName, pItem);
						wsprintf(g_cTxt,"Event Item (%s)",pItem->m_cName) ;
						PutLogFileList(g_cTxt, DEBUG_LOGFILE);

						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iCurNum++;

						return TRUE;
					}

					// return FALSE;
				}
			}
	} 

	return FALSE;
} // NpcDeadItemGeneratorWithItemEvent


bool CGame::bCheckInItemEventList(int iItemID, int iNpcH)
{
	int		i;
	char	cItemName[21];

	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalItemEvents != NULL)
	{

		for (i = 0; i < MAXITEMTYPES; i++ )
		{
			if( m_pItemConfigList[i] == NULL )
				continue;

			if( m_pItemConfigList[i]->m_sIDnum == iItemID ) {
				strcpy(cItemName, m_pItemConfigList[i]->m_cName);
				break;
			}
		}

		for (i = 0; i < m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalItemEvents; i++)
		{
			if( m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iType != 0 )
				continue;

			if( strcmp( m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].cItemName, cItemName) == 0 )
				return TRUE;
		}
	}

	return FALSE;
} // bCheckInItemEventList()


bool CGame::_bDecodeDupItemIDFileContents(char *pData, DWORD dwMsgSize)
{
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iIndex = 0;
	

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();

	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
			case 1:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}

				if (m_pDupItemIDList[atoi(token)] != NULL) {
					PutLogList("(!!!) ERROR! DupItemID configuration file error - Duplicate magic number.");
					delete[] pContents;
					return FALSE;
				}
				m_pDupItemIDList[atoi(token)] = new class CItem;
				iIndex = atoi(token);

				cReadModeB = 2;
				break;

			case 2:
				// m_sTouchEffectType
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pDupItemIDList[iIndex]->m_sTouchEffectType = atoi(token);
				cReadModeB = 3;
				break;

			case 3:
				// m_sTouchEffectValue1
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pDupItemIDList[iIndex]->m_sTouchEffectValue1 = atoi(token);
				cReadModeB = 4;
				break;

			case 4:
				// m_sTouchEffectValue2
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pDupItemIDList[iIndex]->m_sTouchEffectValue2 = atoi(token);
				cReadModeB = 5;
				break;

			case 5:
				// m_sTouchEffectValue3
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pDupItemIDList[iIndex]->m_sTouchEffectValue3 = atoi(token);
				cReadModeB = 6;
				break;

			case 6:
				// m_wPrice
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
					delete[] pContents;
					return FALSE;
				}
				m_pDupItemIDList[iIndex]->m_wPrice = (WORD)atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "DupItemID", 9) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}

		}
		token = pStrTok->pGet();
	}

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(ERROR) DupItemID configuration file contents error!");
		return FALSE;
	}

	//wsprintf(cTxt, "(!) DupItemID(Total:%d) configuration - success!", iIndex);
	//PutLogList(cTxt);

	return TRUE;
}

bool CGame::_bCheckDupItemID(CItem *pItem)
{
	int i;

	for (i = 0; i < MAXDUPITEMID; i++)
		if (m_pDupItemIDList[i] != NULL) {
			if ((pItem->m_sTouchEffectType   == m_pDupItemIDList[i]->m_sTouchEffectType) &&
				(pItem->m_sTouchEffectValue1 == m_pDupItemIDList[i]->m_sTouchEffectValue1) &&
				(pItem->m_sTouchEffectValue2 == m_pDupItemIDList[i]->m_sTouchEffectValue2) &&
				(pItem->m_sTouchEffectValue3 == m_pDupItemIDList[i]->m_sTouchEffectValue3) ) {

					pItem->m_wPrice = m_pDupItemIDList[i]->m_wPrice;
					return TRUE;
			}
		}

		return FALSE;
}

void CGame::RequestNoticementHandler(int iClientH, char * pData)
{
	char * cp, cData[120];
	int  * ip, iRet, iClientSize;
	DWORD * dwp;
	WORD  * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_dwNoticementDataSize < 10) return;

	ip = (int *)(pData + INDEX2_MSGTYPE + 2);
	iClientSize = *ip;

	if (iClientSize != m_dwNoticementDataSize) {
		cp = new char[m_dwNoticementDataSize + 2 + INDEX2_MSGTYPE + 2];
		ZeroMemory(cp, m_dwNoticementDataSize + 2 + INDEX2_MSGTYPE + 2);
		memcpy((cp + INDEX2_MSGTYPE + 2), m_pNoticementData, m_dwNoticementDataSize);

		dwp  = (DWORD *)(cp + INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_NOTICEMENT;
		wp   = (WORD *)(cp + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_REJECT;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cp, m_dwNoticementDataSize + 2 + INDEX2_MSGTYPE + 2);

		delete[] cp;
	}
	else {
		ZeroMemory(cData, sizeof(cData));

		dwp  = (DWORD *)(cData + INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_NOTICEMENT;
		wp   = (WORD *)(cData + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	}
}

void CGame::_bDecodeNoticementFileContents(char *pData, DWORD dwMsgSize)
{
	char * cp;

	cp = (pData);

	if (m_pNoticementData != NULL) {
		delete m_pNoticementData;
		m_pNoticementData = NULL;
	}

	m_pNoticementData = new char[strlen(cp) + 2];
	ZeroMemory(m_pNoticementData, strlen(cp) + 2);

	memcpy(m_pNoticementData, cp, strlen(cp));
	m_dwNoticementDataSize = strlen(cp);

	//wsprintf(g_cTxt, "(!) Noticement Data Size: %d", m_dwNoticementDataSize);
	//PutLogList(g_cTxt);
}

void CGame::RequestCheckAccountPasswordHandler(char *pData, DWORD dwMsgSize)
{
	int * ip, i, iLevel;
	char * cp, cAccountName[11], cAccountPassword[11];

	cp = (char *)(pData + 6);

	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));

	memcpy(cAccountName, cp, 10);
	cp += 10;

	memcpy(cAccountPassword, cp, 10);
	cp += 10;

	ip = (int *)cp;
	iLevel = *ip;
	cp += 4;

	for (i = 0; i < MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cAccountName, cAccountName) == 0)) {

			if ((strcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword) != 0) || (m_pClientList[i]->m_iLevel != iLevel)) {
				wsprintf(g_cTxt, "(TestLog) Error! Account(%s)-Level(%d) password(or level) mismatch! Disconnect.", cAccountName, iLevel);
				PutLogList(g_cTxt);
				DeleteClient(i, FALSE, TRUE);
				return;
			}
		}
}

void CGame::_TamingHandler(int iClientH, int iSkillNum, char cMapIndex, int dX, int dY)
{
	int iSkillLevel, iRange, iTamingLevel, iResult, iX, iY;
	short sOwnerH;
	char  cOwnerType;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pMapList[cMapIndex] == NULL) return;

	iSkillLevel = (int)m_pClientList[iClientH]->m_cSkillMastery[iSkillNum];
	iRange = iSkillLevel / 12; 

	for (iX = dX - iRange; iX <= dX + iRange; iX++)
		for (iY = dY - iRange; iY <= dY + iRange; iY++) {
			sOwnerH = NULL;
			if ((iX > 0) && (iY > 0) && (iX < m_pMapList[cMapIndex]->m_sSizeX) && (iY < m_pMapList[cMapIndex]->m_sSizeY))
				m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, iX, iY);

			if (sOwnerH != NULL) {
				switch (cOwnerType) {
			case OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) break;
				break;

			case OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) break;
				iTamingLevel = 10;
				switch (m_pNpcList[sOwnerH]->m_sType) {
				case 10:
				case 16: iTamingLevel = 1; break;
				case 22: iTamingLevel = 2; break;
				case 17:
				case 14: iTamingLevel = 3; break;
				case 18: iTamingLevel = 4; break;   
				case 11: iTamingLevel = 5; break;
				case 23:
				case 12: iTamingLevel = 6; break;
				case 28: iTamingLevel = 7; break;
				case 13:
				case 27: iTamingLevel = 8; break;
				case 29: iTamingLevel = 9; break;
				case 33: iTamingLevel = 9; break;
				case 30: iTamingLevel = 9; break;  
				case 31:
				case 32: iTamingLevel = 10; break;  				}

				iResult = (iSkillLevel/10);

				if (iResult < iTamingLevel) break;

				break;
				}
			}
		}
}

void CGame::GetMagicAbilityHandler(int iClientH)
{
	//if (m_pClientList[iClientH] == NULL) return;
	////if (m_pClientList[iClientH]->m_cSkillMastery[SKILL_MAGIC] != 0) return;

	////m_pClientList[iClientH]->m_cSkillMastery[SKILL_MAGIC] = 20;
	////SendNotifyMsg(NULL, iClientH, NOTIFY_SKILL, 4, m_pClientList[iClientH]->m_cSkillMastery[SKILL_MAGIC], NULL, NULL);

	////m_pClientList[iClientH]->CheckTotalSkillMasteryPoints(4);
}

int CGame::iRequestPanningMapDataRequest(int iClientH, char * pData)
{
	char  * cp, cDir, cData[3000];
	DWORD * dwp;
	WORD  * wp;
	short * sp, dX, dY;
	int   iRet, iSize;

	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;

	cDir = *(pData + INDEX2_MSGTYPE +2);
	if ((cDir <= 0) || (cDir > 8)) return 0;

	switch (cDir) {
	case 1:	dY--; break;
	case 2:	dX++; dY--;	break;
	case 3:	dX++; break;
	case 4:	dX++; dY++;	break;
	case 5:	dY++; break;
	case 6:	dX--; dY++;	break;
	case 7:	dX--; break;
	case 8:	dX--; dY--;	break;
	}

	if (dX < 1 || dX > m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX ||
		dY < 1 || dY > m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY){
		 return 0;
	}

	m_pClientList[iClientH]->m_sX   = dX;
	m_pClientList[iClientH]->m_sY   = dY;
	m_pClientList[iClientH]->m_cDir = cDir;

	dwp  = (DWORD *)(cData + INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_PANNING;
	wp   = (WORD *)(cData + INDEX2_MSGTYPE);
	*wp  = OBJECTMOVE_CONFIRM;

	cp = (char *)(cData + INDEX2_MSGTYPE+2);

	sp  = (short *)cp;
	*sp = dX - 10; 
	cp += 2;

	sp  = (short *)cp;
	*sp = dY - 7; 
	cp += 2;

	*cp = cDir;
	cp++;

	iSize = iComposeMoveMapData(dX - 10, dY - 7, iClientH, cDir, cp);

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, iSize + 12 + 1 + 4);
	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}

void CGame::AdminOrder_SetObserverMode(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_bIsObserverMode == TRUE) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_LOG, MSGTYPE_CONFIRM, NULL, NULL, NULL);

		SendNotifyMsg(NULL, iClientH, NOTIFY_OBSERVERMODE, 0, NULL, NULL, NULL);
		m_pClientList[iClientH]->m_bIsObserverMode = FALSE;
	}
	else {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(/*1,*/ iClientH, OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_LOG, MSGTYPE_REJECT, NULL, NULL, NULL);

		SendNotifyMsg(NULL, iClientH, NOTIFY_OBSERVERMODE, 1, NULL, NULL, NULL);
		m_pClientList[iClientH]->m_bIsObserverMode = TRUE;
	}
}

void CGame::RequestRestartHandler(int iClientH)
{
	char  cTmpMap[32];
	CClient * player = m_pClientList[iClientH];

	if (!player || !player->m_bIsKilled) return;

	strcpy(cTmpMap,player->m_cMapName) ;
	ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));
	if (player->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ] != 0)
		player->RemoveMagicEffect(MAGICTYPE_CONFUSE);

	switch(player->m_side)
	{
	case ARESDEN:
		if (strcmp(cTmpMap, sideMap[ELVINE]) == 0){
			strcpy(player->m_cLockedMapName, sideMapJail[ELVINE]);
			player->m_iLockedMapTime = 60*3; 
			strcpy(player->m_cMapName, sideMapJail[ELVINE]);
		}else if (strcmp(cTmpMap, sideMap[ISTRIA]) == 0){
			strcpy(player->m_cLockedMapName, sideMapJail[ISTRIA]);
			player->m_iLockedMapTime = 60*3; 
			strcpy(player->m_cMapName, sideMapJail[ISTRIA]);
		}else if (player->m_iLevel > 80)
			strcpy(player->m_cMapName, sideMapRes[ARESDEN]);
		else 
			strcpy(player->m_cMapName, sideMapFarm[ARESDEN]);
		break;
	case ELVINE:
		if (strcmp(cTmpMap, sideMap[ARESDEN]) == 0){
			strcpy(player->m_cLockedMapName, sideMapJail[ARESDEN]);
			player->m_iLockedMapTime = 60*3; 
			strcpy(player->m_cMapName, sideMapJail[ARESDEN]);
		}else if (strcmp(cTmpMap, sideMap[ISTRIA]) == 0){
			strcpy(player->m_cLockedMapName, sideMapJail[ISTRIA]);
			player->m_iLockedMapTime = 60*3; 
			strcpy(player->m_cMapName, sideMapJail[ISTRIA]);
		}else if (player->m_iLevel > 80)
			strcpy(player->m_cMapName, sideMapRes[ELVINE]);
		else 
			strcpy(player->m_cMapName, sideMapFarm[ELVINE]);
		break;
	case ISTRIA:
		if (strcmp(cTmpMap, sideMap[ARESDEN]) == 0){
			strcpy(player->m_cLockedMapName, sideMapJail[ARESDEN]);
			player->m_iLockedMapTime = 60*3; 
			strcpy(player->m_cMapName, sideMapJail[ARESDEN]);
		}else if (strcmp(cTmpMap, sideMap[ELVINE]) == 0){
			strcpy(player->m_cLockedMapName, sideMapJail[ELVINE]);
			player->m_iLockedMapTime = 60*3; 
			strcpy(player->m_cMapName, sideMapJail[ELVINE]);
		}else if (player->m_iLevel > 80)
			strcpy(player->m_cMapName, sideMapRes[ISTRIA]);
		else 
			strcpy(player->m_cMapName, sideMapFarm[ISTRIA]);
		break;
	case NEUTRAL:
		strcpy(player->m_cMapName, sideMap[NEUTRAL]);
		break;
	}

	player->m_bIsKilled = FALSE;
	player->m_iHP = player->GetMaxHP();
	player->m_iHungerStatus = 100;

	ZeroMemory(cTmpMap, sizeof(cTmpMap));
	strcpy(cTmpMap, player->m_cMapName);

	RequestTeleportHandler(iClientH, 2, cTmpMap);
}



void CGame::AdminOrder_CreateItem(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cItemName[256], cTemp[256];
	SYSTEMTIME SysTime;
	CItem * pItem;
	int    iTemp, iEraseReq, manuEndu, amount;
	DWORD attribute;
	WORD  wTemp;
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 4) {
		if (m_pClientList[iClientH]->m_iAdminUserLevel != 0)
			SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	//	if (memcmp(m_pClientList[iClientH]->m_cIPaddress, "203.234.215.", 12) != 0) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();

	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, token);
	} else return;

	token = pStrTok->pGet();
	if (token != NULL) {
		attribute = atoi(token);
	} else attribute = 0;

	token = pStrTok->pGet();
	if (token != NULL) {
		manuEndu = atoi(token);
	} else manuEndu = 0;

	token = pStrTok->pGet();
	if (token != NULL) {
		amount = atoi(token);
	} else amount = 1;

	for (int i = amount; i > 0; i--){
		pItem = new CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {
			delete pItem;
			return;
		}

		if (pItem->m_cItemType == ITEMTYPE_CONSUME || pItem->m_cItemType == ITEMTYPE_ARROW){
			pItem->m_dwCount = amount;
			i = 0; //Breaks loop early for stackable items
		}

		if (attribute != 0) {
			pItem->m_dwAttribute = attribute;
			if (pItem->m_dwAttribute == 1) {
				if ((manuEndu >= 1) && (manuEndu <= 200)) {

					pItem->m_cItemColor = 2;
					pItem->m_sItemSpecEffectValue2 = manuEndu - 100;


					dV2 = (double)pItem->m_sItemSpecEffectValue2;
					dV3 = (double)pItem->m_wMaxLifeSpan;
					dV1 = (dV2/100.0f)*dV3;

					iTemp  = (int)pItem->m_wMaxLifeSpan;
					iTemp += (int)dV1;

					if (iTemp <= 0) 
						wTemp = 1;
					else wTemp = (WORD)iTemp;

					if (wTemp <= pItem->m_wMaxLifeSpan*2) {
						pItem->m_wMaxLifeSpan = wTemp;
						pItem->m_sItemSpecEffectValue1 = (short)wTemp;
						pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
					}
					else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;

				}
				else pItem->m_dwAttribute = NULL;
			}
			else {

				if (pItem->m_sItemEffectType == ITEMEFFECTTYPE_ATTACK) {
					switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
					case 6:	pItem->m_cItemColor = 2; break;
					case 8:	pItem->m_cItemColor = 3; break;
					case 1:	pItem->m_cItemColor = 5; break;
					case 5:	pItem->m_cItemColor = 1; break;
					case 3:	pItem->m_cItemColor = 7; break;
					case 2:	pItem->m_cItemColor = 4; break;
					case 7:	pItem->m_cItemColor = 6; break;
					case 9:	pItem->m_cItemColor = 8; break;
					}
				}
				else if (pItem->m_sItemEffectType == ITEMEFFECTTYPE_ATTACK_MANASAVE) {
					switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
					case 10: pItem->m_cItemColor = 5; break;
					}
				}
			}
		}


		switch (pItem->m_sIDnum) {
		case 511: 	case 513:
		case 515:
		case 517:
		case 530:
		case 531:
		case 532:
		case 533:
		case 534:
			GetLocalTime(&SysTime);
			pItem->m_sTouchEffectType   = ITET_DATE;

			pItem->m_sTouchEffectValue1 = (short)SysTime.wMonth;
			pItem->m_sTouchEffectValue2 = (short)SysTime.wDay;
			pItem->m_sTouchEffectValue3 = 24 ;
			break;

		default:
			GetLocalTime(&SysTime);
			pItem->m_sTouchEffectType   = ITET_GM_MADE;
			pItem->m_sTouchEffectValue1 = dice(1,100000);
			pItem->m_sTouchEffectValue2 = dice(1,100000);
			ZeroMemory(cTemp, sizeof(cTemp));
			wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
			pItem->m_sTouchEffectValue3 = atoi(cTemp);
			break;
		}

		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {

			SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, false);
			
#ifdef TAIWANLOG 
			_bItemLog(ITEMLOG_CREATE, iClientH, (int) -1, pItem);
#endif

			if (iEraseReq == 1) {
				delete pItem;
				pItem = NULL ;
			}

			wsprintf(g_cTxt, "GM Order(%s): Create ItemName(%s)", m_pClientList[iClientH]->m_cCharName, cItemName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);
		}
		else {
			delete pItem;
			return;
		}
	}
}

void CGame::RequestSellItemListHandler(int iClientH, char * pData)
{
	int i, * ip, iAmount;
	char * cp, cIndex;
	struct {
		char cIndex;
		int  iAmount;
	} stTemp[12];

	if (m_pClientList[iClientH] == NULL) return;

	cp = (char *)(pData + 6);
	for (i = 0; i < 12; i++) {
		stTemp[i].cIndex = *cp;
		cp++;

		ip = (int *)cp;
		stTemp[i].iAmount = *ip;
		cp += 4;
	}


	for (i = 0; i < 12; i++) {
		cIndex = stTemp[i].cIndex;
		iAmount = stTemp[i].iAmount;

		if ((cIndex == -1) || (cIndex < 0) || (cIndex >= MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[cIndex] == NULL) return;


		ReqSellItemConfirmHandler(iClientH, cIndex, iAmount, NULL);
		if (m_pClientList[iClientH] == NULL) return;
	}
}

void CGame::DeleteOccupyFlags(int iMapIndex)
{
	if (!m_pMapList[iMapIndex]) return;

	DWORD dwTime = timeGetTime();

	for (int i = 1; i < MAXOCCUPYFLAG; i++) 
	{	
		if (COccupyFlag *& flag = m_pMapList[iMapIndex]->m_pOccupyFlag[i])
		{	
			wsprintf(g_cTxt, "(*)Delete OccupyFlag: Side(%d) XY(%d, %d)", flag->m_side, flag->m_sX, flag->m_sY);
			PutLogList(g_cTxt);
			int dX = flag->m_sX;
			int dY = flag->m_sY;
			int iDynamicObjectIndex = flag->m_iDynamicObjectIndex;
			CDynamicObject *& dynObj = m_pDynamicObjectList[iDynamicObjectIndex];

			delete flag;
			flag = NULL;			
			m_pMapList[iMapIndex]->m_iTotalOccupyFlags--;
			CTile * tile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + dX + dY*m_pMapList[iMapIndex]->m_sSizeY);
			tile->m_iOccupyFlagIndex = NULL;

			if (!dynObj) continue;

			SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, MSGTYPE_REJECT,
				iMapIndex, dX, dY, dynObj->m_sType,
				iDynamicObjectIndex, NULL);
			m_pMapList[iMapIndex]->SetDynamicObject(NULL, NULL, dX, dY, dwTime);

			delete dynObj;
			dynObj = NULL;
		}
	}
}


void CGame::CreateNewPartyHandler(int iClientH)
{
	bool bFlag;

	if (m_pClientList[iClientH] == NULL) return;

	bFlag = m_pClientList[iClientH]->bCreateNewParty();
	SendNotifyMsg(NULL, iClientH, NOTIFY_RESPONSE_CREATENEWPARTY, (int)bFlag, NULL, NULL, NULL);
}


void CGame::JoinPartyHandler(int iClientH, int iV1, char *pMemberName)
{
	char * cp, cData[120];
	short sAppr2;
	DWORD * dwp;
	WORD * wp;
	int i;

	if (m_pClientList[iClientH] == NULL) return;

	switch (iV1) {
	case 0: 
		RequestDeletePartyHandler(iClientH);
		break;

	case 1: 

		if ((m_pClientList[iClientH]->m_iPartyID != NULL) || (m_pClientList[iClientH]->m_iPartyStatus != PARTYSTATUS_NULL)) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_PARTY, 7, 0, NULL, NULL);

			/*			m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
			ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
			m_pClientList[iClientH]->m_iPartyStatus = PARTYSTATUS_NULL;
			*/
			return;
		}

		for (i = 1; i < MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pMemberName) == 0)) {

				sAppr2 = (short)((m_pClientList[i]->m_sAppr2 & 0xF000) >> 12);
				if (sAppr2 != 0) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_PARTY, 7, 0, NULL, NULL);
				}
				else if (m_pClientList[i]->m_side != m_pClientList[iClientH]->m_side) {

					SendNotifyMsg(NULL, iClientH, NOTIFY_PARTY, 7, 0, NULL, NULL);
				}
				else if (m_pClientList[i]->m_iPartyStatus == PARTYSTATUS_PROCESSING) {

					SendNotifyMsg(NULL, iClientH, NOTIFY_PARTY, 7, 0, NULL, NULL);

					m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
					ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
					m_pClientList[iClientH]->m_iPartyStatus = PARTYSTATUS_NULL;
				}
				else if (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_isPartyDisabled && !m_pClientList[i]->IsGM()){
					SendNotifyMsg(NULL, iClientH, NOTIFY_PARTY, 7, 0, NULL, NULL);
				}
				else {

					m_pClientList[i]->m_iReqJoinPartyClientH = iClientH;
					ZeroMemory(m_pClientList[i]->m_cReqJoinPartyName, sizeof(m_pClientList[i]->m_cReqJoinPartyName));
					strcpy(m_pClientList[i]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName);
					SendNotifyMsg(NULL, i, NOTIFY_QUERY_JOINPARTY, NULL, NULL, NULL, m_pClientList[iClientH]->m_cCharName);

					m_pClientList[iClientH]->m_iReqJoinPartyClientH = i;
					ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
					strcpy(m_pClientList[iClientH]->m_cReqJoinPartyName, m_pClientList[i]->m_cCharName);

					m_pClientList[iClientH]->m_iPartyStatus = PARTYSTATUS_PROCESSING;
				}
				return;
			}
			break;

	case 2: 
		if (m_pClientList[iClientH]->m_iPartyStatus == PARTYSTATUS_CONFIRM) {
			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 6; 
			cp += 2;
			wp = (WORD *)cp;
			*wp = iClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			bSendMsgToLS(MSGID_PARTYOPERATION, iClientH, FALSE, cData);
		}
		break;
	}
}


bool CGame::bCheckEnergySphereDestination(int iNpcH, short sAttackerH, char cAttackerType)
{
	int i, sX,sY, dX, dY, iGoalMapIndex;
	char cResult;

	if (m_pNpcList[iNpcH] == NULL) return FALSE;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex == -1) return FALSE;

	if (m_pNpcList[iNpcH]->m_cMapIndex != m_iMiddlelandMapIndex) {

		iGoalMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;

		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;

		cResult = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].cResult;
		dX = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenX;
		dY = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenY;
		if ((sX >= dX-1) && (sX <= dX+1) && (sY >= dY-1) && (sY <= dY+1)) {

			m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_side == 1) { // Aresden (Side:1)
					wsprintf(g_cTxt, "(!)    (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(g_cTxt);
				}
				else {

				}

				for (i = 1; i < MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
						SendNotifyMsg(NULL, i, NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_side, 2, m_pClientList[sAttackerH]->m_cCharName);
					}
			}

			if (m_pMapList[iGoalMapIndex]->m_bIsEnergySphereAutoCreation == TRUE) EnergySphereProcessor(TRUE, -1*iGoalMapIndex);
			return TRUE;
		}

		dX = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineX;
		dY = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineY;
		if ((sX >= dX-1) && (sX <= dX+1) && (sY >= dY-1) && (sY <= dY+1)) {
			m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_side == 2) { // Elvine (Side:2)
					wsprintf(g_cTxt, "(!)    (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(g_cTxt);
				}
				else {

				}

				for (i = 1; i < MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
						//
						SendNotifyMsg(NULL, i, NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_side, 1, m_pClientList[sAttackerH]->m_cCharName);
					}
			}

			if (m_pMapList[iGoalMapIndex]->m_bIsEnergySphereAutoCreation == TRUE) EnergySphereProcessor(TRUE, -1*iGoalMapIndex);
			return TRUE;
		}

		return FALSE;
	}
	else {

		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;

		cResult = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].cResult;
		dX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenX;
		dY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenY;
		if ((sX >= dX-1) && (sX <= dX+1) && (sY >= dY-1) && (sY <= dY+1)) {

			m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_side == 1) { // Aresden (Side:1)
					m_pClientList[sAttackerH]->m_iContribution += 5;
					wsprintf(g_cTxt, "(!)    (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(g_cTxt);
				}
				else {

					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}

				for (i = 1; i < MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
						SendNotifyMsg(NULL, i, NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_side, 2, m_pClientList[sAttackerH]->m_cCharName);
					}
			}
			return TRUE;
		}

		dX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineX;
		dY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineY;
		if ((sX >= dX-1) && (sX <= dX+1) && (sY >= dY-1) && (sY <= dY+1)) {
			m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_side == 2) { // Elvine (Side:2)
					m_pClientList[sAttackerH]->m_iContribution += 5;
					wsprintf(g_cTxt, "(!)    (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(g_cTxt);
				}
				else {

					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}

				for (i = 1; i < MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
						//
						SendNotifyMsg(NULL, i, NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_side, 1, m_pClientList[sAttackerH]->m_cCharName);
					}
			}
			return TRUE;
		}
		return FALSE;
	}
}

void CGame::EnergySphereProcessor(bool bIsAdminCreate, int iClientH)
{
	int i, iNamingValue, iCIndex, iTemp, pX, pY, iMapIndex;
	char cSA, cName_Internal[31], cWaypoint[31];

	if (bIsAdminCreate != TRUE) {

		if (m_iMiddlelandMapIndex < 0) return;
		if (m_pMapList[m_iMiddlelandMapIndex] == NULL) return;
		if (dice(1,2000) != 123) return; 

		if (m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex >= 0) return;

		iCIndex = dice(1, m_pMapList[m_iMiddlelandMapIndex]->m_iTotalEnergySphereCreationPoint);

		if (m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].cType == NULL) return;

		cSA = 0;
		pX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].sX;
		pY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].sY;
		ZeroMemory(cWaypoint, sizeof(cWaypoint));

		iNamingValue = m_pMapList[m_iMiddlelandMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// 
			ZeroMemory(cName_Internal, sizeof(cName_Internal));
			wsprintf(cName_Internal, "XX%d", iNamingValue);
			cName_Internal[0] = '_';
			cName_Internal[1] = m_iMiddlelandMapIndex + 65;

			if ((bCreateNewNpc("Energy-Sphere", cName_Internal, m_pMapList[m_iMiddlelandMapIndex]->m_cName, cSA, MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE)) == FALSE) {
				m_pMapList[m_iMiddlelandMapIndex]->SetNamingValueEmpty(iNamingValue);
				return;
			}
		}

		iTemp  = dice(1, m_pMapList[m_iMiddlelandMapIndex]->m_iTotalEnergySphereGoalPoint);
		if (m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[iTemp].cResult == NULL) return;

		m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = iTemp;

		for (i = 1; i < MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				SendNotifyMsg(NULL, i, NOTIFY_ENERGYSPHERECREATED, pX, pY, NULL, NULL);
			}

			//testcode
			wsprintf(g_cTxt, "(!) Energy Sphere Created! (%d, %d)", pX, pY);
			PutLogList(g_cTxt);
			PutLogFileList(g_cTxt);
	}
	else {
		if (iClientH == 0)
			iMapIndex = 0;
		else if (iClientH < 0) 			 iMapIndex = -1*iClientH;
		else iMapIndex = m_pClientList[iClientH]->m_cMapIndex;

		if (m_pMapList[iMapIndex]->m_iCurEnergySphereGoalPointIndex >= 0) return;

		iCIndex = dice(1, m_pMapList[iMapIndex]->m_iTotalEnergySphereCreationPoint);

		if (m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iCIndex].cType == NULL) return;

		cSA = 0;
		pX = m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iCIndex].sX;
		pY = m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iCIndex].sY;
		ZeroMemory(cWaypoint, sizeof(cWaypoint));

		iNamingValue = m_pMapList[iMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// 
			ZeroMemory(cName_Internal, sizeof(cName_Internal));
			wsprintf(cName_Internal, "XX%d", iNamingValue);
			cName_Internal[0] = '_';
			cName_Internal[1] = iMapIndex + 65;

			if ((bCreateNewNpc("Energy-Sphere", cName_Internal, m_pMapList[iMapIndex]->m_cName, cSA, MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE)) == FALSE) {
				m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
				return;
			}
		}

		iTemp  = dice(1, m_pMapList[iMapIndex]->m_iTotalEnergySphereGoalPoint);
		if (m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iTemp].cResult == NULL) return;

		m_pMapList[iMapIndex]->m_iCurEnergySphereGoalPointIndex = iTemp;

		for (i = 1; i < MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				SendNotifyMsg(NULL, i, NOTIFY_ENERGYSPHERECREATED, pX, pY, NULL, NULL);
			}

			//testcode
			wsprintf(g_cTxt, "(!) Admin Energy Sphere Created! (%d, %d)", pX, pY);
			PutLogList(g_cTxt);
			PutLogFileList(g_cTxt);
	}
}


void CGame::ActivateSpecialAbilityHandler(int iClientH)
{
	DWORD dwTime = timeGetTime();
	short sTemp;


	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime != 0) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) return;
	if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) return;

#ifdef GUILDWARMODE
	return;
#endif

	m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled  = TRUE;
	m_pClientList[iClientH]->m_specialAbilityStartTime = dwTime;


	m_pClientList[iClientH]->m_iSpecialAbilityTime = SPECABLTYTIMESEC;

	sTemp = m_pClientList[iClientH]->m_sAppr4;
	sTemp = sTemp & 0xFF0F;
	switch (m_pClientList[iClientH]->m_iSpecialAbilityType) {
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
		sTemp = sTemp | 0x0010;
		break;
	case 50:
	case 51:
	case 52:
	case 53:
	case 54:
		sTemp = sTemp | 0x0020;
		break;
	}
	m_pClientList[iClientH]->m_sAppr4 = sTemp;

	SendNotifyMsg(NULL, iClientH, NOTIFY_SPECIALABILITYSTATUS, 1, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_specialAbilityLastSec, NULL);
	SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTNULLACTION, NULL, NULL, NULL);
}

void CGame::CancelQuestHandler(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	_ClearQuestStatus(iClientH);

	SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
}

int CGame::iGetItemWeight(CItem *pItem, int iCount)
{
	int iWeight;

	iWeight = (pItem->m_wWeight);
	if (iCount < 0) iCount = 1;
	iWeight = iWeight * iCount;
	if (pItem->m_sIDnum == ITEM_GOLD) iWeight = iWeight / 20;
	if (iWeight <= 0) iWeight = 1;

	return iWeight;
}


bool CGame::bGetItemNameWhenDeleteNpc(int & iItemID, short sNpcType, int iItemprobability)
{
	if (dice(1,iItemprobability) != 1) return FALSE ;

	switch (sNpcType) {
		case 79: if (dice(1,200) != 11) return FALSE; break;	  // Nizie
		case 70: if (dice(1,200) != 11) return FALSE; break;	  // Barlog
		case 71: if (dice(1,200) != 11) return FALSE; break;	  // Centaurus
		default: return FALSE;
	}


	switch (sNpcType) 
	{
		case 79: // Nizie
			if (dice(1,20) == 11) iItemID = 845; break; // StormBringer

		case 70: // Barlog
			if (dice(1,40) == 11) iItemID = 846; break; // The_Devastator

		case 71: // Centaurus
			if (dice(1,20) == 11) iItemID = 848; break; // Lighting Blade
	}

	if (iItemID == 0) 
		return FALSE;
	else return TRUE;
} // bGetItemNameWhenDeleteNpc


void CGame::UpdateMapSectorInfo()
{
	int i, ix, iy;
	int iMaxNeutralActivity, iMaxAresdenActivity, iMaxElvineActivity, iMaxMonsterActivity, iMaxPlayerActivity;

	for (i = 0; i < MAXMAPS; i++) 
		if (m_pMapList[i] != NULL) {

			iMaxNeutralActivity = iMaxAresdenActivity = iMaxElvineActivity = iMaxMonsterActivity = iMaxPlayerActivity = 0;
			m_pMapList[i]->m_iMaxNx = m_pMapList[i]->m_iMaxNy = m_pMapList[i]->m_iMaxAx = m_pMapList[i]->m_iMaxAy = 0;
			m_pMapList[i]->m_iMaxEx = m_pMapList[i]->m_iMaxEy = m_pMapList[i]->m_iMaxMx = m_pMapList[i]->m_iMaxMy = 0;
			m_pMapList[i]->m_iMaxPx = m_pMapList[i]->m_iMaxPy = 0;

			for (ix = 0; ix < MAXSECTORS; ix++)
				for (iy = 0; iy < MAXSECTORS; iy++) {
					if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity > iMaxNeutralActivity) {
						iMaxNeutralActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity;
						m_pMapList[i]->m_iMaxNx = ix;
						m_pMapList[i]->m_iMaxNy = iy;
					}

					if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity > iMaxAresdenActivity) {
						iMaxAresdenActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity;
						m_pMapList[i]->m_iMaxAx = ix;
						m_pMapList[i]->m_iMaxAy = iy;
					}

					if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity > iMaxElvineActivity) {
						iMaxElvineActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity;
						m_pMapList[i]->m_iMaxEx = ix;
						m_pMapList[i]->m_iMaxEy = iy;
					}

					if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity > iMaxMonsterActivity) {
						iMaxMonsterActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity;
						m_pMapList[i]->m_iMaxMx = ix;
						m_pMapList[i]->m_iMaxMy = iy;
					}

					if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity > iMaxPlayerActivity) {
						iMaxPlayerActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity;
						m_pMapList[i]->m_iMaxPx = ix;
						m_pMapList[i]->m_iMaxPy = iy;
					}
				}

				m_pMapList[i]->ClearTempSectorInfo();

				if (m_pMapList[i]->m_iMaxNx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxNx][m_pMapList[i]->m_iMaxNy].iNeutralActivity++;
				if (m_pMapList[i]->m_iMaxAx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxAx][m_pMapList[i]->m_iMaxAy].iAresdenActivity++;
				if (m_pMapList[i]->m_iMaxEx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxEx][m_pMapList[i]->m_iMaxEy].iElvineActivity++;
				if (m_pMapList[i]->m_iMaxMx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxMx][m_pMapList[i]->m_iMaxMy].iMonsterActivity++;
				if (m_pMapList[i]->m_iMaxPx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxPx][m_pMapList[i]->m_iMaxPy].iPlayerActivity++;
		}
}


void CGame::AgingMapSectorInfo()
{
	int i, ix, iy;

	for (i = 0; i < MAXMAPS; i++) 
		if (m_pMapList[i] != NULL) {
			for (ix = 0; ix < MAXSECTORS; ix++)
				for (iy = 0; iy < MAXSECTORS; iy++) {
					m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity--;
					m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity--;
					m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity--;
					m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity--;
					m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity--;

					if (m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity = 0;
					if (m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity = 0;
					if (m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity  < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity  = 0;
					if (m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity = 0;
					if (m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity   = 0;
				}
		}
}


bool CGame::__bSetConstructionKit(int iMapIndex, int dX, int dY, int iType, int iTimeCost, int iClientH)
{
	int iNamingValue, ix, iy, tX, tY;
	char cNpcName[21], cName[21], cNpcWaypoint[11], cOwnerType;
	short sOwnerH;

	//if ((m_bIsCrusadeMode == FALSE) || (m_pClientList[iClientH]->m_iCrusadeDuty != 2)) return FALSE;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures >= MAXCRUSADESTRUCTURES) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_NOMORECRUSADESTRUCTURE, NULL, NULL, NULL, NULL);
		return FALSE;
	}

	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue == -1 || 
		!m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->IsBuild(dX,dY)) 
		return FALSE;

	if(!m_bIsCrusadeMode && !m_astoria.get())
		return FALSE;

	for (ix = dX -1; ix <= dX +1; ix++)
	{
		for (iy = dY -1; iy <= dY +1; iy++) {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
			if (sOwnerH && cOwnerType == OWNERTYPE_NPC && m_pNpcList[sOwnerH]->m_cActionLimit == 5) return FALSE;
		}
	}

	ZeroMemory(cNpcName, sizeof(cNpcName));
	switch(m_pClientList[iClientH]->m_side)
	{
	case ARESDEN:
		switch (iType) 
		{
		case 1: strcpy(cNpcName, "AGT-Aresden"); break;
		case 2: strcpy(cNpcName, "CGT-Aresden"); break;
		case 3: strcpy(cNpcName, "MS-Aresden"); break;
		case 4: strcpy(cNpcName, "DT-Aresden"); break;
		}
		break;
	case ELVINE:
		switch (iType) 
		{
		case 1: strcpy(cNpcName, "AGT-Elvine"); break;
		case 2: strcpy(cNpcName, "CGT-Elvine"); break;
		case 3: strcpy(cNpcName, "MS-Elvine"); break;
		case 4: strcpy(cNpcName, "DT-Elvine"); break;
		}
		break;
	case ISTRIA:
		switch (iType) 
		{
		case 1: strcpy(cNpcName, "AGT-Istria"); break;
		case 2: strcpy(cNpcName, "CGT-Istria"); break;
		case 3: strcpy(cNpcName, "MS-Istria"); break;
		case 4: strcpy(cNpcName, "DT-Istria"); break;
		}
		break;
	default:
		return FALSE;
	}

	ZeroMemory(cName, sizeof(cName));
	wsprintf(cName, "XX%d", iNamingValue);
	cName[0] = '_';
	cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;

	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

	tX = (int)dX;
	tY = (int)dY;
	if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, 
		MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, FALSE) == FALSE) 
	{
		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
	} 
	else {
		//wsprintf(g_cTxt, "Structure(%s) construction begin(%d,%d)!", cNpcName, tX, tY);
		//PutLogList(g_cTxt);
		return TRUE;
	}

	return FALSE;
}

void CGame::CheckCrusadeResultCalculation(int iClientH)
{	if (m_pClientList[iClientH] == NULL) return;
	if ((!m_bIsCrusadeMode) && (m_pClientList[iClientH]->m_dwCrusadeGUID != 0)) {
	//removed if (m_pClientList[iClientH]->m_iWarContribution > 300000 ) m_pClientList[iClientH]->m_iWarContribution = 300000;
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			if (m_iCrusadeWinnerSide == 0) {
				m_pClientList[iClientH]->m_iExpStock += (m_pClientList[iClientH]->m_iWarContribution*5);
				SendNotifyMsg(NULL, iClientH, NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, m_pClientList[iClientH]->m_iWarContribution, NULL);
				_bCrusadeLog(CRUSADELOG_GETEXP,iClientH,(m_pClientList[iClientH]->m_iWarContribution*5),NULL) ;
			}
			else {
				if (m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_side) {
					if (m_pClientList[iClientH]->m_iLevel <= 80) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*200;
					}
					else if (m_pClientList[iClientH]->m_iLevel <= 160) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*125;
					}
					else m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*75;
					m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iWarContribution*35;
					SendNotifyMsg(NULL, iClientH, NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, m_pClientList[iClientH]->m_iWarContribution, NULL);
					_bCrusadeLog(CRUSADELOG_GETEXP,iClientH,m_pClientList[iClientH]->m_iWarContribution*35,NULL) ;
				}else{
					if (m_pClientList[iClientH]->m_iLevel <= 80) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*200;
					}
					else if (m_pClientList[iClientH]->m_iLevel <= 160) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*125;
					}
					else m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*75;
					m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iWarContribution*5;
					SendNotifyMsg(NULL, iClientH, NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, -1*m_pClientList[iClientH]->m_iWarContribution, NULL);
					_bCrusadeLog(CRUSADELOG_GETEXP,iClientH,(m_pClientList[iClientH]->m_iWarContribution*5),NULL) ;
				}
			}
		}
		else {
			SendNotifyMsg(NULL, iClientH, NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);
		}
		m_pClientList[iClientH]->m_iCrusadeDuty     = 0;
		m_pClientList[iClientH]->m_iWarContribution = 0;
		m_pClientList[iClientH]->m_dwCrusadeGUID    = 0;
	}
}


void CGame::LocalStartCrusadeMode(DWORD dwCrusadeGUID)
{
	int i;

	if (m_bIsCrusadeMode) return;
	m_bIsCrusadeMode = TRUE;
	m_iCrusadeWinnerSide = 0;

	for(i = 0; i < MAXSIDES; i++)
	{
		m_iCollectedMana[i] = 0;
		m_mana[i] = 0;
	}

	if (dwCrusadeGUID != NULL) {
		_CreateCrusadeGUID(dwCrusadeGUID, NULL);
		m_dwCrusadeGUID = dwCrusadeGUID;
	}

	for (i = 1; i < MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			m_pClientList[i]->m_iCrusadeDuty = 0;
			m_pClientList[i]->m_iConstructionPoint = 0;
			m_pClientList[i]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			SendNotifyMsg(NULL, i, NOTIFY_CONSTRUCTIONPOINT, 0, 0, 1, NULL); // 1: Don't show to player
		
			SendNotifyMsg(NULL, i, NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[i]->m_iCrusadeDuty, NULL, NULL);
			//wsprintf(g_cTxt, "m_pClientList[i]->m_iCrusadeDuty(%d)", m_pClientList[i]->m_iCrusadeDuty);
			//PutLogList(g_cTxt);

			// Recall from enemy city if already inside when crusade begins...
			if (m_pClientList[i]->m_iAdminUserLevel == 0) {
				if (m_pClientList[i]->IsInFoeMap()) {
					m_pClientList[i]->m_bIsWarLocation = TRUE;
					m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
				}
				else if (m_pClientList[i]->IsNeutral() &&
					(memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0	|| 
					memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0 ||
					memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "middleland", 10) == 0)) {	
						m_pClientList[i]->m_bIsWarLocation = TRUE;
						m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
				}	
			}		
		}

	for (i = 0; i < MAXMAPS; i++)
		if (m_pMapList[i] != NULL) m_pMapList[i]->RestoreStrikePoints();

	CreateCrusadeStructures();
	PutLogList("(!) Crusade Mode ON.");

	_bCrusadeLog(CRUSADELOG_STARTCRUSADE,NULL,NULL,NULL) ;
}


void CGame::LocalEndCrusadeMode(int crusadeWinnerSide)
{
	int i;
	if (!m_bIsCrusadeMode) return;
	m_bIsCrusadeMode = FALSE;
	m_iCrusadeWinnerSide = crusadeWinnerSide;

	PutLogList("(!) Crusade Mode OFF.");

	KillCrusadeObjects();

	_CreateCrusadeGUID(m_dwCrusadeGUID, m_iCrusadeWinnerSide);

	for (i = 1; i < MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			m_pClientList[i]->m_iCrusadeDuty = 0;
			m_pClientList[i]->m_iConstructionPoint = 0;
			SendNotifyMsg(NULL, i, NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, NULL, NULL, m_iCrusadeWinnerSide);
		}

	if (m_iCrusadeWinnerSide == 2)
		_bCrusadeLog(CRUSADELOG_ENDCRUSADE,NULL,NULL,"Elvine Win!") ;
	else if (m_iCrusadeWinnerSide == 1)
		_bCrusadeLog(CRUSADELOG_ENDCRUSADE,NULL,NULL,"Aresden Win!") ;
	else 
		_bCrusadeLog(CRUSADELOG_ENDCRUSADE,NULL,NULL,"Drawn!") ;
}


void CGame::SaveOccupyFlagData()
{
	char * pData;
	int iSize;
	FILE * pFile;

	return;

	PutLogList("(!) Middleland OccupyFlag data saved.");

	pData = new char[1000000+1];
	if (pData == NULL) return;
	ZeroMemory(pData, 1000000);

	iSize = _iComposeFlagStatusContents(pData);

	_mkdir("GameData");

	pFile = fopen("GameData\\OccupyFlag.txt", "wt");
	if (pFile == NULL) return;

	fwrite(pData, 1, iSize, pFile);

	delete[] pData;
	fclose(pFile);
}


void CGame::CreateCrusadeStructures()
{
	int i, z, tX, tY, iNamingValue, iTotalMS, iMSIndex[100], iMSSelected[MAXCRUSADESTRUCTURES], iMSLeft;
	char cName[6], cNpcName[21], cNpcWayPoint[11];
	bool bFlag;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));


	for (i = 0; i < 100; i++) iMSIndex[i] = -1;

	iTotalMS = 0;
	for (i = 0; i < MAXCRUSADESTRUCTURES; i++) 
		if (m_stCrusadeStructures[i].cType == NPC_MANASTONE) {
			iMSIndex[iTotalMS] = i;
			iTotalMS++;
			iMSSelected[i] = -1;
		}

	if (iTotalMS <= 3) {

		iMSSelected[ iMSIndex[0] ] = 1;
		iMSSelected[ iMSIndex[1] ] = 1;
		iMSSelected[ iMSIndex[2] ] = 1;
	}
	else {
		iMSLeft = 3;
		bFlag = FALSE;
		while (bFlag == FALSE) {
			i = dice(1, iTotalMS) -1;
			if (iMSIndex[i] != -1) {
				iMSSelected[ iMSIndex[i] ] = 1;
				iMSIndex[i] = -1;
				iMSLeft--;
				if (iMSLeft <= 0) bFlag = TRUE;
			}
		}
	}


	for (i = 0; i < MAXCRUSADESTRUCTURES; i++) 
		if (m_stCrusadeStructures[i].cType != NULL) {
			for (z = 0; z < MAXMAPS; z++)
				if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, m_stCrusadeStructures[i].cMapName) == 0)) {
					iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
					if (iNamingValue == -1) {

					}
					else {
						ZeroMemory(cName, sizeof(cName));
						ZeroMemory(cNpcName, sizeof(cNpcName));


						wsprintf(cName, "XX%d", iNamingValue);
						cName[0] = '_';
						cName[1] = z+65;

						switch (m_stCrusadeStructures[i].cType) {
						case NPC_AGT:
							if (strcmp(m_pMapList[z]->m_cName, sideMap[ARESDEN]) == 0)
								strcpy(cNpcName, "AGT-Aresden");
							else if (strcmp(m_pMapList[z]->m_cName, sideMap[ELVINE]) == 0)
								strcpy(cNpcName, "AGT-Elvine");
							break;

						case NPC_CGT: 
							if (strcmp(m_pMapList[z]->m_cName, sideMap[ARESDEN]) == 0)
								strcpy(cNpcName, "CGT-Aresden");
							else if (strcmp(m_pMapList[z]->m_cName, sideMap[ELVINE]) == 0)
								strcpy(cNpcName, "CGT-Elvine");
							break;

						case NPC_ESG:
							if (strcmp(m_pMapList[z]->m_cName, sideMap[ARESDEN]) == 0)
								strcpy(cNpcName, "ESG-Aresden");
							else if (strcmp(m_pMapList[z]->m_cName, sideMap[ELVINE]) == 0)
								strcpy(cNpcName, "ESG-Elvine");
							break;

						case NPC_GMG:
							if (strcmp(m_pMapList[z]->m_cName, sideMap[ARESDEN]) == 0)
								strcpy(cNpcName, "GMG-Aresden");
							else if (strcmp(m_pMapList[z]->m_cName, sideMap[ELVINE]) == 0)
								strcpy(cNpcName, "GMG-Elvine");
							break;

						case NPC_MANASTONE:
							if (iMSSelected[i] == 1) strcpy(cNpcName, "ManaStone");
							break;

						default: 
							strcpy(cNpcName, m_npcConfigList[m_stCrusadeStructures[i].cType]->m_cNpcName); 
							break;
						}

						tX = (int)m_stCrusadeStructures[i].dX;
						tY = (int)m_stCrusadeStructures[i].dY;
						if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, MOVETYPE_RANDOM, 
							&tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE) == FALSE) {
								m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
						} 
						else {
							wsprintf(g_cTxt, "(!) Creating Crusade Structure(%s) at %s(%d, %d)", cNpcName, m_stCrusadeStructures[i].cMapName, tX, tY);
							PutLogList(g_cTxt);
						}
					}
					break;
				}
		}
}


void CGame::SendCollectedMana()
{
	char * cp, cData[120];
	WORD * wp;
	if (!m_bIsCrusadeMode) return;
	
	if ((m_iCollectedMana[1] == 0) && m_iCollectedMana[2] == 0) return;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);
	*cp = GSM_COLLECTEDMANA;
	cp++;

	wp = (WORD *)cp;
	*wp = (WORD)m_iCollectedMana[1];
	cp += 2;

	wp = (WORD *)cp;
	*wp = (WORD)m_iCollectedMana[2];
	cp += 2;

	m_mana[ARESDEN] += m_iCollectedMana[1];
	m_mana[ELVINE] += m_iCollectedMana[2];
	bStockMsgToGateServer(cData, 5);

	m_iCollectedMana[0] = 0;
	m_iCollectedMana[1] = 0;
	m_iCollectedMana[2] = 0;
}


void CGame::MeteorStrikeMsgHandler(char cAttackerSide)
{
	int i;
	DWORD dwTime = timeGetTime();

	if (!m_bIsCrusadeMode) return;
	switch (cAttackerSide) {
	case 1:
		if (m_iElvineMapIndex != -1) {
			for (i = 1; i < MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "elvine") == 0) {
					SendNotifyMsg(NULL, i, NOTIFY_METEORSTRIKECOMING, 1, NULL, NULL, NULL);
				}
				else {
					SendNotifyMsg(NULL, i, NOTIFY_METEORSTRIKECOMING, 2, NULL, NULL, NULL);
				}
			}
			RegisterDelayEvent(DELAYEVENTTYPE_METEORSTRIKE, NULL, dwTime + 5000, NULL, NULL, m_iElvineMapIndex, NULL, NULL, NULL, NULL, NULL);
		}
		else {
			for (i = 1; i < MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				SendNotifyMsg(NULL, i, NOTIFY_METEORSTRIKECOMING, 2, NULL, NULL, NULL);
			}
		}
		break;

	case 2:
		if (m_iAresdenMapIndex != -1) {
			for (i = 1; i < MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "aresden") == 0) {
					SendNotifyMsg(NULL, i, NOTIFY_METEORSTRIKECOMING, 3, NULL, NULL, NULL);
				}
				else {
					SendNotifyMsg(NULL, i, NOTIFY_METEORSTRIKECOMING, 4, NULL, NULL, NULL);
				}
			}
			RegisterDelayEvent(DELAYEVENTTYPE_METEORSTRIKE, NULL, dwTime + 1000*5, NULL, NULL, m_iAresdenMapIndex, NULL, NULL, NULL, NULL, NULL);
		}
		else {
			for (i = 1; i < MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				SendNotifyMsg(NULL, i, NOTIFY_METEORSTRIKECOMING, 4, NULL, NULL, NULL);
			}
		}
		break;
	}
}

void CGame::_LinkStrikePointMapIndex()
{
	int i, z, x;

	for (i = 0; i < MAXMAPS; i++)
		if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_iTotalStrikePoints != 0)) {
			for (z = 0; z < MAXSTRIKEPOINTS; z++) 
				if (strlen(m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) != 0) {
					for (x = 0; x < MAXMAPS; x++) 
						if ((m_pMapList[x] != NULL) && (strcmp(m_pMapList[x]->m_cName,m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) == 0)) {
							m_pMapList[i]->m_stStrikePoint[z].iMapIndex = x;
							//testcode
							wsprintf(g_cTxt, "(!) Map(%s) Strike Point(%d) Related Map(%s) Index(%d)", m_pMapList[i]->m_cName, z, m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName, x);
							PutLogList(g_cTxt);

							break;
						}
				}
		}
}

void CGame::MeteorStrikeHandler(int iMapIndex)
{
	int i, ix, iy, dX, dY, iIndex, iTargetIndex, iTotalESG, iEffect;
	int iTargetArray[MAXSTRIKEPOINTS];
	short sOwnerH;
	char  cOwnerType, G_cTxt[120];
	DWORD dwTime = timeGetTime();
	
	if (!m_bIsCrusadeMode) return;
	PutLogList("(!) Beginning Meteor Strike Procedure...");
	if (iMapIndex == -1) 
	{	PutLogList("(X) MeteorStrikeHandler Error! MapIndex -1!");
		return;
	}	
	if (m_pMapList[iMapIndex] == NULL) 
	{	PutLogList("(X) MeteorStrikeHandler Error! NULL Map!");
		return;
	}	
	if (m_pMapList[iMapIndex]->m_iTotalStrikePoints == 0) 
	{	PutLogList("(X) MeteorStrikeHandler Error! No Strike Points!");
		return;
	}	
	for (i = 0; i < MAXSTRIKEPOINTS; i++) iTargetArray[i] = -1;

	iIndex = 0;
	for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) 
	{	if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) 
		{	iTargetArray[iIndex] = i; 
			iIndex++;
		}
	}
	wsprintf(G_cTxt, "(!) Map(%s) has %d available strike points", m_pMapList[iMapIndex]->m_cName, iIndex);
	PutLogList(G_cTxt);

	m_stMeteorStrikeResult.iCasualties            = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum   = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;

	if (iIndex == 0) 
	{	PutLogList("(!) No strike points!");
		RegisterDelayEvent(DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, NULL, dwTime + 6000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
	}else 
	{	for (i = 1; i < MAXCLIENTS; i++)
		{	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) 
			{	SendNotifyMsg(NULL, i, NOTIFY_METEORSTRIKEHIT, NULL, NULL, NULL, NULL);
			}
		}
		for (i = 0; i < iIndex; i++) 
		{	iTargetIndex = iTargetArray[i];
			if (iTargetIndex == -1) 
			{	PutLogList("(X) Strike Point MapIndex: -1!");
				goto MSH_SKIP_STRIKE;
			}
			dX = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dX;
			dY = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dY;
			iTotalESG = 0;
			for (ix = dX-30; ix <= dX+30; ix++) 
			for (iy = dY-30; iy <= dY+30; iy++) {
				m_pMapList[iMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ((cOwnerType == OWNERTYPE_NPC) && (m_pNpcList[sOwnerH] != NULL) && (m_pNpcList[sOwnerH]->m_sType == NPC_ESG)) {
					iTotalESG++;
				}
			}			
			wsprintf(G_cTxt, "(!) Meteor Strike Target(%d, %d) ESG(%d)", dX, dY, iTotalESG);
			PutLogList(G_cTxt);
		if (iTotalESG < 2) 
			{	m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP -= (dice(1,3) - iTotalESG);//(2 - iTotalESG);
				if (m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP <= 0) 
				{	m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP = 0;
					// Should have been a way to prevent people to go in destructed building, never implemented
					m_pMapList[m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iMapIndex]->m_bIsDisabled = TRUE;
					m_stMeteorStrikeResult.iCrashedStructureNum++;
				}else 
				{	m_stMeteorStrikeResult.iStructureDamageAmount += (dice(1,3) - iTotalESG);// (2 - iTotalESG);
					iEffect = dice(1,5)-1;
					iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_FIRE2, iMapIndex, 
					                  m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectX[iEffect] +(dice(1,3) -2), 
									  m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectY[iEffect] +(dice(1,3) -2), 60*1000*50);
				}
			}
MSH_SKIP_STRIKE:;
		}
		RegisterDelayEvent(DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, NULL, dwTime + 1000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
		RegisterDelayEvent(DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, NULL, dwTime + 3000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
		RegisterDelayEvent(DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, NULL, dwTime + 5000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
		RegisterDelayEvent(DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, NULL, dwTime + 7000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
	}
}

void CGame::RequestSetGuildTeleportLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char * pMapName)
{
	char * cp, cData[120];
	register int i;
	int *ip, iIndex;
	DWORD dwTemp, dwTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (!m_bIsCrusadeMode) return;

	if (dY < 100) dY = 100;
	if (dY > 600) dY = 600;


	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_SETGUILDTELEPORTLOC;
	cp++;

	ip = (int *)cp;
	*ip = iGuildGUID;
	cp += 4;

	ip = (int *)cp;
	*ip = dX;
	cp += 4;

	ip = (int *)cp;
	*ip = dY;
	cp += 4;

	memcpy(cp, pMapName, 10);
	cp += 10;
	//

	dwTime = timeGetTime();

	//testcode
	wsprintf(g_cTxt, "SetGuildTeleportLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(g_cTxt);

	for (i = 0; i < MAXGUILDS; i++)
		if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
			if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) {

				m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				return;
			}
			else {

				m_pGuildTeleportLoc[i].m_sDestX = dX;
				m_pGuildTeleportLoc[i].m_sDestY = dY;
				ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
				strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
				m_pGuildTeleportLoc[i].m_dwTime = dwTime;


				bStockMsgToGateServer(cData, 23);
				return;
			}
		}

		dwTemp = 0;
		iIndex = -1;
		for (i = 0; i < MAXGUILDS; i++) {
			if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {

				m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
				m_pGuildTeleportLoc[i].m_sDestX = dX;
				m_pGuildTeleportLoc[i].m_sDestY = dY;
				ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
				strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
				m_pGuildTeleportLoc[i].m_dwTime = dwTime;


				bStockMsgToGateServer(cData, 23);
				return;
			}
			else {

				if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) {
					dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
					iIndex = i;
				}
			}
		}


		if (iIndex == -1) return;

		//testcode
		PutLogList("(X) No more GuildTeleportLoc Space! Replaced.");

		m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
		m_pGuildTeleportLoc[i].m_sDestX = dX;
		m_pGuildTeleportLoc[i].m_sDestY = dY;
		ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
		strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
		m_pGuildTeleportLoc[i].m_dwTime = dwTime;


		bStockMsgToGateServer(cData, 23);
}

void CGame::RequestGuildTeleportHandler(int iClientH)
{	
	int i;
	char cMapName[11];

	if (m_pClientList[iClientH] == NULL) return;
	if (!m_bIsCrusadeMode) return;
	if (m_pClientList[iClientH]->m_iLockedMapTime != NULL) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, NULL, NULL, m_pClientList[iClientH]->m_cLockedMapName);
		return;
	}
	if (m_pClientList[iClientH]->IsInFoeMap()) return;
	for (i = 0; i < MAXGUILDS; i++) 
		if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) {
			ZeroMemory(cMapName, sizeof(cMapName));
			strcpy(cMapName, m_pGuildTeleportLoc[i].m_cDestMapName);
			RequestTeleportHandler(iClientH, 2, cMapName, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY);
			return;
		}
}

void CGame::RequestSetGuildConstructLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char * pMapName)
{
	char * cp, cData[120];
	register int i;
	int *ip, iIndex;
	DWORD dwTemp, dwTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (!m_bIsCrusadeMode) return;
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_SETGUILDCONSTRUCTLOC;
	cp++;

	ip = (int *)cp;
	*ip = iGuildGUID;
	cp += 4;

	ip = (int *)cp;
	*ip = dX;
	cp += 4;

	ip = (int *)cp;
	*ip = dY;
	cp += 4;

	memcpy(cp, pMapName, 10);
	cp += 10;
	
	dwTime = timeGetTime();

	for (i = 0; i < MAXGUILDS; i++)
		if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
			if ((m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) {
				m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				return;
			} else  {
				m_pGuildTeleportLoc[i].m_sDestX2 = dX;
				m_pGuildTeleportLoc[i].m_sDestY2 = dY;
				ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
				strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
				m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				bStockMsgToGateServer(cData, 23);
				return;
			}
		}
		dwTemp = 0;
		iIndex = -1;
		for (i = 0; i < MAXGUILDS; i++) {
			if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
				m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
				m_pGuildTeleportLoc[i].m_sDestX2 = dX;
				m_pGuildTeleportLoc[i].m_sDestY2 = dY;
				ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
				strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
				m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				bStockMsgToGateServer(cData, 23);
				return;
			}
			else {
				if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) {
					dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
					iIndex = i;
				}
			}
		}
	if (iIndex == -1) return;
	PutLogList("(X) No more GuildConstructLoc Space! Replaced.");
	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX2 = dX;
	m_pGuildTeleportLoc[i].m_sDestY2 = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
	bStockMsgToGateServer(cData, 23);
}
void CGame::RequestSummonWarUnitHandler(int iClientH, int dX, int dY, char cType, char cNum, char cMode)
{
	char cName[6], cNpcName[21], cMapName[11], cNpcWayPoint[11], cOwnerType;
	register int i, x;
	int iNamingValue, tX, tY, ix, iy;
	bool bRet;
	short sOwnerH;
	DWORD dwTime = timeGetTime();

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (!m_bIsCrusadeMode) return;

	ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cMapName, sizeof(cMapName));

	if (cType < 0) return;
	if (cType >= MAXNPCTYPES) return;
	if (cNum  >  10) return;

	if (m_pClientList[iClientH]->m_iConstructionPoint < m_iNpcConstructionPoint[cType]) return;
	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE)) return; 

	cNum = 1;
	for (x = 1; x <= cNum; x++) {

		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue == -1) {
		}
		else {
			ZeroMemory(cName, sizeof(cName));
			wsprintf(cName, "XX%d", iNamingValue);
			cName[0] = '_';
			cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
			switch (cType) {
			case NPC_LWB: // Light War Beetle
				switch (m_pClientList[iClientH]->m_side) {
				case 1: strcpy(cNpcName, "LWB-Aresden"); break;
				case 2: strcpy(cNpcName, "LWB-Elvine"); break;
				}
				break;

			case NPC_AGT: // Arrow Guard Tower
				switch (m_pClientList[iClientH]->m_side) {
				case 1: strcpy(cNpcName, "AGT-Aresden"); break;
				case 2: strcpy(cNpcName, "AGT-Elvine"); break;
				}
				break;

			case NPC_CGT: // Cannon Guard Tower
				switch (m_pClientList[iClientH]->m_side) {
				case 1: strcpy(cNpcName, "CGT-Aresden"); break;
				case 2: strcpy(cNpcName, "CGT-Elvine"); break;
				}
				break;

			case NPC_MS: // Mana Collector
				switch (m_pClientList[iClientH]->m_side) {
				case 1: strcpy(cNpcName, "MS-Aresden"); break;
				case 2: strcpy(cNpcName, "MS-Elvine"); break;
				}
				break;

			case NPC_DT: // Detector
				switch (m_pClientList[iClientH]->m_side) {
				case 1: strcpy(cNpcName, "DT-Aresden"); break;
				case 2: strcpy(cNpcName, "DT-Elvine"); break;
				}
				break;

			case NPC_CP: // Catapult
				switch (m_pClientList[iClientH]->m_side) {
				case 1: strcpy(cNpcName, "CP-Aresden"); break;
				case 2: strcpy(cNpcName, "CP-Elvine"); break;
				}
				break;

			case NPC_GHK:
				strcpy(cNpcName, "GHK");
				break;

			case NPC_GHKABS:
				strcpy(cNpcName, "GHKABS");
				break;

			case NPC_TK:
				strcpy(cNpcName, "TK");
				break;

			case NPC_BG:
				strcpy(cNpcName, "BG");
				break;
			}
			wsprintf(g_cTxt, "(!) Request Summon War Unit (%d) (%s)", cType, cNpcName);
			PutLogList(g_cTxt);

			tX = (int)dX;
			tY = (int)dY;

			bRet = FALSE;
			switch (cType) {
			case NPC_AGT:
			case NPC_CGT:
			case NPC_MS:
			case NPC_DT:
				if (strcmp(m_pClientList[iClientH]->m_cConstructMapName, m_pClientList[iClientH]->m_cMapName) != 0) bRet = TRUE;
				if (abs(m_pClientList[iClientH]->m_sX - m_pClientList[iClientH]->m_iConstructLocX) > 10) bRet = TRUE;
				if (abs(m_pClientList[iClientH]->m_sY - m_pClientList[iClientH]->m_iConstructLocY) > 10) bRet = TRUE;

				if (bRet == TRUE) {
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
					SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTCONSTRUCT, 2, NULL, NULL, NULL);
					return;
				}
				for (i = 0; i < MAXGUILDS; i++) 
					if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) {
						m_pGuildTeleportLoc[i].m_dwTime = dwTime;
						if (m_pGuildTeleportLoc[i].m_iV2 >= MAXCONSTRUCTNUM) {
							m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
							SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);
							return;
						}
						else {
							m_pGuildTeleportLoc[i].m_iV2++;
							goto RSWU_LOOPBREAK;
						}
					}
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);
				return;
				break;

			case NPC_LWB:
			case NPC_GHK:
			case NPC_GHKABS:
			case NPC_TK:
			case NPC_BG:
			case NPC_CP:
				for (i = 0; i < MAXGUILDS; i++) 
					if (m_pGuildTeleportLoc[i].m_iNumSummonNpc >= MAX_CRUSADESUMMONMOB) {
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
						SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTCONSTRUCT, 4, NULL, NULL, NULL);
						return;
					} else {
						m_pGuildTeleportLoc[i].m_iNumSummonNpc ++;
						goto RSWU_LOOPBREAK;
					}
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);
				return;
				break;
			}
RSWU_LOOPBREAK:;
			bRet = FALSE;
			switch (cType) {
			case NPC_AGT:
			case NPC_CGT:
				for (ix = tX-2; ix <= tX+2; ix++)
					for (iy = tY-2; iy <= tY+2; iy++) {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((sOwnerH != NULL) && (cOwnerType == OWNERTYPE_NPC)) {
							switch (m_pNpcList[sOwnerH]->m_sType) {
							case NPC_AGT:
							case NPC_CGT:
								bRet = TRUE;
								break;
							}
						}
					}
				if ((dY <= 32) || (dY >= 783)) bRet = TRUE;
				break;
			}
			if (bRet == TRUE) {
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTCONSTRUCT, 1, NULL, NULL, NULL);
				return;
			}
			if (cMode == NULL) {
				bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, MOVETYPE_FOLLOW, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE, FALSE, FALSE, FALSE, m_pClientList[iClientH]->m_iGuildGUID);
				bSetNpcFollowMode(cName, m_pClientList[iClientH]->m_cCharName, OWNERTYPE_PLAYER);
			}
			else bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, MOVETYPE_GUARD, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE, FALSE, FALSE, FALSE, m_pClientList[iClientH]->m_iGuildGUID);
			if (bRet == FALSE) {
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
			} 
			else {
				m_pClientList[iClientH]->m_iConstructionPoint -= m_iNpcConstructionPoint[cType];
				if (m_pClientList[iClientH]->m_iConstructionPoint < 0) m_pClientList[iClientH]->m_iConstructionPoint = 0;
				SendNotifyMsg(NULL, iClientH, NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, NULL, NULL);
			}
		}
	}
}


void CGame::CheckConnectionHandler(int iClientH, char *pData)
{
	char * cp;
	DWORD * dwp, dwTimeRcv, dwTime, dwTimeGapClient, dwTimeGapServer;

	if (m_pClientList[iClientH] == NULL) return;

	dwTime = timeGetTime();
	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	dwp = (DWORD *)cp;
	dwTimeRcv = *dwp;

	if (m_pClientList[iClientH]->m_dwInitCCTimeRcv == NULL) {
		m_pClientList[iClientH]->m_dwInitCCTimeRcv = dwTimeRcv;
		m_pClientList[iClientH]->m_dwInitCCTime = dwTime;
	}
	else {
		dwTimeGapClient = (dwTimeRcv - m_pClientList[iClientH]->m_dwInitCCTimeRcv);
		dwTimeGapServer = (dwTime - m_pClientList[iClientH]->m_dwInitCCTime);

		if (dwTimeGapClient < dwTimeGapServer) return;

		if (abs((int)(dwTimeGapClient - dwTimeGapServer)) >= CLIENTTIMEOUT) {

			wsprintf(g_cTxt, "(!) Client(%s) Timeout/Hack %u %u %u %u %u %u Time gap %u", m_pClientList[iClientH]->m_cCharName, dwTimeRcv, m_pClientList[iClientH]->m_dwInitCCTimeRcv, dwTime, m_pClientList[iClientH]->m_dwInitCCTime,dwTimeGapClient,dwTimeGapServer,   dwTimeGapClient - dwTimeGapServer );
			PutLogList(g_cTxt);
			PutLogFileList(g_cTxt);
			/*
			SYSTEMTIME SysTime;
			GetLocalTime(&SysTime);

			m_pClientList[iClientH]->m_iPenaltyBlockYear  = SysTime.wYear+1;
			m_pClientList[iClientH]->m_iPenaltyBlockMonth = SysTime.wMonth;
			m_pClientList[iClientH]->m_iPenaltyBlockDay   = SysTime.wDay;
			*/
			DeleteClient(iClientH, TRUE, TRUE, TRUE, TRUE);
			return;
		}
	}

	if (m_pClientList[iClientH]->m_bIsManager == TRUE) {
		char cTemp[256] ;
		short * sp ; 
		WORD * wp ;

		cp += 4;
		memcpy(cTemp, cp, 10);
		cp += 10;

		if (memcmp(cTemp,"?BWordMtr?",10) != 0) return ;

		ZeroMemory(cTemp, sizeof(cTemp));

		dwp = (DWORD *)cTemp;
		*dwp = MSGID_RESPONSE_CHECKCONNECTION;

		wp  = (WORD *)(cTemp + INDEX2_MSGTYPE);
		*wp = NULL;

		cp  = (char *)(cTemp + INDEX2_MSGTYPE + 2);
		sp  = (short *)cp;

		if ((m_bIsGameStarted == TRUE) && (m_bIsItemAvailable == TRUE) && 
			(m_bIsNpcAvailable == TRUE) && (m_bIsMagicAvailable == TRUE) &&
			(m_bIsSkillAvailable == TRUE) && (m_bIsPotionAvailable == TRUE) &&
			(m_bIsQuestAvailable == TRUE)
			) {

				*sp =  1 ; 
		} 
		else 
		{
			*sp =  0 ; 
		}
		cp += 2 ;

		sp  = (short *)cp;
		*sp = m_iTotalClients ;
		cp += 2 ;

		sp  = (short *)cp;
		*sp = m_iMaxClients ;
		cp += 2 ;

		sp  = (short *)cp;
		*sp = m_iTotalGameServerClients ;
		cp += 2 ;

		sp  = (short *)cp;
		*sp = m_iTotalGameServerMaxClients ;
		cp += 2 ;

		m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, 16 );

	}

}
BOOL CGame::bActionOnWrongCRC(int iClientH, int iReason, int iValue)
{	
	char G_cTxt[250];
	BOOL bIsHosterTesting = FALSE;
	if (m_iGameServerMode == 1)			// ROUTER mode
	{	if (   (strcmp(m_pClientList[iClientH]->m_cIPaddress, m_cLogServerAddrExternal) == 0)
			|| (strcmp(m_pClientList[iClientH]->m_cIPaddress, m_cGameServerAddr) == 0))
		{	// server & client share same external IP
			bIsHosterTesting = TRUE;
		}
	}else if  ( (m_iGameServerMode == 2)	// INTERNET mode
			&& (strcmp(m_pClientList[iClientH]->m_cIPaddress, m_cGameServerAddr) == 0))
	{	// server & client have exactelly same IP
		bIsHosterTesting = TRUE;
	}
	if (bIsHosterTesting == TRUE)
	{	/*wsprintf(G_cTxt, "Checksum error Reason: %d, Code: 0x%04."
			, iReason
			, iValue);
		ShowClientMsg(iClientH, "AntiHACK", G_cTxt );*/
		return(FALSE);
	}

	return(FALSE);
}

void CGame::SelectCrusadeDutyHandler(int iClientH, int iDuty)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (!m_bIsCrusadeMode) return;
	if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (iDuty == 3)) return;

	if( m_iCrusadeWinnerSide != m_pClientList[iClientH]->m_side &&
		m_pClientList[iClientH]->m_iGuildRank == 0 && iDuty == 3)
	{
		m_pClientList[iClientH]->m_iConstructionPoint = 3000;
	}
	m_pClientList[iClientH]->m_iCrusadeDuty = iDuty;
	SendNotifyMsg(NULL, iClientH, NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
	if (iDuty == 1) 
		_bCrusadeLog(CRUSADELOG_SELECTDUTY, iClientH, NULL, "Fighter");
	else if (iDuty == 2) 
		_bCrusadeLog(CRUSADELOG_SELECTDUTY, iClientH, NULL, "Constructor");
	else
		_bCrusadeLog(CRUSADELOG_SELECTDUTY, iClientH, NULL, "Commander");
}


void CGame::MapStatusHandler(int iClientH, int iMode, char * pMapName)
{
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iCrusadeDuty == NULL) return;//add in

	switch (iMode) {
	case 1:
		//if (m_pClientList[iClientH]->m_iCrusadeDuty == NULL) return;

		for (i = 0; i < MAXGUILDS; i++) 
			if ((m_pGuildTeleportLoc[i].m_iV1 != NULL) && (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID)) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_TCLOC, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY,
					NULL, m_pGuildTeleportLoc[i].m_cDestMapName, m_pGuildTeleportLoc[i].m_sDestX2, m_pGuildTeleportLoc[i].m_sDestY2,
					NULL, NULL, NULL, NULL, m_pGuildTeleportLoc[i].m_cDestMapName2);

				ZeroMemory(m_pClientList[iClientH]->m_cConstructMapName, sizeof(m_pClientList[iClientH]->m_cConstructMapName));
				memcpy(m_pClientList[iClientH]->m_cConstructMapName, m_pGuildTeleportLoc[i].m_cDestMapName2, 10);
				m_pClientList[iClientH]->m_iConstructLocX = m_pGuildTeleportLoc[i].m_sDestX2;
				m_pClientList[iClientH]->m_iConstructLocY = m_pGuildTeleportLoc[i].m_sDestY2;
				return;
			}

			break;

	case 3:
		
		for (i = 0; i < MAXCRUSADESTRUCTURES; i++) {
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = NULL;
		}
		m_pClientList[iClientH]->m_iCSIsendPoint = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cSendingMapName, sizeof(m_pClientList[iClientH]->m_cSendingMapName));

		if (strcmp(pMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName) == 0) {
			for (i = 0; i < m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures; i++) {
				if ( m_pClientList[iClientH]->m_iCrusadeDuty == 3) 
				{
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
				}
				else if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType == 42) 
				{
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
				}
			}
			memcpy(m_pClientList[iClientH]->m_cSendingMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 10);
		}
		else {
			if (strcmp(pMapName, "middleland") == 0) {
				for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
					if ( m_pClientList[iClientH]->m_iCrusadeDuty == 3) 
					{
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_stMiddleCrusadeStructureInfo[i].sX;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_stMiddleCrusadeStructureInfo[i].sY;
					}
					else if (m_stMiddleCrusadeStructureInfo[i].cType == 42)
					{
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_stMiddleCrusadeStructureInfo[i].sX;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_stMiddleCrusadeStructureInfo[i].sY;
					}
				}
				strcpy(m_pClientList[iClientH]->m_cSendingMapName, "middleland");
			}
			else {

			}
		}
		_SendMapStatus(iClientH);
		break;
	}
}


void CGame::_SendMapStatus(int iClientH)
{
	register int i, iDataSize;
	char *cp, cData[MAXCRUSADESTRUCTURES*6];
	short * sp;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);

	memcpy(cp, m_pClientList[iClientH]->m_cSendingMapName, 10);
	cp += 10;

	sp = (short *)cp;
	*sp = (short)m_pClientList[iClientH]->m_iCSIsendPoint;
	cp += 2;

	cp++;

	if (m_pClientList[iClientH]->m_iCSIsendPoint == NULL)
		m_pClientList[iClientH]->m_bIsSendingMapStatus = TRUE;

	iDataSize = 0;
	for (i = 0 ; i < 100; i++) {
		if (m_pClientList[iClientH]->m_iCSIsendPoint >= MAXCRUSADESTRUCTURES) goto SMS_ENDOFDATA;
		if (m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType == NULL) goto SMS_ENDOFDATA;

		if ((m_pClientList[iClientH]->m_iCSIsendPoint >= 3) && (m_pClientList[iClientH]->m_iCrusadeDuty != 3) )  goto SMS_ENDOFDATA;
		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType;
		cp++;
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sX;
		cp += 2;
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sY;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cSide;
		cp++;

		iDataSize += 6;
		m_pClientList[iClientH]->m_iCSIsendPoint++;
	}

	cp = (char *)(cData + 12);
	*cp = (iDataSize/6);
	SendNotifyMsg(NULL, iClientH, NOTIFY_MAPSTATUSNEXT, iDataSize +13, NULL, NULL, cData);
	return;

SMS_ENDOFDATA:;

	cp = (char *)(cData + 12);
	*cp = (iDataSize/6);
	SendNotifyMsg(NULL, iClientH, NOTIFY_MAPSTATUSLAST, iDataSize +13, NULL, NULL, cData);
	m_pClientList[iClientH]->m_bIsSendingMapStatus = FALSE;

	return;
}




void CGame::RequestHelpHandler(int iClientH)
{
	register int i;
	if (!m_bIsCrusadeMode) return;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iGuildRank == -1) return;
	if (m_pClientList[iClientH]->m_iCrusadeDuty != 1) return;

	for (i = 1; i < MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildRank == 0) && 
			(m_pClientList[i]->m_iCrusadeDuty == 3) && (m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) {

				SendNotifyMsg(NULL, i, NOTIFY_HELP, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_iHP, m_pClientList[iClientH]->m_cCharName);
				return;
		}

	SendNotifyMsg(NULL, iClientH, NOTIFY_HELPFAILED, NULL, NULL, NULL, NULL);
}



bool CGame::bStockMsgToGateServer(char *pData, DWORD dwSize)
{
	char * cp;

	//testcode
	//wsprintf(g_cTxt, "StockMsg(%d) Size(%d)", *pData, dwSize);
	//PutLogList(g_cTxt);

	if ((m_iIndexGSS + dwSize) >= MAXGATESERVERSTOCKMSGSIZE-10) return FALSE;

	cp = (char *)(m_cGateServerStockMsg + m_iIndexGSS);
	memcpy(cp, pData, dwSize);

	m_iIndexGSS += dwSize;

	return TRUE;
}


void CGame::SendStockMsgToGateServer()
{
	DWORD * dwp;
	WORD * wp;
	char * cp;

	if (m_iIndexGSS > 6) {
		bSendMsgToLS(MSGID_SERVERSTOCKMSG, NULL, FALSE, m_cGateServerStockMsg);

		ZeroMemory(m_cGateServerStockMsg, sizeof(m_cGateServerStockMsg));
		cp = (char *)m_cGateServerStockMsg;
		dwp = (DWORD *)cp;
		*dwp = MSGID_SERVERSTOCKMSG;
		cp += 4;
		wp = (WORD *)cp;
		*wp = MSGTYPE_CONFIRM;
		cp += 2;

		m_iIndexGSS = 6;
	}
}


void CGame::ServerStockMsgHandler(char *pData)
{
	char * cp, cTemp[120], cTemp2[120], cTemp3[120], cName[11], cBuffer[256];
	short * sp ;
	WORD * wp, wServerID, wClientH, wV1, wV2, wV3, wV4 , wV5;
	DWORD * dwp;
	bool bFlag = FALSE;
	int * ip, i, iTotal, iV1, iV2, iV3, iRet;

	iTotal = 0;
	cp = (char *)(pData + 6);
	while (bFlag == FALSE) {
		iTotal++;
		switch (*cp) {
		case GSM_DISCONNECT:
			ZeroMemory(cName, sizeof(cName));
			cp++;
			memcpy(cName, cp, 10);
			cp += 10;

			for (i = 1; i < MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iWhisperPlayerIndex != -1) && (strcmp(m_pClientList[i]->m_cWhisperPlayerName, cName) == 0)) {
					m_pClientList[i]->m_iWhisperPlayerIndex = -1;
					SendNotifyMsg(NULL, i, NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, cName);
					goto SSMH_LOOPBREAK; 
				}
				break;

		case GSM_WHISPERMSG:
			ZeroMemory(cName, sizeof(cName));
			ZeroMemory(cBuffer, sizeof(cBuffer));
			cp++;
			memcpy(cName, cp, 10);
			cp += 10;
			wp = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			memcpy(cBuffer, cp, wV1);
			cp += wV1;

			for (i = 1; i < MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cBuffer, wV1);
					if(	m_pClientList[i]->m_iAdminUserLevel > 0) {
						char cTxt[200],cTmpName[12] ;
						ZeroMemory(cTxt,sizeof(cTxt)) ;
						ZeroMemory(cTmpName,sizeof(cTmpName)) ;

						memcpy(cTmpName,cBuffer+10,10) ;
						wsprintf(cTxt,"PC Chat(%s):\"%s\"\tto GM(%s)",cTmpName,cBuffer+21,m_pClientList[i]->m_cCharName) ;
						bSendMsgToLS(MSGID_GAMEMASTERLOG, i, NULL, cTxt);
					}
					break;
				}

				break;

		case GSM_CHATMSG:
			cp++;
			ZeroMemory(cTemp, sizeof(cTemp));
			ZeroMemory(cName, sizeof(cName));
			iV1 = *cp;
			cp++;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			memcpy(cName, cp, 10);
			cp += 10;;
			sp = (short *)cp;
			wV1 = (WORD)*sp;
			cp += 2;
			ChatMsgHandlerGSM(iV1, iV2, cName, cp, wV1);
			cp += wV1;
			break;

		case GSM_CONSTRUCTIONPOINT:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			GSM_ConstructionPoint(iV1, iV2);
			break;

		case GSM_SETGUILDTELEPORTLOC:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV3 = *ip;
			cp += 4;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			GSM_SetGuildTeleportLoc(iV1, iV2, iV3, cTemp);
			break;

		case GSM_SETGUILDCONSTRUCTLOC:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV3 = *ip;
			cp += 4;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			GSM_SetGuildConstructLoc(iV1, iV2, iV3, cTemp);
			break;

		case GSM_MIDDLEMAPSTATUS:
			cp++;
			for (i = 0; i < MAXCRUSADESTRUCTURES; i++) {
				m_stMiddleCrusadeStructureInfo[i].cType = NULL;
				m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
				m_stMiddleCrusadeStructureInfo[i].sX    = NULL;
				m_stMiddleCrusadeStructureInfo[i].sY    = NULL;
			}
			sp = (short *)cp;
			m_iTotalMiddleCrusadeStructures = *sp;
			cp += 2;

			for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
				m_stMiddleCrusadeStructureInfo[i].cType = *cp;
				cp++;
				m_stMiddleCrusadeStructureInfo[i].cSide = *cp;
				cp++;
				sp = (short *)cp;
				m_stMiddleCrusadeStructureInfo[i].sX = *sp;
				cp += 2;
				sp = (short *)cp;
				m_stMiddleCrusadeStructureInfo[i].sY = *sp;
				cp += 2;
			}
			break;

		case GSM_BEGINAPOCALYPSE:
			cp++;
			LocalStartApocalypse();
			break;

		case GSM_ENDAPOCALYPSE:
			cp++;
			LocalEndApocalypse();
			break;

		case GSM_BEGINCRUSADE:
			cp++;
			dwp = (DWORD *)cp;
			cp += 4;
			LocalStartCrusadeMode(*dwp);
			break;

		case GSM_ENDCRUSADE:
			cp++;
			LocalEndCrusadeMode(*cp);
			cp += 16;
			break;

		case GSM_COLLECTEDMANA:
			cp++;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			break;

		case GSM_GRANDMAGICLAUNCH:
			cp++;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;

			switch (wV1) {
				case 1: 				MeteorStrikeMsgHandler((char)wV2);
				break;
			}
			break;

		case  GSM_GRANDMAGICRESULT:
			cp++;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV3 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV4 = *wp;
			cp += 2;


			wp  = (WORD *)cp;
			wV5 = *wp;


			/*	cp++ ;


			wp  = (WORD *)cp;
			wV5 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV6 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV7 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV8 = *wp;
			cp += 2; */ 

			GrandMagicResultHandler(cTemp, wV1, wV2, wV3, wV4,wV5,cp);
			break;


		case GSM_REQUEST_SUMMONPLAYER:
			cp++;
			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;


			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;

			for (i = 1; i < MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {

#ifdef TAIWANLOG
					short sX = 0,sY = 0 ;
					char cMapName[22] ; 

					ZeroMemory(cMapName,sizeof(cMapName)) ;

					sX = m_pClientList[i]->m_sX ;
					sY = m_pClientList[i]->m_sY ;
					strcpy(cMapName, m_pClientList[i]->m_cMapName) ;

					m_pClientList[i]->m_sX = wV1;
					m_pClientList[i]->m_sY = wV2;
					strcpy(m_pClientList[i]->m_cMapName, cTemp) ;

					_bItemLog(ITEMLOG_SUMMONPLAYER, i, cTemp2,NULL) ;

					m_pClientList[i]->m_sY = sY ; 
					m_pClientList[i]->m_sX = sX ;

					strcpy(m_pClientList[i]->m_cMapName,cMapName) ;

#endif
					RequestTeleportHandler(i, 2, cTemp ,wV1, wV2);
					break;
				}
				break ;


		case GSM_REQUEST_SHUTUPPLAYER:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;

			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;

			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			GSM_RequestShutupPlayer(cTemp,wServerID,wClientH, wV1, cName);

			break ;

		case GSM_RESPONSE_SHUTUPPLAYER:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;

			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;

			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			if (wServerID == GSID) {
				if ((m_pClientList[wClientH] != NULL)&& (strcmp(m_pClientList[wClientH]->m_cCharName, cName) == 0)&&(m_pClientList[wClientH]->m_iAdminUserLevel > 0)) {
					SendNotifyMsg(NULL, wClientH, NOTIFY_PLAYERSHUTUP, wV1, NULL, NULL, cTemp);
				}
			}
			break;

		case GSM_REQUEST_FINDCHARACTER:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			ZeroMemory(cTemp2, sizeof(cTemp2));
			memcpy(cTemp2, cp, 10);
			cp += 10;

			GSM_RequestFindCharacter(wServerID, wClientH, cTemp,cTemp2);
			break;

		case GSM_RESPONSE_FINDCHARACTER:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			ZeroMemory(cTemp2, sizeof(cTemp2));
			memcpy(cTemp2, cp, 10);
			cp += 10;

			ZeroMemory(cTemp3, sizeof(cTemp3));
			memcpy(cTemp3, cp, 14);
			cp += 14;

			if (wServerID == GSID) {
				if (m_pClientList[wClientH] != NULL) {
					if ((m_pClientList[wClientH]->m_bIsCheckingWhisperPlayer == TRUE) && (strcmp(m_pClientList[wClientH]->m_cWhisperPlayerName, cTemp) == 0)) {
						m_pClientList[wClientH]->m_iWhisperPlayerIndex = 10000;
						m_pClientList[wClientH]->m_bIsCheckingWhisperPlayer = FALSE;
						SendNotifyMsg(NULL, wClientH, NOTIFY_WHISPERMODEON, NULL, NULL, NULL, m_pClientList[wClientH]->m_cWhisperPlayerName);
					}
					else{
						if (m_pClientList[wClientH]->m_iAdminUserLevel == 0) 
							ZeroMemory(cTemp3, sizeof(cTemp3));

						if (strcmp(m_pClientList[wClientH]->m_cCharName,cTemp2) == 0)
							SendNotifyMsg(NULL, wClientH, NOTIFY_PLAYERONGAME, NULL, NULL, NULL, cTemp, NULL, NULL, NULL, NULL, NULL, NULL, cTemp3);
					}
				}
			}
			break;

		case GSM_REQUEST_FINDFRIEND:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			wp = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			GSM_RequestFindFriend(wServerID, wClientH, cTemp,cp, wV1);
			cp += wV1;
			break;

		case GSM_RESPONSE_FINDFRIEND:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			ZeroMemory(cTemp2, sizeof(cTemp2));
			memcpy(cTemp2, cp, 10);
			cp += 10;

			if (wServerID == GSID)
				if (m_pClientList[wClientH] != NULL)
					if (strcmp(m_pClientList[wClientH]->m_cCharName,cTemp) == 0)
						SendNotifyMsg(NULL, wClientH, NOTIFY_FRIENDONGAME, NULL, NULL, NULL, cTemp2, NULL, NULL, NULL, NULL, NULL, NULL, "");
			break;

		case GSM_REQUEST_SETFORCERECALLTIME:
			cp++;
			wp = (WORD *)cp;
			m_sForceRecallTime = *wp;
			cp += 2;

			wsprintf(g_cTxt,"(!) GSM: Force Recall Time (%d)min",m_sForceRecallTime) ;
			PutLogList(g_cTxt) ;

		default:
			bFlag = TRUE;
			break;
		}

SSMH_LOOPBREAK:;
	}

	//testcode
	//wsprintf(g_cTxt, "(!) Total %d GSM Messages.", iTotal-1);
	//PutLogList(g_cTxt);
}

void CGame::GSM_RequestFindFriend(WORD reqServerID, WORD reqClientH, char * requesterName, char * names, WORD nameSize){
	char * cp, response[120];
	WORD * wp;
	char   seps[] = ", ";
	char   * token, friendName[11];
	register int i;

	StrTok pStrTok(new CStrTok(names, seps));
	token = pStrTok->pGet();

	for (int j = 0;token != NULL && j < 13; j++) {
		if(strlen(token) == 0) continue;
		ZeroMemory(friendName, sizeof(friendName));
		if (strlen(token) > 10)	memcpy(friendName, token, 10);
		else memcpy(friendName, token, strlen(token));

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, friendName, 10) == 0)) {
				ZeroMemory(response, sizeof(response));
				cp = (char *)(response);
				*cp = GSM_RESPONSE_FINDFRIEND;
				cp++;

				wp = (WORD *)cp;
				*wp = reqServerID;
				cp += 2;

				wp = (WORD *)cp;
				*wp = reqClientH;
				cp += 2;

				memcpy(cp, requesterName, 10);
				cp += 10;

				memcpy(cp, friendName, 10);
				cp += 10;

				bStockMsgToGateServer(response, 25);
			}
			token = pStrTok->pGet();
	}
}


void CGame::GSM_RequestShutupPlayer(char * pGMName,WORD wReqServerID, WORD wReqClientH, WORD wTime,char * pPlayer )
{
	char * cp, cTemp[120];
	WORD * wp;
	register int i;

	for (i = 1; i < MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pPlayer) == 0)) {

			ZeroMemory(cTemp, sizeof(cTemp));
			cp = (char *)(cTemp);
			*cp = GSM_RESPONSE_SHUTUPPLAYER;
			cp++;

			wp = (WORD *)cp;
			*wp = wReqServerID;
			cp += 2;

			wp = (WORD *)cp;
			*wp = wReqClientH;
			cp += 2;

			memcpy(cp, pGMName, 10);
			cp += 10;

			wp = (WORD *)cp;
			*wp = (WORD) wTime;
			cp += 2;

			memcpy(cp, pPlayer, 10);
			cp += 10;


			m_pClientList[i]->m_iTimeLeft_ShutUp = wTime*20; 

			SendNotifyMsg(NULL, i, NOTIFY_PLAYERSHUTUP, wTime, NULL, NULL, pPlayer);

#ifdef TAIWANLOG

			_bItemLog(ITEMLOG_SHUTUP,i,pGMName,NULL) ;

			// Admin Log

			wsprintf(g_cTxt, "GM Order(%s): Shutup PC(%s) (%d)Min",pGMName, 
				m_pClientList[i]->m_cCharName, wTime);

			bSendMsgToLS(MSGID_GAMEMASTERLOG, i, NULL,g_cTxt);
#endif

			bStockMsgToGateServer(cTemp, 27);
			return;
		}
}

void CGame::GSM_RequestFindCharacter(WORD wReqServerID, WORD wReqClientH, char *pName,char * cRequestCharName)
{
	char * cp, cTemp[120];
	WORD * wp;
	register int i;

	for (i = 1; i < MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pName) == 0)) {

			ZeroMemory(cTemp, sizeof(cTemp));
			cp = (char *)(cTemp);
			*cp = GSM_RESPONSE_FINDCHARACTER;
			cp++;

			wp = (WORD *)cp;
			*wp = wReqServerID;
			cp += 2;

			wp = (WORD *)cp;
			*wp = wReqClientH;
			cp += 2;

			memcpy(cp, pName, 10);
			cp += 10;

			memcpy(cp, cRequestCharName, 10);
			cp += 10;


			memcpy(cp, m_pClientList[i]->m_cMapName, 10) ;
			cp += 10 ;

			wp = (WORD *)cp;
			*wp =(WORD) m_pClientList[i]->m_sX;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD) m_pClientList[i]->m_sY;
			cp += 2;

			bStockMsgToGateServer(cTemp, 39);
			return;
		}
}

void CGame::DoMeteorStrikeDamageHandler(int iMapIndex)
{
 int i, iDamage;
 DWORD dwTime = timeGetTime();
	if (!m_bIsCrusadeMode) return;

	for (i = 1; i < MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_side != 0) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) {
		iDamage = dice(1, m_pClientList[i]->m_iLevel*3);
		if (m_pClientList[i]->m_cMagicEffectStatus[ MAGICTYPE_PROTECT ] == 2) {
			iDamage = (iDamage/2) - 2;
		}
		if (m_pClientList[i]->m_cMagicEffectStatus[ MAGICTYPE_PROTECT ] == 5) {
			iDamage = 0;
		}		
		if (m_pClientList[i]->m_iAdminUserLevel > 0) {
			iDamage = 0;
		}
		if (iDamage > 400) iDamage = 400;	
		m_pClientList[i]->m_iHP -= iDamage;
		if (m_pClientList[i]->m_iHP <= 0) {
			m_pClientList[i]->KilledHandler(NULL, NULL, iDamage);
			m_stMeteorStrikeResult.iCasualties++;
		}
		else {
			if (iDamage > 0) {
				SendNotifyMsg(NULL, i, NOTIFY_HP, NULL, NULL, NULL, NULL);
				SendEventToNearClient_TypeA(i, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTDAMAGE, iDamage, NULL, NULL);
				if (m_pClientList[i]->m_bSkillUsingStatus[19] != TRUE) {
					m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(i, OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					m_pMapList[m_pClientList[i]->m_cMapIndex]->SetOwner(i, OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
				}			
				if (m_pClientList[i]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) { // 100% unPara
					SendNotifyMsg(NULL, i, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_HOLDOBJECT, m_pClientList[i]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ], NULL, NULL);
					m_pClientList[i]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
					RemoveFromDelayEventList(i, OWNERTYPE_PLAYER, MAGICTYPE_HOLDOBJECT);
	}	}	}	}
}
void CGame::CalcMeteorStrikeEffectHandler(int iMapIndex)
{
	int i, iActiveStructure, iStructureHP[MAXSTRIKEPOINTS];
	char * cp, * cp2, cData[120], cWinnerSide, cTempData[120], G_cTxt[120];
	WORD * wp;
	if (!m_bIsCrusadeMode) return;
	for(i = 0 ; i < MAXSTRIKEPOINTS; i++)
	iStructureHP[i] = 0;
	iActiveStructure = 0;
	for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
		if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) {
			iActiveStructure++;
			iStructureHP[i] = m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP ;
		}
	}
	if (MAXSTRIKEPOINTS > 6)
	{	wsprintf(G_cTxt, "ActiveStructure:%d  MapIndex:%d Life: %d %d %d %d %d %d", iActiveStructure, iMapIndex, iStructureHP[1], iStructureHP[2], iStructureHP[3], iStructureHP[4], iStructureHP[5], iStructureHP[6]);
		PutLogList(G_cTxt);		
	}
	if (iActiveStructure == 0) {	
		if (iMapIndex == m_iAresdenMapIndex) {	
			cWinnerSide = 2;
			LocalEndCrusadeMode(2); 
		}
		else if (iMapIndex == m_iElvineMapIndex) {
			cWinnerSide = 1;
			LocalEndCrusadeMode(1); 
		}
		else {
			cWinnerSide = 0;
			LocalEndCrusadeMode(0);
		}

		ZeroMemory(cData, sizeof(cData));
		cp = (char *)(cData);
		*cp =  GSM_ENDCRUSADE;
		cp++;
		*cp = cWinnerSide;
		cp++;
		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCrashedStructureNum;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iStructureDamageAmount;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCasualties;
		cp += 2;
		memcpy(cp, m_pMapList[iMapIndex]->m_cName, 10);
		cp += 10;
		bStockMsgToGateServer(cData, 18);
	} else {	
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)(cData);
		*cp =  GSM_GRANDMAGICRESULT;
		cp++;		
		memcpy(cp, m_pMapList[iMapIndex]->m_cName, 10);
		cp += 10;
		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCrashedStructureNum;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iStructureDamageAmount;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCasualties;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD) iActiveStructure;
		cp += 2;
		ZeroMemory(cTempData, sizeof(cTempData));
		cp2 = (char *)(cTempData); 
		wp = (WORD *)cp2;
		*wp = (WORD) m_pMapList[iMapIndex]->m_iTotalStrikePoints;
		cp2 += 2;
		for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints;i++)
		{	wp = (WORD *)cp2;
			*wp = (WORD) iStructureHP[i];
			cp2 += 2;
		}
		memcpy(cp,cTempData,2*(m_pMapList[iMapIndex]->m_iTotalStrikePoints+1) ) ;
		bStockMsgToGateServer(cData, 18 + (m_pMapList[iMapIndex]->m_iTotalStrikePoints+1)*2 );
		GrandMagicResultHandler(m_pMapList[iMapIndex]->m_cName, m_stMeteorStrikeResult.iCrashedStructureNum, m_stMeteorStrikeResult.iStructureDamageAmount, m_stMeteorStrikeResult.iCasualties, iActiveStructure,m_pMapList[iMapIndex]->m_iTotalStrikePoints, cTempData);
	}
	m_stMeteorStrikeResult.iCasualties            = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum   = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;
}



void CGame::GrandMagicResultHandler(char *cMapName, int iCrashedStructureNum, int iStructureDamageAmount, int iCasualities, int iActiveStructure, int iSTcount,char * pData)
{
	int i;
	if (!m_bIsCrusadeMode) return;
	for (i = 1; i < MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			SendNotifyMsg(NULL, i, NOTIFY_GRANDMAGICRESULT, iCrashedStructureNum, iStructureDamageAmount, iCasualities, cMapName, iActiveStructure,0,0,0,0,iSTcount,pData);
		}
}

void CGame::_GrandMagicLaunchMsgSend(int iType, char cAttackerSide)
{
	char * cp, cBuff[120];
	WORD * wp;
	if (!m_bIsCrusadeMode) return;
	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_GRANDMAGICLAUNCH;
	cp++;

	wp = (WORD *)cp;
	*wp = (WORD)iType;
	cp += 2;

	wp = (WORD *)cp;
	*wp = (WORD)cAttackerSide;
	cp += 2;

	bStockMsgToGateServer(cBuff, 5);
}


void CGame::SyncMiddlelandMapInfo()
{
	int i;
	char * cp;
	short * sp;
	if (!m_bIsCrusadeMode) return;
	if (m_iMiddlelandMapIndex != -1) {
		for (i = 0; i < MAXCRUSADESTRUCTURES; i++) {
			m_stMiddleCrusadeStructureInfo[i].cType = NULL;
			m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
			m_stMiddleCrusadeStructureInfo[i].sX    = NULL;
			m_stMiddleCrusadeStructureInfo[i].sY    = NULL;
		}
		m_iTotalMiddleCrusadeStructures = m_pMapList[m_iMiddlelandMapIndex]->m_iTotalCrusadeStructures;
		ZeroMemory(G_cData50000, sizeof(G_cData50000));
		cp = (char *)G_cData50000;
		*cp = GSM_MIDDLEMAPSTATUS;
		cp++;

		sp = (short *)cp;
		*sp = (short)m_iTotalMiddleCrusadeStructures;
		cp += 2;

		for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
			m_stMiddleCrusadeStructureInfo[i].cType = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cType;
			m_stMiddleCrusadeStructureInfo[i].cSide = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cSide;
			m_stMiddleCrusadeStructureInfo[i].sX    = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sX;
			m_stMiddleCrusadeStructureInfo[i].sY    = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sY;

			*cp = m_stMiddleCrusadeStructureInfo[i].cType;
			cp++;
			*cp = m_stMiddleCrusadeStructureInfo[i].cSide;
			cp++;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sX;
			cp += 2;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sY;
			cp += 2;
		}

		if (m_iTotalMiddleCrusadeStructures != 0) {
			//testcode
			//wsprintf(g_cTxt, "m_iTotalMiddleCrusadeStructures: %d", m_iTotalMiddleCrusadeStructures);
			//PutLogList(g_cTxt);
			bStockMsgToGateServer(G_cData50000, 3 + m_iTotalMiddleCrusadeStructures*6);
		}
	}
}


void CGame::GSM_SetGuildTeleportLoc(int iGuildGUID, int dX, int dY, char * pMapName)
{
	int i, iIndex;
	DWORD dwTemp, dwTime;
	if (!m_bIsCrusadeMode) return;

	dwTime = timeGetTime();

	for (i = 0; i < MAXGUILDS; i++)
		if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
			if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) {
				m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				return;
			}
			else {
				m_pGuildTeleportLoc[i].m_sDestX = dX;
				m_pGuildTeleportLoc[i].m_sDestY = dY;
				ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
				strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
				m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				return;
			}
		}
		dwTemp = 0;
		iIndex = -1;
		for (i = 0; i < MAXGUILDS; i++) {
			if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
				m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
				m_pGuildTeleportLoc[i].m_sDestX = dX;
				m_pGuildTeleportLoc[i].m_sDestY = dY;
				ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
				strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
				m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				return;
			}
			else {
				if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) {
					dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
					iIndex = i;
				}
			}
		}
		if (iIndex == -1) return;
		m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
		m_pGuildTeleportLoc[i].m_sDestX = dX;
		m_pGuildTeleportLoc[i].m_sDestY = dY;
		ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
		strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
		m_pGuildTeleportLoc[i].m_dwTime = dwTime;
}

void CGame::GSM_SetGuildConstructLoc(int iGuildGUID, int dX, int dY, char * pMapName)
{
	int i, iIndex;
	DWORD dwTemp, dwTime;
	if (!m_bIsCrusadeMode) return;

	dwTime = timeGetTime();

	for (i = 0; i < MAXGUILDS; i++)
		if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
			if ((m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) {
				m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				return;
			}
			else {
				m_pGuildTeleportLoc[i].m_sDestX2 = dX;
				m_pGuildTeleportLoc[i].m_sDestY2 = dY;
				ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
				strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
				m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				return;
			}
		}	
		dwTemp = 0;
		iIndex = -1;
		for (i = 0; i < MAXGUILDS; i++) {
			if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
				m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
				m_pGuildTeleportLoc[i].m_sDestX2 = dX;
				m_pGuildTeleportLoc[i].m_sDestY2 = dY;
				ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
				strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
				m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				return;
			}
			else {
				if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) {
					dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
					iIndex = i;
				}
			}
		}
		if (iIndex == -1) return;
		m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
		m_pGuildTeleportLoc[i].m_sDestX2 = dX;
		m_pGuildTeleportLoc[i].m_sDestY2 = dY;
		ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
		strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
		m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
}


void CGame::GlobalStartCrusadeMode()
{
	char * cp, cData[120];
	DWORD * dwp, dwCrusadeGUID;
	SYSTEMTIME SysTime;
	if (m_bIsCrusadeMode) return;
	GetLocalTime(&SysTime);

	dwCrusadeGUID = timeGetTime();

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_BEGINCRUSADE;
	cp++;
	dwp = (DWORD *)cp;
	*dwp = dwCrusadeGUID;
	cp += 4;

	bStockMsgToGateServer(cData, 5);

	LocalStartCrusadeMode(dwCrusadeGUID);
}

void CGame::CheckCommanderConstructionPoint(int iClientH)
{
	char * cp, cData[120];
	int  * ip, i;

	if (m_pClientList[iClientH] == NULL) return;
	if (!m_bIsCrusadeMode) return;
	if (m_pClientList[iClientH]->m_iConstructionPoint <= 0) return;

	switch (m_pClientList[iClientH]->m_iCrusadeDuty) {
	case 1: 
	case 2: 
		for (i = 0; i < MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iCrusadeDuty == 3) &&
				(m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) {
					m_pClientList[i]->m_iConstructionPoint += m_pClientList[iClientH]->m_iConstructionPoint;

					m_pClientList[i]->m_iWarContribution   += (m_pClientList[iClientH]->m_iConstructionPoint / 6);

					if (m_pClientList[i]->m_iConstructionPoint > MAXCONSTRUCTIONPOINT) 
						m_pClientList[i]->m_iConstructionPoint = MAXCONSTRUCTIONPOINT;

					if (m_pClientList[i]->m_iWarContribution > MAXWARCONTRIBUTION)
						m_pClientList[i]->m_iWarContribution = MAXWARCONTRIBUTION;

					SendNotifyMsg(NULL, i, NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
					m_pClientList[iClientH]->m_iConstructionPoint = 0; 
					return;
			}


			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			*cp = GSM_CONSTRUCTIONPOINT;
			cp++;
			ip = (int*)cp;
			*ip = m_pClientList[iClientH]->m_iGuildGUID;
			cp += 4;
			ip = (int*)cp;
			*ip = m_pClientList[iClientH]->m_iConstructionPoint;
			cp += 4;
			bStockMsgToGateServer(cData, 9);

			m_pClientList[iClientH]->m_iConstructionPoint = 0; 
			break;

	case 3: 

		break;
	}
}



void CGame::GSM_ConstructionPoint(int iGuildGUID, int iPoint)
{
	int i;
	if (!m_bIsCrusadeMode) return;
	for (i = 1; i < MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iCrusadeDuty == 3) &&
			(m_pClientList[i]->m_iGuildGUID == iGuildGUID)) {

				m_pClientList[i]->m_iConstructionPoint += iPoint;
				m_pClientList[i]->m_iWarContribution   += iPoint/6;

				if (m_pClientList[i]->m_iConstructionPoint > MAXCONSTRUCTIONPOINT) 
					m_pClientList[i]->m_iConstructionPoint = MAXCONSTRUCTIONPOINT;

				if (m_pClientList[i]->m_iWarContribution > MAXWARCONTRIBUTION)
					m_pClientList[i]->m_iWarContribution = MAXWARCONTRIBUTION;

				SendNotifyMsg(NULL, i, NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
				return;
		}
}



bool CGame::bAddClientShortCut(int iClientH)
{
	int i; 

	for (i = 0; i < MAXCLIENTS; i++)
		if (m_iClientShortCut[i] == iClientH) return FALSE;

	for (i = 0; i < MAXCLIENTS; i++)
		if (m_iClientShortCut[i] == 0) {
			m_iClientShortCut[i] = iClientH;
			return TRUE;
		}

	return FALSE;
}

void CGame::RemoveClientShortCut(int iClientH)
{
	int i;

	for (i = 0; i < MAXCLIENTS+1; i++)
		if (m_iClientShortCut[i] == iClientH) {
			m_iClientShortCut[i] = 0;
			break;
		}

	for (i = 0; i < MAXCLIENTS; i++)
		if ((m_iClientShortCut[i] == 0) && (m_iClientShortCut[i+1] != 0)) {
			m_iClientShortCut[i] = m_iClientShortCut[i+1];
			m_iClientShortCut[i+1] = 0;
		}
}

void CGame::_CreateCrusadeGUID(DWORD dwCrusadeGUID, int m_iCrusadeWinnerSide)
{
	char * cp, cTxt[256], cFn[256], cTemp[1024];
	FILE * pFile;

	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));

	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn,"CrusadeGUID.Txt");

	pFile = fopen(cFn, "wt");
	if (pFile == NULL) {

		wsprintf(cTxt, "(ERROR) Cannot create CrusadeGUID(%d) file", dwCrusadeGUID);
		PutLogList(cTxt);
	}
	else {
		ZeroMemory(cTemp, sizeof(cTemp));

	///*	ZeroMemory(cTxt, sizeof(cTxt));
	//	wsprintf(cTxt, "CrusadeGUID = %d\n", dwCrusadeGUID);
	//	strcat(cTemp, cTxt);

	//	ZeroMemory(cTxt, sizeof(cTxt));
	//	wsprintf(cTxt, "winner-side = %d\n", m_iCrusadeWinnerSide);
	//	strcat(cTemp, cTxt);*/

		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);

		//wsprintf(cTxt, "(O) CrusadeGUID(%d) file created", dwCrusadeGUID);
		//PutLogList(cTxt);
	}
	if (pFile != NULL) fclose(pFile);
}


bool CGame::bReadCrusadeGUIDFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, * token, cReadMode;
	char seps[] = "= \t\n";

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {

		PutLogList("(ERROR) Cannot open CrusadeGUID file.");
		return FALSE;
	}
	else {
		//PutLogList("(*) Reading CrusadeGUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		StrTok pStrTok(new CStrTok(cp, seps));
		token = pStrTok->pGet();

		while( token != NULL )   {

			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					m_dwCrusadeGUID = atoi(token);
					//wsprintf(g_cTxt, "CrusadeGUID = %d", m_dwCrusadeGUID);
					//PutLogList(g_cTxt);
					cReadMode = 0;
					break;

				case 2:
					m_iCrusadeWinnerSide = atoi(token);
					//wsprintf(g_cTxt, "CrusadeWinnerSide = %d", m_iCrusadeWinnerSide);
					//PutLogList(g_cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "CrusadeGUID", 11) == 0) cReadMode = 1;
				if (memcmp(token, "winner-side", 11) == 0) cReadMode = 2;
			}

			token = pStrTok->pGet();
		}

		delete[] cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}




void CGame::ManualEndCrusadeMode(int m_iCrusadeWinnerSide)
{
	char * cp, cData[256];
	WORD * wp;

	if (!m_bIsCrusadeMode) return;
	LocalEndCrusadeMode(m_iCrusadeWinnerSide);

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);
	*cp =  GSM_ENDCRUSADE;
	cp++;

	*cp = (char)m_iCrusadeWinnerSide;
	cp++;

	wp  = (WORD *)cp;
	*wp = NULL;
	cp += 2;

	wp  = (WORD *)cp;
	*wp = NULL;
	cp += 2;

	wp  = (WORD *)cp;
	*wp = NULL;
	cp += 2;

	cp += 10;

	bStockMsgToGateServer(cData, 18);
}
int CGame::iGetMapLocationSide(char *pMapName)
{
	uint32 length = strlen(pMapName);

	if(length == 0) return 0;

	ASSERT(length <= 11);
	if(pMapName[ length - 2] == '_')
	{
		switch(pMapName[ length - 1])
		{
			case '1':
				return ARESDEN;
			case '2':
				return ELVINE;
			case '3':
				return ISTRIA;
		}
	}

	
	if (strcmp(pMapName, sideMap[ARESDEN]) == 0) return ARESDEN + 10 ;
	if (strcmp(pMapName, sideMap[ELVINE]) == 0)  return ELVINE + 10 ;
	if (strcmp(pMapName, sideMap[ISTRIA]) == 0)  return ISTRIA + 10 ;
	if (memcmp(pMapName, "arebrk11", 8) == 0) return ARESDEN + 10 ;
	if (memcmp(pMapName, "elvbrk11", 8) == 0) return ELVINE + 10 ;
	if (memcmp(pMapName, "istbrk1", 7) == 0) return ISTRIA + 10 ;

	if (memcmp(pMapName, "arefarm", 7) == 0) return ARESDEN ;
	if (memcmp(pMapName, "elvfarm", 7) == 0) return ELVINE ;
	if (memcmp(pMapName, "istfarm", 7) == 0) return ISTRIA ;

	if (memcmp(pMapName, "arewrhus", 8) == 0) return ARESDEN ;
	if (memcmp(pMapName, "elvwrhus", 8) == 0) return ELVINE ;
	if (memcmp(pMapName, "istwrhus", 8) == 0) return ISTRIA ;

	/*  memcmp    .
	if (memcmp(pMapName, "gshop_1f") == 0) return 1;
	if (memcmp(pMapName, "bsmith_1f") == 0) return 1;
	if (memcmp(pMapName, "wrhus_1f") == 0) return 1;

	if (memcmp(pMapName, "gshop_2f") == 0) return 2;
	if (memcmp(pMapName, "bsmith_2f") == 0) return 2;
	if (memcmp(pMapName, "wrhus_2f") == 0) return 2; */


	return 0;
}

bool CGame::bCopyItemContents(CItem * pCopy, CItem *pOriginal)
{
	if (pOriginal == NULL) return FALSE;
	if (pCopy == NULL) return FALSE;

	pCopy->m_sIDnum = pOriginal->m_sIDnum;
	pCopy->m_cItemType = pOriginal->m_cItemType;
	pCopy->m_cEquipPos = pOriginal->m_cEquipPos;
	pCopy->m_sItemEffectType = pOriginal->m_sItemEffectType;     
	pCopy->m_sItemEffectValue1 = pOriginal->m_sItemEffectValue1;
	pCopy->m_sItemEffectValue2 = pOriginal->m_sItemEffectValue2;
	pCopy->m_sItemEffectValue3 = pOriginal->m_sItemEffectValue3; 
	pCopy->m_sItemEffectValue4 = pOriginal->m_sItemEffectValue4;
	pCopy->m_sItemEffectValue5 = pOriginal->m_sItemEffectValue5;
	pCopy->m_sItemEffectValue6 = pOriginal->m_sItemEffectValue6; 
	pCopy->m_wMaxLifeSpan = pOriginal->m_wMaxLifeSpan;
	pCopy->m_sSpecialEffect = pOriginal->m_sSpecialEffect;

	//short m_sSM_HitRatio, m_sL_HitRatio;

	pCopy->m_sSpecialEffectValue1 = pOriginal->m_sSpecialEffectValue1;
	pCopy->m_sSpecialEffectValue2 = pOriginal->m_sSpecialEffectValue2; 

	pCopy->m_sSprite = pOriginal->m_sSprite;
	pCopy->m_sSpriteFrame = pOriginal->m_sSpriteFrame;

	pCopy->m_cApprValue = pOriginal->m_cApprValue;
	pCopy->m_cSpeed = pOriginal->m_cSpeed;

	pCopy->m_wPrice = pOriginal->m_wPrice; 
	pCopy->m_wWeight = pOriginal->m_wWeight;
	pCopy->m_sLevelLimit = pOriginal->m_sLevelLimit;
	pCopy->m_cGenderLimit = pOriginal->m_cGenderLimit;

	pCopy->m_sRelatedSkill = pOriginal->m_sRelatedSkill;

	pCopy->m_cCategory = pOriginal->m_cCategory;
	pCopy->m_bIsForSale = pOriginal->m_bIsForSale;
	// 

	pCopy->m_dwCount = pOriginal->m_dwCount;
	pCopy->m_sTouchEffectType = pOriginal->m_sTouchEffectType;
	pCopy->m_sTouchEffectValue1 =pOriginal->m_sTouchEffectValue1;
	pCopy->m_sTouchEffectValue2 = pOriginal->m_sTouchEffectValue2;
	pCopy->m_sTouchEffectValue3 = pOriginal->m_sTouchEffectValue3;
	pCopy->m_cItemColor = pOriginal->m_cItemColor;
	pCopy->m_sItemSpecEffectValue1 = pOriginal->m_sItemSpecEffectValue1;
	pCopy->m_sItemSpecEffectValue2 = pOriginal->m_sItemSpecEffectValue2;
	pCopy->m_sItemSpecEffectValue3 = pOriginal->m_sItemSpecEffectValue3;
	pCopy->m_wCurLifeSpan = pOriginal->m_wCurLifeSpan;
	pCopy->m_dwAttribute = pOriginal->m_dwAttribute;

	return TRUE;
}

void CGame::Scheduler()
{
	if (m_schedulesCnt == 0 || 
		m_bIsCrusadeMode || m_astoria.get()) return;

	SYSTEMTIME SysTime;
	SYSTEMTIME announce2, announce30, announce10;
	GetLocalTime(&SysTime);
	announce2 = announce30 = announce10 = SysTime;
	announce2.wHour += 2;
	announce30.wMinute += 30;
	if(announce30.wMinute >= 60)
	{
		announce30.wHour++;
		announce30.wMinute -= 60;
	}
	announce10.wMinute += 10;
	if(announce10.wMinute >= 60)
	{
		announce10.wHour++;
		announce10.wMinute -= 60;
	}

	for (int i = 0; i < MAXSCHEDULE; i++)
	{
		if (m_schedules[i] == SysTime)
		{
			m_schedules[i].evStatus = ES_STARTED;
			switch(m_schedules[i].evType)
			{
			case ET_CAPTURE:
			case ET_DESTROY_SHIELD:
				EventStart(m_schedules[i].evType);
				break;
			case ET_CRUSADE:
				GlobalStartCrusadeMode();
				break;
			}
		}
		else if (m_schedules[i].evStatus != ES_ANNOUNCED_ONCE &&
			m_schedules[i] == announce2)
		{
			m_schedules[i].evStatus = ES_ANNOUNCED_ONCE;
			int shortCutIndex = 0;
			while(int index = m_iClientShortCut[shortCutIndex++])
			{
				SendNotifyMsg(NULL, index, NOTIFY_EVENTSTARTING, m_schedules[i].evType, NULL, NULL, NULL);
			}
		}
		else if (m_schedules[i].evStatus != ES_ANNOUNCED_TWICE &&
			m_schedules[i] == announce30)
		{
			m_schedules[i].evStatus = ES_ANNOUNCED_TWICE;
			int shortCutIndex = 0;
			while(int index = m_iClientShortCut[shortCutIndex++])
			{
				SendNotifyMsg(NULL, index, NOTIFY_EVENTSTARTING2, m_schedules[i].evType, NULL, NULL, NULL);
			}
		}
		else if (m_schedules[i].evStatus != ES_ANNOUNCED_THRICE &&
			m_schedules[i] == announce10)
		{
			m_schedules[i].evStatus = ES_ANNOUNCED_THRICE;
			int shortCutIndex = 0;
			while(int index = m_iClientShortCut[shortCutIndex++])
			{
				SendNotifyMsg(NULL, index, NOTIFY_EVENTSTARTING3, m_schedules[i].evType, NULL, NULL, NULL);
			}
		}
		else
			m_schedules[i].evStatus = ES_ENDED;
	}
}

bool CGame::bReadSchedulerConfigFile(char *pFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, * token, cReadModeA, cReadModeB;
	char seps[] = "= \t\n";

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(pFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(pFn, "rt");
	if (pFile == NULL) {

		PutLogList("(ERROR) Cannot open Scheduler file.");
		return FALSE;
	}
	else {
		//PutLogList("(*) Reading Scheduler file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		StrTok strTok(new CStrTok(cp, seps));
		token = strTok->pGet();

		while(token)
		{
			if(cReadModeA != 0) {
				switch (cReadModeA) 
				{
				case 1:
					switch (cReadModeB) 
					{
					case 1:
						if (m_schedulesCnt >= MAXSCHEDULE) {
							PutLogList("(!) WARNING! Too many events in scheduler!"); 
							return TRUE;
						}
						if(memcmp(token, "CTR", 3) == 0)
						{
							m_schedules[m_schedulesCnt].evType = ET_CAPTURE;
						}else if(memcmp(token, "DS", 2) == 0)
						{
							m_schedules[m_schedulesCnt].evType = ET_DESTROY_SHIELD;
						}else if(memcmp(token, "Crusade", 7) == 0)
						{
							m_schedules[m_schedulesCnt].evType = ET_CRUSADE;
						}else
						{
							cReadModeA = 0;
							cReadModeB = 0;
							break;
						}
						cReadModeB++;
						break;
					case 2:
						m_schedules[m_schedulesCnt].iDay = atoi(token);
						cReadModeB++;
						break;
					case 3:
						m_schedules[m_schedulesCnt].iHour = atoi(token);
						cReadModeB++;
						break;
					case 4:
						m_schedules[m_schedulesCnt].iMinute = atoi(token);
						m_schedulesCnt++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;
				}
			}
			else {
				if (memcmp(token, "event", 5) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}

			token = strTok->pGet();
		}
		delete[] cp;
	}
	if (pFile) fclose(pFile);

	return TRUE;
}

void CGame::KillCrusadeObjects()
{
	int i;

	for (i = 1; i < MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) {
			switch (m_pNpcList[i]->m_sType) 
			{
			case NPC_LWB:
			case NPC_GHK:
			case NPC_GHKABS:
			case NPC_TK:
			case NPC_BG:
			case NPC_CP:
			case NPC_AGT:
			case NPC_CGT:
			case NPC_MS:
			case NPC_DT:
			case NPC_ESG:
			case NPC_GMG:
			case NPC_MANASTONE:
				NpcKilledHandler(NULL, NULL, i, 0);
				break;
			}
		}
}





void CGame::AdminOrder_GetFightzoneTicket(int iClientH)
{
	int iReserveTime, iFightzoneTN, iFightzoneN;
	char cTemp[21];
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "fightzone", 9) == 0) {

		iReserveTime = m_pClientList[iClientH]->m_iReserveTime;
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iReserveTime = SysTime.wMonth*10000 + SysTime.wDay*100 + (SysTime.wHour +3);  

		ZeroMemory(cTemp, sizeof(cTemp));
		strcpy(cTemp, (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName +9));
		iFightzoneN  = m_pClientList[iClientH]->m_iFightzoneNumber;
		iFightzoneTN = m_pClientList[iClientH]->m_iFightZoneTicketNumber;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = 10;
		m_pClientList[iClientH]->m_iFightzoneNumber = atoi(cTemp);

		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);

		m_pClientList[iClientH]->m_iFightzoneNumber = iFightzoneN;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = iFightzoneTN;
		m_pClientList[iClientH]->m_iReserveTime = iReserveTime;
	}
	else {
		iReserveTime = m_pClientList[iClientH]->m_iReserveTime;
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iReserveTime = SysTime.wMonth*10000 + SysTime.wDay*100 + (SysTime.wHour +2);  

		ZeroMemory(cTemp, sizeof(cTemp));
		strcpy(cTemp, (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName +9));
		iFightzoneN  = m_pClientList[iClientH]->m_iFightzoneNumber;
		iFightzoneTN = m_pClientList[iClientH]->m_iFightZoneTicketNumber;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = 10;
		m_pClientList[iClientH]->m_iFightzoneNumber = 1;

		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);

		m_pClientList[iClientH]->m_iFightzoneNumber = iFightzoneN;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = iFightzoneTN;
		m_pClientList[iClientH]->m_iReserveTime = iReserveTime;
	}
}



void CGame::ResurrectPlayer(int iClientH)
{
	int iMaxSuperAttack;
	PutLogList("(*) Resurrect Player!");


	RemoveFromTarget(iClientH, OWNERTYPE_PLAYER);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(/*13,*/ iClientH, OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX,  m_pClientList[iClientH]->m_sY);

	SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_LOG, MSGTYPE_REJECT, NULL, NULL, NULL);

	GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	m_pClientList[iClientH]->m_iHP = m_pClientList[iClientH]->GetMaxHP();
	m_pClientList[iClientH]->m_iMP = m_pClientList[iClientH]->GetMaxMP();
	m_pClientList[iClientH]->m_iSP = m_pClientList[iClientH]->GetMaxSP();
	iMaxSuperAttack = (m_pClientList[iClientH]->m_iLevel / 10);
	m_pClientList[iClientH]->m_iSuperAttackLeft = iMaxSuperAttack;

	m_pClientList[iClientH]->m_bIsKilled = FALSE;

	//RequestInitDataHandler(iClientH);
	return;
}

void CGame::RequestCreatePartyHandler(int iClientH)
{
	char *cp, cData[120];
	DWORD * dwp;
	WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if (m_pClientList[iClientH]->m_iPartyStatus != PARTYSTATUS_NULL) {
		return;
	}
	
	if(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPartyDisabled == true && !m_pClientList[iClientH]->IsGM()) return;
	m_pClientList[iClientH]->m_iPartyStatus = PARTYSTATUS_PROCESSING;


	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;

	dwp = (DWORD *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;
	wp = (WORD*)cp;
	*wp = 1; // 1, request
	cp += 2;

	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;

	bSendMsgToLS(MSGID_PARTYOPERATION, iClientH, FALSE, cData);
}


void CGame::PartyOperationResultHandler(char *pData)
{
	char * cp, cResult, cName[12];
	WORD * wp;
	int i, iClientH, iPartyID, iTotal;

	cp = (char *)(pData + 4);
	wp = (WORD *)cp;
	cp += 2;

	switch (*wp) {
	case 1: 
		cResult = *cp;
		cp++;
		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;
		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;
		wp = (WORD *)cp;
		iPartyID = (int)*wp;
		cp += 2;
		PartyOperationResult_Create(iClientH, cName, cResult, iPartyID);
		break;

	case 2: 
		wp = (WORD *)cp;
		iPartyID = *wp;
		cp += 2;
		PartyOperationResult_Delete(iPartyID);
		break;

	case 3: 
		wp = (WORD *)cp;
		iClientH = *wp;
		cp += 2;
		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		if ((iClientH < 0) && (iClientH > MAXCLIENTS)) return;
		if (m_pClientList[iClientH] == NULL) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, cName) != 0) return;


		for (i = 0; i < MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == iClientH) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = 0;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers--;
				break;
			}

		for (i = 0; i < MAXPARTYMEMBERS-1; i++)
			if ((m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) && (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] != 0)) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i]   = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1];
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] = 0;
			}

			m_pClientList[iClientH]->m_iPartyID = NULL;
			m_pClientList[iClientH]->m_iPartyStatus = PARTYSTATUS_NULL;

			SendNotifyMsg(NULL, iClientH, NOTIFY_PARTY, 8, 0, NULL, NULL);
			break;

	case 4: 
		cResult = *cp;
		cp++;
		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;
		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;
		wp = (WORD *)cp;
		iPartyID = (int)*wp;
		cp += 2;
		PartyOperationResult_Join(iClientH, cName, cResult, iPartyID);
		break;

	case 5: 
		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;
		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;
		wp = (WORD *)cp;
		iTotal = (int)*wp;
		cp += 2;
		PartyOperationResult_Info(iClientH, cName, iTotal, cp);
		break;

	case 6: 
		cResult = *cp;
		cp++;
		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;
		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;
		wp = (WORD *)cp;
		iPartyID = (int)*wp;
		cp += 2;
		PartyOperationResult_Dismiss(iClientH, cName, cResult, iPartyID);
		break;
	}
}

void CGame::PartyOperationResult_Create(int iClientH, char *pName, int iResult, int iPartyID)
{
	char * cp, cData[120];
	DWORD * dwp;
	WORD * wp;
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

	switch (iResult) {
	case 0: 
		if (m_pClientList[iClientH]->m_iPartyStatus != PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = NULL;
		m_pClientList[iClientH]->m_iPartyStatus = PARTYSTATUS_NULL;
		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		SendNotifyMsg(NULL, iClientH, NOTIFY_PARTY, 1, 0, NULL, NULL);
		break;

	case 1: 
		if (m_pClientList[iClientH]->m_iPartyStatus != PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = iPartyID;
		m_pClientList[iClientH]->m_iPartyStatus = PARTYSTATUS_CONFIRM;
		SendNotifyMsg(NULL, iClientH, NOTIFY_PARTY, 1, 1, NULL, NULL);


		for (i = 0; i < MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = iClientH;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers++;
				break;
			}

		if ((m_pClientList[iClientH]->m_iReqJoinPartyClientH != NULL) && (strlen(m_pClientList[iClientH]->m_cReqJoinPartyName) != NULL)) {
			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 3; 
			cp += 2;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cReqJoinPartyName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			bSendMsgToLS(MSGID_PARTYOPERATION, iClientH, FALSE, cData);
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
			ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		}
		break;
	}
}

void CGame::PartyOperationResult_Join(int iClientH, char *pName, int iResult, int iPartyID)
{
	int i, j;

	if (m_pClientList[iClientH] == NULL) return;

	switch (iResult) {
	case 0: 
		if (m_pClientList[iClientH]->m_iPartyStatus != PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = NULL;
		m_pClientList[iClientH]->m_iPartyStatus = PARTYSTATUS_NULL;
		SendNotifyMsg(NULL, iClientH, NOTIFY_PARTY, 4, 0, NULL, pName);

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		break;

	case 1: 
		if (m_pClientList[iClientH]->m_iPartyStatus != PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = iPartyID;
		m_pClientList[iClientH]->m_iPartyStatus = PARTYSTATUS_CONFIRM;
		SendNotifyMsg(NULL, iClientH, NOTIFY_PARTY, 4, 1, NULL, pName);

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));


		for (i = 0; i < MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = iClientH;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers++;
				GetPartyInfoHandler(iClientH);
				for(i = 0; i< MAXPARTYMEMBERS; i++){ //Update everyone player joining and people in party with each others coordinates
					j = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
					if(j != 0 && j != iClientH) {
						SendNotifyMsg(NULL, j, NOTIFY_PARTY, 4, 1, NULL, pName);
						if(m_pClientList[j]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex){
						SendNotifyMsg(iClientH, j, NOTIFY_PARTY_COORDS, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, NULL, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iHP, m_pClientList[iClientH]->m_iMP, m_pClientList[iClientH]->GetMaxHP(), m_pClientList[iClientH]->GetMaxMP());
						}
					}
				}
				break;
			}
		break;
	}
}

void CGame::PartyOperationResult_Dismiss(int iClientH, char *pName, int iResult, int iPartyID)
{
	int i;

	switch (iResult) {
	case 0: 
		break;

	case 1: 
		if (iClientH == NULL) {
			for (i = 1; i < MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pName) == 0)) {
					iClientH = i;
					break;
				}

			for (i = 0; i < MAXPARTYMEMBERS; i++)
				if (m_stPartyInfo[iPartyID].iIndex[i] == iClientH) {
					m_stPartyInfo[iPartyID].iIndex[i] = 0;
					m_stPartyInfo[iPartyID].iTotalMembers--;
					break;
				}

			for (i = 0; i < MAXPARTYMEMBERS-1; i++)
				if ((m_stPartyInfo[iPartyID].iIndex[i] == 0) && (m_stPartyInfo[iPartyID].iIndex[i+1] != 0)) {
					m_stPartyInfo[iPartyID].iIndex[i]   = m_stPartyInfo[iPartyID].iIndex[i+1];
					m_stPartyInfo[iPartyID].iIndex[i+1] = 0;
				}

				if (m_pClientList[iClientH] != NULL) {
					m_pClientList[iClientH]->m_iPartyID = NULL;
					m_pClientList[iClientH]->m_iPartyStatus = PARTYSTATUS_NULL;
					m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
				}

			for (i = 1; i < MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iPartyID != NULL) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
					SendNotifyMsg(NULL, i, NOTIFY_PARTY, 6, 1, NULL, pName);
				}
				return;
		}

		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iPartyStatus != PARTYSTATUS_PROCESSING)) return;
		if ((m_pClientList[iClientH] != NULL) && (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0)) return;

		for (i = 1; i < MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iPartyID != NULL) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
				SendNotifyMsg(NULL, i, NOTIFY_PARTY, 6, 1, NULL, pName);
			}


		for (i = 0; i < MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[iPartyID].iIndex[i] == iClientH) {
				m_stPartyInfo[iPartyID].iIndex[i] = 0;
				m_stPartyInfo[iPartyID].iTotalMembers--;
				break;
			}

		for (i = 0; i < MAXPARTYMEMBERS-1; i++)
			if ((m_stPartyInfo[iPartyID].iIndex[i] == 0) && (m_stPartyInfo[iPartyID].iIndex[i+1] != 0)) {
				m_stPartyInfo[iPartyID].iIndex[i]   = m_stPartyInfo[iPartyID].iIndex[i+1];
				m_stPartyInfo[iPartyID].iIndex[i+1] = 0;
			}

		if (m_pClientList[iClientH] != NULL) {
			m_pClientList[iClientH]->m_iPartyID = NULL;
			m_pClientList[iClientH]->m_iPartyStatus = PARTYSTATUS_NULL;
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		}
		break;
	}
}

void CGame::PartyOperationResult_Delete(int iPartyID)
{
	int i;

	for (i = 0; i < MAXPARTYMEMBERS; i++)
	{
		m_stPartyInfo[iPartyID].iIndex[i] = 0;
		m_stPartyInfo[iPartyID].iTotalMembers = 0;
	}

	for (i = 1; i < MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
			SendNotifyMsg(NULL, i, NOTIFY_PARTY, 2, 0, NULL, NULL);
			m_pClientList[i]->m_iPartyID = NULL;
			m_pClientList[i]->m_iPartyStatus = PARTYSTATUS_NULL;
			m_pClientList[i]->m_iReqJoinPartyClientH = NULL;
		}
}


void CGame::RequestJoinPartyHandler(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * cp, * token, cBuff[256], cData[120], cName[12];
	DWORD * dwp;
	WORD  * wp;
	int i;


	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != PARTYSTATUS_NULL) return;
	if ((dwMsgSize)	<= 0) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();

	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	}
	else return;

	for (i = 1; i < MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {

			if ((m_pClientList[i]->m_iPartyID == NULL) || (m_pClientList[i]->m_iPartyStatus != PARTYSTATUS_CONFIRM)) {

				return;
			}

			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 3; 
			cp += 2;
			wp = (WORD *)cp;
			*wp = iClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[i]->m_iPartyID;
			cp += 2;
			bSendMsgToLS(MSGID_PARTYOPERATION, iClientH, FALSE, cData);
			return;
		}

	SendNotifyMsg(NULL, iClientH, NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
}



void CGame::RequestDismissPartyHandler(int iClientH)
{
	char * cp, cData[120];
	DWORD * dwp;
	WORD  * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != PARTYSTATUS_CONFIRM) return;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	dwp = (DWORD *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;
	wp = (WORD*)cp;
	*wp = 4; 	
	cp += 2;
	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;
	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_iPartyID;
	cp += 2;
	bSendMsgToLS(MSGID_PARTYOPERATION, iClientH, FALSE, cData);

	m_pClientList[iClientH]->m_iPartyStatus = PARTYSTATUS_PROCESSING;
}


void CGame::GetPartyInfoHandler(int iClientH)
{
	char * cp, cData[120];
	DWORD * dwp;
	WORD  * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != PARTYSTATUS_CONFIRM) return;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	dwp = (DWORD *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;
	wp = (WORD*)cp;
	*wp = 6; 
	cp += 2;
	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;
	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_iPartyID;
	cp += 2;

	bSendMsgToLS(MSGID_PARTYOPERATION, iClientH, FALSE, cData);
}


void CGame::PartyOperationResult_Info(int iClientH, char * pName, int iTotal, char *pNameList)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != PARTYSTATUS_CONFIRM) return;

	SendNotifyMsg(NULL, iClientH, NOTIFY_PARTY, 5, 1, iTotal, pNameList);

	for(int i = 0; i < MAXPARTYMEMBERS; i++){
		int j = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
		if(j != 0 && j != iClientH && m_pClientList[j]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex){
			SendNotifyMsg(j, iClientH, NOTIFY_PARTY_COORDS, m_pClientList[j]->m_sX, m_pClientList[j]->m_sY, NULL, m_pClientList[j]->m_cCharName, m_pClientList[j]->m_iHP, m_pClientList[j]->m_iMP, m_pClientList[j]->GetMaxHP(), m_pClientList[j]->GetMaxMP());
		}
	}		
}

void CGame::RequestDeletePartyHandler(int iClientH)
{
	char * cp, cData[120];
	DWORD * dwp;
	WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyID != NULL) {
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		dwp = (DWORD *)cp;
		*dwp = MSGID_PARTYOPERATION;
		cp += 4;
		wp = (WORD*)cp;
		*wp = 4; 		
		cp += 2;
		wp = (WORD *)cp;
		*wp = iClientH;
		cp += 2;
		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_iPartyID;
		cp += 2;
		bSendMsgToLS(MSGID_PARTYOPERATION, iClientH, FALSE, cData);

		m_pClientList[iClientH]->m_iPartyStatus = PARTYSTATUS_PROCESSING;
	}
}

void CGame::RequestAcceptJoinPartyHandler(int iClientH, int iResult)
{
	char *cp, cData[120];
	DWORD * dwp;
	WORD * wp;
	int iH;

	if (m_pClientList[iClientH] == NULL) return;

	switch (iResult) {
	case 0: 
		iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
		if (m_pClientList[iH] == NULL) {

			return;
		}
		if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {

			return;
		}
		if (m_pClientList[iH]->m_iPartyStatus != PARTYSTATUS_PROCESSING) {

			return;
		}
		if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {

			return;
		}

		SendNotifyMsg(NULL, iH, NOTIFY_PARTY, 7, 0, NULL, NULL);

		m_pClientList[iH]->m_iPartyID = NULL;
		m_pClientList[iH]->m_iPartyStatus = PARTYSTATUS_NULL;
		m_pClientList[iH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iH]->m_cReqJoinPartyName, sizeof(m_pClientList[iH]->m_cReqJoinPartyName));

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		break;

	case 1: 
		if ((m_pClientList[iClientH]->m_iPartyStatus == PARTYSTATUS_CONFIRM) && (m_pClientList[iClientH]->m_iPartyID != NULL)) {
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			if (m_pClientList[iH] == NULL)	return;

			if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) return;

			if (m_pClientList[iH]->m_iPartyStatus != PARTYSTATUS_PROCESSING) 	return;

			if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) 	return;

			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 3; 
			cp += 2;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cReqJoinPartyName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			bSendMsgToLS(MSGID_PARTYOPERATION, iClientH, FALSE, cData);
		}
		else {
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			if (m_pClientList[iH] == NULL) 	return;

			if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) return;

			if (m_pClientList[iH]->m_iPartyStatus != PARTYSTATUS_PROCESSING)	return;

			if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) return;


			if (m_pClientList[iClientH]->m_iPartyStatus == PARTYSTATUS_NULL) {
				RequestCreatePartyHandler(iClientH);
			}
			else {

			}
		}
		break;

	case 2: 
		if ((m_pClientList[iClientH]->m_iPartyID != NULL) && (m_pClientList[iClientH]->m_iPartyStatus == PARTYSTATUS_CONFIRM)) {
			RequestDismissPartyHandler(iClientH);
		}
		else {

			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;

			if ((m_pClientList[iH] != NULL) && (m_pClientList[iH]->m_iReqJoinPartyClientH == iClientH) && 
				(strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) == 0)) {
					m_pClientList[iH]->m_iReqJoinPartyClientH = NULL;
					ZeroMemory(m_pClientList[iH]->m_cReqJoinPartyName, sizeof(m_pClientList[iH]->m_cReqJoinPartyName));
			}

			m_pClientList[iClientH]->m_iPartyID = NULL;
			m_pClientList[iClientH]->m_iPartyStatus = PARTYSTATUS_NULL;
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
			ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		}
		break;
	}
}

void CGame::GetExp(int iClientH, int iExp, bool bIsAttackerOwn)
{
	double dV1, dV2, dV3;
	int i, iH, iUnitValue, iPartyTotalMember = 0, slateMulti = 1;
	DWORD dwTime = timeGetTime();

	if (m_pClientList[iClientH] == NULL) return;
	if (iExp <= 0) return;
	iExp = (iExp / 100);

	if (m_pClientList[iClientH]->m_iLevel <= 80) {
		dV1 = (double)(80 - m_pClientList[iClientH]->m_iLevel);
		dV2 = dV1 * 0.025f;
		dV3 = (double)iExp;
		dV1 = (dV2 + 1.025f)*dV3;
		iExp = (int)dV1;
	}

		if ((m_pClientList[iClientH]->m_iLevel >= 80) &&
			((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) 
			|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0))) {
				iExp = (iExp/2) ;
		}
	
	if ((m_pClientList[iClientH]->m_iPartyID != NULL) && (m_pClientList[iClientH]->m_iPartyStatus == PARTYSTATUS_CONFIRM) && 
		((dwTime - m_pClientList[iClientH]->m_dwLastActionTime) < 1000*60*5)) {
			if ((iExp >= 10) && (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers > 1)) {
				iPartyTotalMember  = 0 ;

				for (i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++) {
					iH = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
					if ((m_pClientList[iH] != NULL) && (m_pClientList[iH]->m_iHP > 0))
					{
						iPartyTotalMember++ ;
					}
				}
				if (iPartyTotalMember > MAXPARTYMEMBERS) 
				{
					wsprintf(g_cTxt,"(X) Party Bug !! partyMember %d XXXXXXXXXX",iPartyTotalMember) ;
					PutLogFileList(g_cTxt);
					iPartyTotalMember = MAXPARTYMEMBERS ;
				}

				dV1 = (double)iExp;

				if(iPartyTotalMember == 1)	dV2 = dV1 ;
				else dV2 = (dV1 * iPartyTotalMember);

				dV3 = dV2 + 0.75f ;
				iUnitValue = (int) dV3;

				for (i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++, slateMulti = 1) {
					iH = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
					if ((m_pClientList[iH] != NULL) && (m_pClientList[iH]->m_iHP > 0))
					{
						if((m_pClientList[iH]->m_iStatus & STATUS_GREENSLATE) != 0) slateMulti = 3;
						if(m_pClientList[iH]->m_iLevel == m_sMaxPlayerLevel)
							m_pClientList[iH]->m_iExpStock += (iUnitValue/3) * slateMulti;
						else
							m_pClientList[iH]->m_iExpStock += iUnitValue * slateMulti;
					}
				}
				if((m_pClientList[iClientH]->m_iStatus & STATUS_GREENSLATE) != 0) iUnitValue *= 3;
				if(m_pClientList[iClientH]->m_iLevel == m_sMaxPlayerLevel)
					iUnitValue /= 3;
				if ((bIsAttackerOwn == TRUE) && (iPartyTotalMember > 1))
					m_pClientList[iClientH]->m_iExpStock += (int)(iUnitValue/10);
			} else {
				if((m_pClientList[iClientH]->m_iStatus & STATUS_GREENSLATE) != 0) iExp *= 3;
				if(m_pClientList[iClientH]->m_iLevel == m_sMaxPlayerLevel)
					iExp /= 3;
				m_pClientList[iClientH]->m_iExpStock += iExp;
			}
	} else {
		if((m_pClientList[iClientH]->m_iStatus & STATUS_GREENSLATE) != 0) iExp *= 3;
		if(m_pClientList[iClientH]->m_iLevel == m_sMaxPlayerLevel)
			iExp /= 3;
		m_pClientList[iClientH]->m_iExpStock += iExp;
	}
}

void CGame::RequestItemUpgradeHandler(int iClientH, int iItemIndex)
{
	int i, iValue,  iItemX,iItemY, iSoM, iSoX, iSomH, iSoxH;
	DWORD dwTemp, dwSWEType, dwColor;
	double dV1, dV2, dV3;
	short sItemUpgrade = 2;

	if (m_pClientList[iClientH] == NULL) return;
	if ((iItemIndex < 0) || (iItemIndex >= MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return;

	iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
	if (iValue >= 20 || iValue < 0 ) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 1, NULL, NULL, NULL);
		return;
	}

	/*wsprintf(g_cTxt, "value (%d)", iValue);
	PutLogList(g_cTxt);
	wsprintf(g_cTxt, "Weapon (%d)", m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum);
	PutLogList(g_cTxt);*/

	switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cCategory) 
	{
	case 46: // Pendants
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType != 1) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);   
			return; // Pendants are type 1
		}
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cEquipPos < 11) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);   
			return; // Pendants are left finger or more
		}
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectType != 14) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);   
			return; // Pendants are EffectType 14
		}
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectValue1) 
		{
		default: // Other items are not upgradable
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);   
			return; // Pendants are EffectType 14
		case 16: // AngelicPendant(STR)
		case 17: // AngelicPendant(DEX)
		case 18: // AngelicPendant(INT)
		case 19: // AngelicPendant(MAG)
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return;
			}
			if(iValue >= 20) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return;
			}
			switch (iValue) {
			case 0: sItemUpgrade = 6; break;
			case 1: sItemUpgrade = 8; break;
			case 2: sItemUpgrade = 10; break;
			case 3: sItemUpgrade = 13; break;
			case 4: sItemUpgrade = 16; break;
			case 5: sItemUpgrade = 20; break;
			case 6: sItemUpgrade = 24; break;
			case 7: sItemUpgrade = 29; break;
			case 8: sItemUpgrade = 34; break;
			case 9: sItemUpgrade = 39; break;
			case 10: sItemUpgrade = 44; break;
			case 11: sItemUpgrade = 49; break;
			case 12: sItemUpgrade = 54; break;
			case 13: sItemUpgrade = 59; break;
			case 14: sItemUpgrade = 64; break;
			default:
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return;
			}

			if (   (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) 
				|| (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) 
				|| (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3)) 
			{ 
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				return; 
			}
			if (( m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}

			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade; 
			SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
			iValue++;
			if (iValue > 20) iValue = 20;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp& 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
			return;
		}
		break;
	case 1: //Weapons
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) 
		{
		case ITEM_EXCALIBER:
		case ITEM_XELIMABLADE:
		case ITEM_XELIMAAXE:
		case ITEM_XELIMARAPIER:
		case ITEM_SWORDOFMEDUSA:
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
			return; 

		case ITEM_DKFLAMEBERG:
		case ITEM_DKGIANTSWORD:
		case ITEM_BLACKKNIGHTTEMPLE:
		case ITEM_DKRAPIER:
		case ITEM_DKGREATSWORD:
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) 
			{ 
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}

			sItemUpgrade = (iValue*(iValue+6)/8) + 2;

			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
			{
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				return; 
			}

			if (( m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0)
			{ 
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}

			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade; 

			SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);

			if ((iValue == 2) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == ITEM_DKFLAMEBERG)) 
			{

				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , ITEM_DKGIANTSWORD ) == FALSE) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

				SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONEITEMCHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute );

				_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			} 
			else if ((iValue == 6) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == ITEM_DKGIANTSWORD))
			{
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , ITEM_BLACKKNIGHTTEMPLE) == FALSE) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

				SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONEITEMCHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute );
				_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;

			} 
			else if ((iValue == 14) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == ITEM_BLACKKNIGHTTEMPLE))
			{
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 720) == FALSE) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwColor = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor;
				dwColor = 9; 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor = dwColor;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

				SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONEITEMCHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute );
				_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			} 
			else 
			{
				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
				_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
			}
			break;
		case 717:  // DKRapier
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) 
			{ 
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}

			sItemUpgrade = (iValue*(iValue+6)/8) + 2;

			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
			{
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				return; 
			}

			if (( m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) 
			{ 
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}

			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade; 

			SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
			iValue += 1;
			if (iValue > 7) iValue = 7;
			dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
			dwTemp = dwTemp& 0x0FFFFFFF;
			m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
			_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);

			break;
		default:
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				if (dwSWEType == ITEMSTAT_ANCIENT) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
					return;
				}
			}
			iSoX = iSoM = 0;
			for (i = 0; i < MAXITEMS; i++)
				if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
					switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) 
					{
					case ITEM_STONEOFXELIMA: iSoX++; iSoxH = i; break;
					case ITEM_STONEOFMERIEN: iSoM++; iSomH = i; break;
					}
				}
				if (iSoX > 0) {
					if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == FALSE) {
						SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
						iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
						if (iValue >= 3) ItemDepleteHandler(iClientH, iItemIndex, FALSE);
						ItemDepleteHandler(iClientH, iSoxH, FALSE); 
						return;
					}

					if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
						iValue++;
						if (iValue > 10) 
							iValue = 10;
						else {
							dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
							dwTemp = dwTemp& 0x0FFFFFFF;
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
							ItemDepleteHandler(iClientH, iSoxH, FALSE);
						}
					}
					else {
						iValue++;
						if (iValue > 7) 
							iValue = 7;
						else {
							dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
							dwTemp = dwTemp& 0x0FFFFFFF;
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
							ItemDepleteHandler(iClientH, iSoxH, FALSE);
						}
					}
				}

			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
			break;
		}
		break;

	case 3: // Bows
		SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
		break;

	case 5: // Shields

		if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
			dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
			if (dwSWEType == 8) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				return;
			}
		}
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum)
		{
		case ITEM_MERIENSHIELD:
		case ITEM_GM_SHIELD:
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
			return;
		default: break;
		}

		iSoX = iSoM = 0;
		for (i = 0; i < MAXITEMS; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
				switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) 
				{
				case ITEM_STONEOFXELIMA: iSoX++; iSoxH = i; break;
				case ITEM_STONEOFMERIEN: iSoM++; iSomH = i; break;
				}
			}

			if (iSoM > 0) {
				if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH,TRUE) == FALSE) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; 
					if (iValue >= 3) ItemDepleteHandler(iClientH, iItemIndex, FALSE); 
					ItemDepleteHandler(iClientH, iSomH, FALSE); 
					return;
				}

				iValue++;
				if (iValue > 10) 
					iValue = 10;
				else {
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp& 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

					if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
						dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						dV2 = 0.2f * dV1;
						dV3 = dV1 + dV2;
					}
					else {
						dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						dV2 = 0.15f * dV1;
						dV3 = dV1 + dV2;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (short)dV3;
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 < 0) 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;

					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
					ItemDepleteHandler(iClientH, iSomH, FALSE); 
				}
			}
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
			break;


	case 12: //Cape
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) 
		{
		case ITEM_ARESDENHEROCAPE:
		case ITEM_ELVINEHEROCAPE:
		case ITEM_CAPE:

		default:
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				if (dwSWEType == 8) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
					return;
				}
			}

			iSoX = iSoM = 0;
			for (i = 0; i < MAXITEMS; i++)
				if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
					switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum)
					{
					case ITEM_STONEOFXELIMA: iSoX++; iSoxH = i; break;
					case ITEM_STONEOFMERIEN: iSoM++; iSomH = i; break;
					}
				}

			if (iSoM > 0) {
				if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH,TRUE) == FALSE) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					if (iValue >= 3) ItemDepleteHandler(iClientH, iItemIndex, FALSE);
					return;
				}

				if ((iValue == 0) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == ITEM_CAPE))
				{
					iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
					iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;

					delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

					m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;

					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp;


					if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , ITEM_CAPE_ADD1) == FALSE) {
						SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
						return;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = ITET_UNIQUE_OWNER;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

					iValue++;
					if (iValue > 15) iValue = 15;
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp& 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

					SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONEITEMCHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute );
					_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					m_pClientList[iClientH]->m_iContribution = m_pClientList[iClientH]->m_iContribution - 50;
					ItemDepleteHandler(iClientH, iSomH, FALSE); 
					return;
				}

				if ((iValue == 0) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == ITEM_ARESDENHEROCAPE) && (m_pClientList[iClientH]->m_iContribution >= 50))
				{
					iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
					iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

					delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

					m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;

					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;


					if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , ITEM_ARESDENHEROCAPE_ADD1) == FALSE) {
						SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
						return;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = ITET_UNIQUE_OWNER;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;


					if (iValue > 15) iValue = 15;
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp& 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

					SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONEITEMCHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute );
					_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					m_pClientList[iClientH]->m_iContribution = m_pClientList[iClientH]->m_iContribution - 50;
					ItemDepleteHandler(iClientH, iSomH, FALSE); 
					return;
				}

				if ((iValue == 0) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == ITEM_ELVINEHEROCAPE) && (m_pClientList[iClientH]->m_iContribution >= 50))
				{

					iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
					iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

					delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

					m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;

					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;


					if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , ITEM_ELVINEHEROCAPE_ADD1) == FALSE) {
						SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
						return;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = ITET_UNIQUE_OWNER;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;


					if (iValue > 15) iValue = 15;
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp& 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

					SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONEITEMCHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute );
					_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					m_pClientList[iClientH]->m_iContribution = m_pClientList[iClientH]->m_iContribution - 50;
					ItemDepleteHandler(iClientH, iSomH, FALSE); 
					return;
				}
			}
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
			break;
		}
		break;

	case 11: //Robes
	case 13: //Cape+1
	case 15: //Costume
	case 6:  //Armor
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) 
		{
		case 621: // MerienPlateMailM
		case 622: // MerienPlateMailW
		case 700: // SangAhHauberk
		case 701: // SangAhFullHel 
		case 702: // SangAhLeggings
		case 704: // SangAhPlateMail

		case 706: // DKHauberk
		case 707: // DKFullHelm
		case 708: // DKLeggings
		case 710: // DKPlateMail
		case 711: // DMHauberk
		case 712: // DMChainMail
		case 713: // DMLeggings
		case 724: // DKHauberkW
		case 725: // DKFullHelmW
		case 726: // DKLeggingsW
		case 728: // DKPlateMailW
		case 729: // DMHauberkW
		case 730: // DMChainMailW
		case 731: // DMLeggingsW

		case 716: // DMLedderArmor
		case 719: // DMScaleMail
		case 775: // DMLArmorW
		case 776: // DMScaleMailW
		case 733: // DMRobeW
		case 715: // DMRobe

			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
			return;

		default:
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				if (dwSWEType == 8) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
					return;
				}
			}
			iSoX = iSoM = 0;
			for (i = 0; i < MAXITEMS; i++)
				if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
					switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
					case ITEM_STONEOFXELIMA: iSoX++; iSoxH = i; break;
					case ITEM_STONEOFMERIEN: iSoM++; iSomH = i; break;
					}
				}

				if (iSoM > 0) {
					if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH,TRUE) == FALSE) {
						SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
						iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
						if (iValue >= 3) ItemDepleteHandler(iClientH, iItemIndex, FALSE);
						ItemDepleteHandler(iClientH, iSomH, FALSE); 
						return;
					}
					iValue++;
					if (iValue > 10) 
						iValue = 10;
					else {
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp& 0x0FFFFFFF;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

						if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
							dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
							dV2 = 0.2f * dV1;
							dV3 = dV1 + dV2;
						}
						else {
							dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
							dV2 = 0.15f * dV1;
							dV3 = dV1 + dV2;
						}
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (short)dV3;
						if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 < 0) 
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
						ItemDepleteHandler(iClientH, iSomH, FALSE); 
					}
				}
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
			break;
		}
		break;

	case 8: //Wands
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) 
		{

		case ITEM_DMMAGICSTAFF:
		case ITEM_DMMAGICWAND:
		case ITEM_BLACKMAGETEMPLE:
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
			{
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				return; 
			}

			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0)
			{ 
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}

			sItemUpgrade = (iValue*(iValue+6)/8) + 2;

			if ((m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) 
			{ 
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}

			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade; 
			SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);

			if (iValue == 0 ){
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
			}

			if( (iValue == 2) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 724) )
			{
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;

				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;


				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 725) == FALSE) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp& 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

				SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONEITEMCHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute );
				_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			}

			if ((iValue == 6) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 725)) {
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;

				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;


				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 726) == FALSE) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp& 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

				SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONEITEMCHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute );
				_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			}

			if ((iValue == 14) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 726)) {

				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;

				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;


				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 726) == FALSE) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 1;
				if (iValue > 15) iValue = 15;
				dwColor = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor;
				dwColor = 9; 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor = dwColor;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp& 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

				SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONEITEMCHANGE, iItemIndex, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute );
				_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break; 
			}
			else
			{
				iValue += 2;
				if (iValue > 15) iValue = 15; 
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp& 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
				_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			}
		default:
			iSoX = iSoM = 0;
			for (i = 0; i < MAXITEMS; i++)
				if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
					switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) 
					{
					case 656: iSoX++; iSoxH = i; break;
					case 657: iSoM++; iSomH = i; break;
					}
				}
			if (iSoX > 0) {
				if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == FALSE) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					if (iValue >= 3) ItemDepleteHandler(iClientH, iItemIndex, FALSE);
					ItemDepleteHandler(iClientH, iSoxH, FALSE); 
					return;
				}

				iValue++;
				if (iValue > 20) 
					iValue = 20;
				else {
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp& 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
					ItemDepleteHandler(iClientH, iSoxH, FALSE);
				}
			 }

			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
			break;
		}
		break;
		/* case 13:  switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 715:  case 733:   if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) return;
		break;

		default:
		SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
		break;
		}
		break;
		*/
	default:
		SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
		break;
	}
}



bool CGame::bCheckIsItemUpgradeSuccess(int iClientH, int iItemIndex, int iSomH, bool bBonus)
{
	int iValue, iProb, iResult;

	if (m_pClientList[iClientH]->m_pItemList[iSomH] == NULL) return FALSE;
	iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;

	switch (iValue) {
	case 0: iProb = 30; break; 
	case 1: iProb = 25; break;
	case 2: iProb = 20; break;
	case 3: iProb = 15; break;
	case 4: iProb = 10; break;
	case 5: iProb = 10; break;
	case 6: iProb =  8; break;
	case 7: iProb =  8; break;
	case 8: iProb =  5; break;
	case 9: iProb =  3; break;
	default: iProb = 1; break;
	}

	if (((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 > 100)) {

		if (iProb > 20) 
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 10);
		else if (iProb > 7) 
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 20);
		else
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 40);
	}
	if ( bBonus == TRUE) iProb *=2 ;

	iProb *= 100;
	iResult = dice(1,10000);

	if (iProb >= iResult) {
		_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
		return TRUE;
	}

	_bItemLog(ITEMLOG_UPGRADEFAIL, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);

	return FALSE;
}


void CGame::ArmorLifeDecrement(int iAttackerH, int iTargetH, char cOwnerType, int iValue)
{
	int iTemp;

	if (m_pClientList[iAttackerH] == NULL) return ;

	switch (cOwnerType) {
	case OWNERTYPE_PLAYER:
		if (m_pClientList[iTargetH] == NULL) return;
		break;

	case OWNERTYPE_NPC:	return;
	default: return;
	}


	if (m_pClientList[iAttackerH]->m_side == m_pClientList[iTargetH]->m_side && 
		!m_pMapList[m_pClientList[iAttackerH]->m_cMapIndex]->m_bIsFightZone) return;
	if (m_pClientList[iTargetH]->IsNeutral()) return;

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[EQUIPPOS_BODY];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;

		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;

			SendNotifyMsg(NULL, iTargetH, NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);

			ReleaseItemHandler(iTargetH, iTemp, TRUE);  
		}
	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[EQUIPPOS_PANTS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;

		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;

			SendNotifyMsg(NULL, iTargetH, NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);

			ReleaseItemHandler(iTargetH, iTemp, TRUE);  
		}
	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[EQUIPPOS_LEGGINGS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;

		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;

			SendNotifyMsg(NULL, iTargetH, NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);

			ReleaseItemHandler(iTargetH, iTemp, TRUE);  
		}
	}


	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[EQUIPPOS_ARMS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;

		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;

			SendNotifyMsg(NULL, iTargetH, NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);

			ReleaseItemHandler(iTargetH, iTemp, TRUE);  
		}
	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[EQUIPPOS_HEAD];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;

		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;

			SendNotifyMsg(NULL, iTargetH, NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);

			ReleaseItemHandler(iTargetH, iTemp, TRUE);  
		}
	}
}



void CGame::RequestGuildNameHandler(int iClientH, int iObjectID, int iIndex)
{
	if (m_pClientList[iClientH] == NULL) return;
	if ((iObjectID <= 0) || (iObjectID >= MAXCLIENTS)) return;

	if (m_pClientList[iObjectID] != NULL) {
		// SendNotifyMsg(NULL, iClientH, NOTIFY_REQGUILDNAMEANSWER, iObjectID, iIndex, m_pClientList[iObjectID]->m_iGuildRank, m_pClientList[iObjectID]->m_cGuildName);
		// SendNotifyMsg(NULL, iClientH, NOTIFY_REQGUILDNAMEANSWER, m_pClientList[iObjectID]->m_iGuildRank, iIndex, m_pClientList[iObjectID]->m_iGuildRank, m_pClientList[iObjectID]->m_cGuildName);
		SendNotifyMsg(NULL, iClientH, NOTIFY_REQGUILDNAMEANSWER, m_pClientList[iObjectID]->m_iGuildRank, iIndex, NULL, m_pClientList[iObjectID]->m_cGuildName);
	}
}

bool CGame::bCheckClientAttackFrequency(int iClientH, DWORD dwClientTime)
{
	DWORD dwTimeGap;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	if (m_pClientList[iClientH]->m_dwAttackFreqTime == NULL) 
		m_pClientList[iClientH]->m_dwAttackFreqTime = dwClientTime;
	else {
		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwAttackFreqTime;
		m_pClientList[iClientH]->m_dwAttackFreqTime = dwClientTime;
#ifndef NO_MSGSPEEDCHECK
		if (dwTimeGap < 500) {
			wsprintf(g_cTxt, "(!) Speed hack suspect(%s)", m_pClientList[iClientH]->m_cCharName);
			PutLogList(g_cTxt);
			DeleteClient(iClientH, TRUE, TRUE);

			return FALSE;
		}
#endif
	}

	return FALSE;
}


bool CGame::bCheckClientMagicFrequency(int iClientH, DWORD dwClientTime)
{
	DWORD dwTimeGap;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	if (m_pClientList[iClientH]->m_dwMagicFreqTime == NULL) 
		m_pClientList[iClientH]->m_dwMagicFreqTime = dwClientTime;
	else {
		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwMagicFreqTime;
		m_pClientList[iClientH]->m_dwMagicFreqTime = dwClientTime;

		if (dwTimeGap < 1500) {
			wsprintf(g_cTxt, "(!) Speed hack suspect(%s)", m_pClientList[iClientH]->m_cCharName);
			PutLogList(g_cTxt);
			DeleteClient(iClientH, TRUE, TRUE);

			return FALSE;
		}
	}

	return FALSE;
}


bool CGame::bCheckClientMoveFrequency(int iClientH, DWORD dwClientTime)
{
	DWORD dwTimeGap;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	if (m_pClientList[iClientH]->m_dwMoveFreqTime == NULL) 
		m_pClientList[iClientH]->m_dwMoveFreqTime = dwClientTime;
	else {
		if (m_pClientList[iClientH]->m_bIsMoveBlocked == TRUE) {
			m_pClientList[iClientH]->m_dwMoveFreqTime = NULL;
			m_pClientList[iClientH]->m_bIsMoveBlocked = FALSE;
			return FALSE;
		}

		if (m_pClientList[iClientH]->m_bIsAttackModeChange == TRUE) {
			m_pClientList[iClientH]->m_dwMoveFreqTime = NULL;
			m_pClientList[iClientH]->m_bIsAttackModeChange = FALSE;
			return FALSE;
		}

		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwMoveFreqTime;
		m_pClientList[iClientH]->m_dwMoveFreqTime = dwClientTime;

#ifndef NO_MSGSPEEDCHECK
		if (dwTimeGap < 250) {
			wsprintf(g_cTxt, "(!) Speed hack suspect(%s)", m_pClientList[iClientH]->m_cCharName);
			PutLogList(g_cTxt);
			DeleteClient(iClientH, TRUE, TRUE);

			return FALSE;
		}
#endif
	}

	return FALSE;
}

void CGame::SetForceRecallTime(int iClientH)
{
	int iTL_ = 0 ;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return ;

	if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {

		if (m_sForceRecallTime > 0 ) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sForceRecallTime ;
		}
		else {
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeMonday; break;  //  3 2002-09-10 #1
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeTuesday; break;  //  3 
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeWednesday; break;  //  3 
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeThursday; break;  //  3 
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeFriday; break; // 15
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSaturday; break; // 45 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSunday; break; // 60
			}
		}
	}
	else {
		if (m_sForceRecallTime > 0 ) {
			iTL_ =  20*m_sForceRecallTime ;
		}
		else {

			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	iTL_ = 20*m_sRaidTimeMonday; break;  //  3 2002-09-10 #1
			case 2:	iTL_ = 20*m_sRaidTimeTuesday; break;  //  3
			case 3:	iTL_ = 20*m_sRaidTimeWednesday; break;  //  3
			case 4:	iTL_ = 20*m_sRaidTimeThursday; break;  //  3
			case 5:	iTL_ = 20*m_sRaidTimeFriday; break; // 15
			case 6:	iTL_ = 20*m_sRaidTimeSaturday; break; // 45 
			case 0:	iTL_ = 20*m_sRaidTimeSunday; break; // 60
			}
		}

		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_) 
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = iTL_;
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
	}
	return ;
}

int CGame::iSetSide(int iClientH)
{
	if ( m_pClientList[iClientH] == NULL ) return -1;

	char	cLocationName[12], cMapLocationName[12];

	ZeroMemory(cLocationName, sizeof(cLocationName));
	ZeroMemory(cMapLocationName, sizeof(cMapLocationName));

	strcpy(cLocationName, m_pClientList[iClientH]->m_cLocation);
	strcpy(cMapLocationName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);

	m_pClientList[iClientH]->m_side = NEUTRAL ; 
	m_pClientList[iClientH]->m_iIsOnTown = PK;

	if (memcmp(cLocationName,cMapLocationName,3) == 0)
		m_pClientList[iClientH]->m_iIsOnTown = NONPK;

	if (memcmp(cLocationName, "are", 3) == 0) {
		m_pClientList[iClientH]->m_side = ARESDEN;
	} else if (memcmp(cLocationName, "elv", 3) == 0) {
		m_pClientList[iClientH]->m_side = ELVINE;
	} else if (memcmp(cLocationName, "ist", 3) == 0) {
		m_pClientList[iClientH]->m_side = ISTRIA;
	}
	else {
		if (strcmp(cMapLocationName, sideMap[ELVINE]) == 0 ||
			strcmp(cMapLocationName, sideMap[ARESDEN]) == 0 ||
			strcmp(cMapLocationName, sideMap[ISTRIA]) == 0)
		{
			m_pClientList[iClientH]->m_iIsOnTown = NONPK;
		}
		m_pClientList[iClientH]->m_bIsNeutral = FALSE ;
	}

	m_pClientList[iClientH]->SetSideFlag((Side) m_pClientList[iClientH]->m_side);

	if (memcmp(m_pClientList[iClientH]->m_cMapName, sideMap[NEUTRAL], 7) == 0) { // Jehovah - Added so trav's cannot fight in trav zone.
		m_pClientList[iClientH]->m_bIsNeutral = TRUE;
	}

	if((memcmp(m_pClientList[iClientH]->m_cMapName, "bsmith",6) == 0) ||
		(memcmp(m_pClientList[iClientH]->m_cMapName, "gldhall",7) == 0) ||
		(memcmp(m_pClientList[iClientH]->m_cMapName, "gshop",5) == 0) )
		m_pClientList[iClientH]->m_bIsOnShop = TRUE;
	else
		m_pClientList[iClientH]->m_bIsOnShop = FALSE;


	if(memcmp(m_pClientList[iClientH]->m_cMapName, "wrhus",5) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName + 3, "wrhus",5) == 0)
		m_pClientList[iClientH]->m_bIsOnWarehouse = TRUE;
	else
		m_pClientList[iClientH]->m_bIsOnWarehouse = FALSE;


	if(memcmp(m_pClientList[iClientH]->m_cMapName, "wzdtwr",6) == 0 )
		m_pClientList[iClientH]->m_bIsOnTower = TRUE;
	else
		m_pClientList[iClientH]->m_bIsOnTower = FALSE;

	return m_pClientList[iClientH]->m_side;
}



bool CGame::__bSetAgricultureItem(int iMapIndex, int dX, int dY, int iType,int iSsn, int iClientH)  
{
	int iNamingValue, tX, tY;
	char cNpcName[21], cName[21], cNpcWaypoint[11], cOwnerType;
	short sOwnerH;
	bool	iRet;

	//	//	if ((m_bIsCrusadeMode == FALSE) || (m_pClientList[iClientH]->m_iCrusadeDuty != 2)) return FALSE;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture >= MAXAGRICULTURE) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_NOMOREAGRICULTURE, NULL, NULL, NULL, NULL);
		return FALSE;
	}

	if(iSsn > m_pClientList[iClientH]->m_cSkillMastery[SKILL_FARMING]) 
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_AGRICULTURESKILLLIMIT, NULL, NULL, NULL, NULL);  //??
		return FALSE;
	}

	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue != -1) {
		//		for (ix = dX -1; ix <= dX +3; ix++)
		//		for (iy = dY -1; iy <= dY +3; iy++) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		if ((sOwnerH != NULL) && (cOwnerType == OWNERTYPE_NPC) && (m_pNpcList[sOwnerH]->m_cActionLimit == 5))
		{
			SendNotifyMsg(NULL, iClientH, NOTIFY_AGRICULTURENOAREA, NULL, NULL, NULL, NULL);
			return FALSE;
		}
		// 		}

		if(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsFarm(dX,dY) == FALSE)
		{
			SendNotifyMsg(NULL, iClientH, NOTIFY_AGRICULTURENOAREA, NULL, NULL, NULL, NULL);
			return FALSE;
		}

		ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy(cNpcName, "Crops");

		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;

		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

		tX = (int)dX;
		tY = (int)dY;

		iRet = bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, 
			MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, FALSE, 0 , FALSE, TRUE);

		if ( iRet == FALSE) {
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
		} 
		else {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
			if(m_pNpcList[sOwnerH] == NULL) return FALSE;
			
			m_pNpcList[sOwnerH]->m_iNpcCrops = iType;
			switch (iType) 
			{
			case 1: 
			case 2: 
			case 3: 
			case 4: 
			case 5: 
			case 6: 
			case 7: 
			case 8: 
			case 9: 
			case 10: 
			case 11: 
			case 12: 
			case 13:
			case 14:
				m_pNpcList[sOwnerH]->m_iCropsSkillLV = iSsn;
				break;
			default: 
				m_pNpcList[sOwnerH]->m_iCropsSkillLV = 100;
				break;
			}

			m_pNpcList[sOwnerH]->m_sAppr2 = iType << 8 | 1;
			//			m_pNpcList[iRet]->m_sAppr2 = (char)1;

			SendEventToNearClient_TypeA(sOwnerH, OWNERTYPE_NPC, MSGID_EVENT_LOG, MSGTYPE_CONFIRM, NULL, NULL, NULL);

			//wsprintf(g_cTxt, "plant(%s) Agriculture begin(%d,%d) sum(%d)!", cNpcName, tX, tY,
			//	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture);
			//PutLogList(g_cTxt);
			return TRUE;
		}
	}

	return FALSE;
}

void CGame::AdminOrder_CheckRep(int iClientH, char *pData,DWORD dwMsgSize)
{
	short m_iRating;
	char   * token, cName[11], cTargetName[11], cRepMessage[256], cTemp[256], seps[] = "= \t\n", cBuff[256];
	register int i;

	if (m_pClientList[iClientH] == NULL) return;
	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cRepMessage, sizeof(cRepMessage));

	wsprintf(cRepMessage, " You have %d reputation points.", m_pClientList[iClientH]->m_reputation);
	ShowClientMsg(iClientH, cRepMessage);

	if ((dwMsgSize)	<= 0) return;
	if (!m_pClientList[iClientH]->IsGM()) return;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	} 
	else {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, "null");
	}

	token = pStrTok->pGet();

	if (token != NULL) {
		m_iRating = atoi(token);
	} 

	if (token == NULL) {
		token = "null"; 
	}

	if (cName != NULL) {
		token = cName;

		if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
				wsprintf(cRepMessage, " %s has %d reputation points.", m_pClientList[i]->m_cCharName, m_pClientList[i]->m_reputation);
				ShowClientMsg(iClientH, cRepMessage);
			}
	}
}


//////////////////////////////////////////////////////////////////////////////////////////////
//		bool bCropsItemDrop(int iClientH, short iTargetH,bool bMobDropPos)  

//////////////////////////////////////////////////////////////////////////////////////////////
bool CGame::bCropsItemDrop(int iClientH, short iTargetH,bool bMobDropPos)  
{
	class CItem * pItem;
	int	  iItemID = 0 ;
	int	  iSeedID = 0 ;

	iSeedID = m_pNpcList[iTargetH]->m_iNpcCrops;

	switch (iSeedID) 
	{
	case 1: iItemID = 820;	GetExp(iClientH, dice(3, 10));  break;
	case 2: iItemID = 821;	GetExp(iClientH, dice(3, 10));  break;
	case 3: iItemID = 822;	GetExp(iClientH, dice(4, 10));  break;
	case 4: iItemID = 823;	GetExp(iClientH, dice(4, 10));  break;
	case 5: iItemID = 824;	GetExp(iClientH, dice(5, 10)); 	break;
	case 6: iItemID = 825;	GetExp(iClientH, dice(5, 10));  break;
	case 7: iItemID = 826;	GetExp(iClientH, dice(6, 10));  break;
	case 8: iItemID = 827;	GetExp(iClientH, dice(6, 10));  break;
	case 9: iItemID = 828;	GetExp(iClientH, dice(7, 10));  break;
	case 10: iItemID = 829;	GetExp(iClientH, dice(7, 10));  break;
	case 11: iItemID = 830;	GetExp(iClientH, dice(8, 10));  break;
	case 12: iItemID = 831; GetExp(iClientH, dice(8, 10));  break;
	case 13: iItemID = 832;	GetExp(iClientH, dice(9, 10));  break;
	case 14: iItemID = 731;	GetExp(iClientH, dice(10, 10)); break;
	default: return FALSE;
	}

	pItem = new class CItem;
	if (_bInitItemAttr(pItem, iItemID) == FALSE) {
		delete pItem;
		return FALSE;
	}
	else {
		if( bMobDropPos == FALSE)
		{
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
				m_pClientList[iClientH]->m_sY, pItem);

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 
		}
		else
		{
			m_pMapList[ m_pNpcList[iTargetH]->m_cMapIndex ]->bSetItem(m_pNpcList[iTargetH]->m_sX, 
				m_pNpcList[iTargetH]->m_sY, 
				pItem);


			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pNpcList[iTargetH]->m_cMapIndex,
				m_pNpcList[iTargetH]->m_sX, m_pNpcList[iTargetH]->m_sY,
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
		}
	}

	return TRUE;
}

//=============================================================================
bool CGame::IsDatePast(char *Date)
{
	char *token;
	SYSTEMTIME SysTime;

	char seps[] = " :-";
	StrTok pStrTok(new CStrTok(Date, seps));

	GetLocalTime(&SysTime);

	token = pStrTok->pGet();
	if(atoi(token) < SysTime.wYear){
		return true;
	}
	else if (atoi(token) > SysTime.wYear){
		return false;
	}

	token = pStrTok->pGet();
	if(atoi(token) < SysTime.wMonth){
		return true;
	}
	else if(atoi(token) > SysTime.wMonth){
		return false;
	}

	token = pStrTok->pGet();
	if(atoi(token) < SysTime.wDay){
		return true;
	}
	else if(atoi(token) > SysTime.wDay){
		return false;
	}

	token = pStrTok->pGet();
	if(atoi(token) < SysTime.wHour){
		return true;
	}
	else if(atoi(token) > SysTime.wHour){
		return false;
	}

	token = pStrTok->pGet();
	if(atoi(token) < SysTime.wMinute){
		return true;
	}
	else if(atoi(token) > SysTime.wMinute){
		return false;
	}

	token = pStrTok->pGet();
	if(atoi(token) < SysTime.wSecond){
		return true;
	}
	else if(atoi(token) > SysTime.wSecond){
		return false;
	}

	return true;
}
/*********************************************************************************************************************
**  BOOL CGame::SetAngel(short sOwnerH, char cOwnerType, int iStatus, iTemp)  Snoopy   ** 
** description   :: Sets the status to send or not Angels to every client       **
*********************************************************************************************************************/
void CGame::SetAngel(short sOwnerH, char cOwnerType, int iStatus, bool notify) 
{
	if (cOwnerType != OWNERTYPE_PLAYER) return;
	if (m_pClientList[sOwnerH] == NULL) return;
	switch (iStatus) {
	case 1: // STR Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | STATUS_ANGELSTR;  
		break;
	case 2: // DEX Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | STATUS_ANGELDEX;
		break;
	case 3: // INT Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | STATUS_ANGELINT;
		break;
	case 4: // MAG Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | STATUS_ANGELMAG;
		break;
	default:
	case 0: // Remove all Angels
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFF0FFF;
		break;
	}
	if(notify)
		SendEventToNearClient_TypeA(sOwnerH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTNULLACTION, NULL, NULL, NULL);
}

/*********************************************************************************************************************
**  BOOL CGame::GetAngelHandler(int iClientH, char * pData, DWORD dwMsgSize)          ** 
** description   :: Reversed and coded by Snoopy                 **
*********************************************************************************************************************/
/*
void CGame::GetAngelHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
char  *cp, cData[256], cTmpName[21];
int   iAngel, iItemNbe;
class CItem * pItem;
int   iRet, iEraseReq;
short * sp;
WORD  * wp;
int   * ip;
DWORD * dwp;

if (m_pClientList[iClientH] == NULL)      return;
if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

if (_iGetItemSpaceLeft(iClientH) == 0) 
{ SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
return;
}

if(m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 5 )
return;

m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= 5;
SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);

cp = (char *)(pData + INDEX2_MSGTYPE + 2);
ZeroMemory(cTmpName, sizeof(cTmpName));
strcpy(cTmpName, cp);
cp += 20;
ip = (int *)cp;
iAngel = (int) *ip; // 0x00 l a i
cp += 2;
wsprintf(g_cTxt, "PC(%s) obtained an Angel (%d).   %s(%d %d)"
, m_pClientList[iClientH]->m_cCharName
, iAngel
, m_pClientList[iClientH]->m_cMapName
, m_pClientList[iClientH]->m_sX
, m_pClientList[iClientH]->m_sY); 
PutLogList(g_cTxt); 
switch (iAngel) {
case 1: // STR
iItemNbe = 908;
break;
case 2: // DEX
iItemNbe = 909;
break;
case 3: // INT
iItemNbe = 910;
break;
case 4: // MAG
iItemNbe = 911;
break;
default:
PutLogList("Gail asked to create a wrong item!"); 
break;
}
pItem = NULL;
pItem = new class CItem;
if (pItem == NULL) return;
if ((_bInitItemAttr(pItem, iItemNbe) == TRUE)) 
{ pItem->m_sTouchEffectType = ITET_UNIQUE_OWNER;
pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
{ ZeroMemory(cData, sizeof(cData));
dwp  = (DWORD *)(cData + INDEX4_MSGID);
*dwp = MSGID_NOTIFY;
wp   = (WORD *)(cData + INDEX2_MSGTYPE);
*wp  = NOTIFY_ITEMOBTAINED;    
cp = (char *)(cData + INDEX2_MSGTYPE + 2);    
*cp = 1;
cp++;    
memcpy(cp, pItem->m_cName, 20);
cp += 20;    
dwp  = (DWORD *)cp;
*dwp = pItem->m_dwCount;
cp += 4;    
*cp = pItem->m_cItemType;
cp++;    
*cp = pItem->m_cEquipPos;
cp++;    
*cp = (char)0; 
cp++;    
sp  = (short *)cp;
*sp = pItem->m_sLevelLimit;
cp += 2;    
*cp = pItem->m_cGenderLimit;
cp++;    
wp = (WORD *)cp;
*wp = pItem->m_wCurLifeSpan;
cp += 2;    
wp = (WORD *)cp;
*wp = pItem->m_wWeight;
cp += 2;    
sp  = (short *)cp;
*sp = pItem->m_sSprite;
cp += 2;    
sp  = (short *)cp;
*sp = pItem->m_sSpriteFrame;
cp += 2;
*cp = pItem->m_cItemColor;
cp++;
*cp = (char)pItem->m_sItemSpecEffectValue2; 
cp++;    
dwp = (DWORD *)cp;
*dwp = pItem->m_dwAttribute;
cp += 4;
if (iEraseReq == 1) delete pItem;    
iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
switch (iRet) {
case XSOCKEVENT_QUENEFULL:
case XSOCKEVENT_SOCKETERROR:
case XSOCKEVENT_CRITICALERROR:
case XSOCKEVENT_SOCKETCLOSED:
DeleteClient(iClientH, TRUE, TRUE);
break;
}
}else 
{ m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
m_pClientList[iClientH]->m_sY, pItem);   
SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 
dwp  = (DWORD *)(cData + INDEX4_MSGID);
*dwp = MSGID_NOTIFY;
wp   = (WORD *)(cData + INDEX2_MSGTYPE);
*wp  = NOTIFY_CANNOTCARRYMOREITEM;    
iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
switch (iRet) {
case XSOCKEVENT_QUENEFULL:
case XSOCKEVENT_SOCKETERROR:
case XSOCKEVENT_CRITICALERROR:
case XSOCKEVENT_SOCKETCLOSED:
DeleteClient(iClientH, TRUE, TRUE);
break;
} }
}else 
{ delete pItem;
pItem = NULL;
} 
} */


void CGame::GetAngelHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
	char  *cp, cTmpName[21];
	int   iAngel;
	class CItem * pItem;
	int   iEraseReq;
	char  cItemName[21];
	int   * ip;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (_iGetItemSpaceLeft(iClientH) == 0) 
	{
		SendItemNotifyMsg(iClientH,	NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, false);
		return;
	} 

	if(m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 5 )
		return;

	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= 5;
	SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, cp);
	cp += 20;
	ip = (int *)cp;
	iAngel = (int) *ip;
	cp += 2;
	wsprintf(g_cTxt, "PC(%s) obtained an Angel (%d).   %s(%d %d)"
		, m_pClientList[iClientH]->m_cCharName
		, iAngel
		, m_pClientList[iClientH]->m_cMapName
		, m_pClientList[iClientH]->m_sX
		, m_pClientList[iClientH]->m_sY); 
	PutLogList(g_cTxt); 
	switch (iAngel) {
	case 1:
		wsprintf(cItemName, "AngelicPendant(STR)");
		break;
	case 2:
		wsprintf(cItemName, "AngelicPendant(DEX)");
		break;
	case 3:
		wsprintf(cItemName, "AngelicPendant(INT)");
		break;
	case 4:
		wsprintf(cItemName, "AngelicPendant(MAG)");
		break;
	default:
		PutLogList("Gail asked to create a wrong item!");
		break;
	}
	pItem = NULL;
	pItem = new class CItem;
	if (pItem == NULL) return;
	if ((_bInitItemAttr(pItem, cItemName) == TRUE)) 
	{
		pItem->m_sTouchEffectType = ITET_UNIQUE_OWNER;
		pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
		pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
		pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
		{
			SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);
		
			if (iEraseReq == 1) delete pItem;    
			
		}else { 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
				m_pClientList[iClientH]->m_sY, pItem);   
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 
			SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
		}
	}else { 
		delete pItem;
		pItem = NULL;
	} 
} 

// Jehovah - Coded a DK item handler for cityhall from snoopys function.
void CGame::GetDKItemHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
	char  *cp, cTmpName[21];
	int   iAngel;
	class CItem * pItem;
	int   iEraseReq;
	char  cItemName[21];
	int   * ip;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (_iGetItemSpaceLeft(iClientH) == 0) 
	{
		SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, false);
		return;
	}
	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, cp);
	cp += 20;
	ip = (int *)cp;
	iAngel = (int) *ip;
	cp += 2;
	switch (iAngel) 
	{
		// Knight Items
	case 1:
		if (m_pClientList[iClientH]->m_cSex == MALE) wsprintf(cItemName, "DKFullHelm(M)");
		else if (m_pClientList[iClientH]->m_cSex == FEMALE) wsprintf(cItemName, "DKFullHelm(W)");
		break;
	case 2:
		if (m_pClientList[iClientH]->m_cSex == MALE) wsprintf(cItemName, "DKHauberk(M)");
		else if (m_pClientList[iClientH]->m_cSex == FEMALE) wsprintf(cItemName, "DKHauberk(W)");
		break;
	case 3:
		if (m_pClientList[iClientH]->m_cSex == MALE) wsprintf(cItemName, "DKPlateMail(M)");
		else if (m_pClientList[iClientH]->m_cSex == FEMALE) wsprintf(cItemName, "DKPlateMail(W)");
		break;
	case 4:
		if (m_pClientList[iClientH]->m_cSex == MALE) wsprintf(cItemName, "DKLeggings(M)");
		else if (m_pClientList[iClientH]->m_cSex == FEMALE) wsprintf(cItemName, "DKLeggings(W)");
		break;

		// Mage Items
	case 5:
		if (m_pClientList[iClientH]->m_cSex == MALE) wsprintf(cItemName, "DMHat(M)");
		else if (m_pClientList[iClientH]->m_cSex == FEMALE) wsprintf(cItemName, "DMHat(W)");
		break;
	case 6:
		if (m_pClientList[iClientH]->m_cSex == MALE) wsprintf(cItemName, "DMHauberk(M)");
		else if (m_pClientList[iClientH]->m_cSex == FEMALE) wsprintf(cItemName, "DMHauberk(W)");
		break;
	case 7:
		if (m_pClientList[iClientH]->m_cSex == MALE) wsprintf(cItemName, "DMRobe(M)");
		else if (m_pClientList[iClientH]->m_cSex == FEMALE) wsprintf(cItemName, "DMRobe(W)");
		break;
	case 8:
		if (m_pClientList[iClientH]->m_cSex == MALE) wsprintf(cItemName, "DMChainMail(M)");
		else if (m_pClientList[iClientH]->m_cSex == FEMALE) wsprintf(cItemName, "DMChainMail(W)");
		break;
	case 9:
		if (m_pClientList[iClientH]->m_cSex == MALE) wsprintf(cItemName, "DMLeggings(M)");
		else if (m_pClientList[iClientH]->m_cSex == FEMALE) wsprintf(cItemName, "DMLeggings(W)");
		break;

		// Weapons
	case 10:
		wsprintf(cItemName, "DMMagicStaff");
		break;
	case 11:
		wsprintf(cItemName, "DKRapier");
		break;
	case 12:
		wsprintf(cItemName, "DKGreatSword");
		break;
	case 13:
		wsprintf(cItemName, "DKFlameberg");
		break;

	default:
		PutLogList("Gail asked to create a wrong item!");
		break;
	}
	pItem = NULL;
	pItem = new class CItem;
	if (pItem == NULL) return;
	if ((_bInitItemAttr(pItem, cItemName) == TRUE)) 
	{
		pItem->m_sTouchEffectType = ITET_UNIQUE_OWNER;
		pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
		pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
		pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
		{
			SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);

			if (iEraseReq == 1) delete pItem;
			
			/*	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= iRequiredMagesty; 
			SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL); */
		}
		else 
		{
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
			SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
		}
	}
	else 
	{
		delete pItem;
		pItem = NULL;
	}
}

void CGame::PlayerOrder_SetAFK(int iClientH)
{
	if (m_pClientList[iClientH]->GetStatusFlag(STATUS_AFK)){
		SendNotifyMsg(NULL, iClientH, NOTIFY_NOTICEMSG, NULL, NULL, NULL, "You are no longer AFK.");
		m_pClientList[iClientH]->SetStatusFlag(STATUS_AFK, FALSE);

	}else
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_NOTICEMSG, NULL, NULL, NULL, "You are now AFK.");
		m_pClientList[iClientH]->SetStatusFlag(STATUS_AFK, TRUE);

	}
}

void CGame::ReqCreateSlateHandler(int iClientH, char* pData)
{
	int i;
	char cItemID[4], ctr[4];
	char *cp, cSlateColour, cData[120];
	BOOL bIsSlatePresent = FALSE;
	CItem * pItem;
	int iSlateType, iEraseReq;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;

	for(i = 0; i < 4; i++){
		cItemID[i] = 0;
		ctr[i] = 0;
	}

	cp = (char *)pData;
	cp += 11;

	// 35% chance of creating slates
	if (dice(1,100) < m_sSlateSuccessRate) bIsSlatePresent = TRUE;

	try{
		// make sure slates really exist
		for(i = 0; i < 4; i++){
			cItemID[i] = *cp;
			cp++;

			if(m_pClientList[iClientH]->m_pItemList[cItemID[i]] == NULL || cItemID[i] >MAXITEMS) {
				bIsSlatePresent = FALSE;
				SendNotifyMsg(NULL, iClientH, NOTIFY_SLATE_CREATEFAIL, NULL, NULL, NULL, NULL);  
				return; 
			}

			//No duping
			if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == ITEM_ANCIENTTABLET_LU) // AncientTablet(LU)
				ctr[0] = 1;
			else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == ITEM_ANCIENTTABLET_LD) // AncientTablet(LD)
				ctr[1] = 1;
			else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == ITEM_ANCIENTTABLET_RU) // AncientTablet(RU)
				ctr[2] = 1;
			else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == ITEM_ANCIENTTABLET_RD) // AncientTablet(RD)
				ctr[3] = 1;
		}
	}
	catch(...){
		//Crash Hacker Caught
		bIsSlatePresent = FALSE;
		SendNotifyMsg(NULL, iClientH, NOTIFY_SLATE_CREATEFAIL, NULL, NULL, NULL, NULL);  
		wsprintf(g_cTxt, "TSearch Slate Hack: (%s) Player: (%s) - creating slates without correct item!", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutLogList(g_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}

	// Are all 4 slates present ??
	if (ctr[0] != 1 || ctr[1] != 1 || ctr[2] != 1 || ctr[3] != 1) {
		bIsSlatePresent = FALSE;
		return; 
	}

	if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) bIsSlatePresent = TRUE;

	// if we failed, kill everything
	if (!bIsSlatePresent) {
		for(i = 0; i < 4; i++) {
			if(m_pClientList[iClientH]->m_pItemList[cItemID[i]] != NULL) {
				ItemDepleteHandler(iClientH,cItemID[i], FALSE, FALSE);
			}
		} 
		SendNotifyMsg(NULL, iClientH, NOTIFY_SLATE_CREATEFAIL, NULL, NULL, NULL, NULL); 
		return; 
	}

	// make the slates
	for(i = 0; i < 4; i++){
		if(m_pClientList[iClientH]->m_pItemList[cItemID[i]] != NULL) {
			ItemDepleteHandler(iClientH,cItemID[i], FALSE, FALSE);
		}
	}

	pItem = new class CItem;

	i = dice(1,1000);

	if (i < 50) { // Health Slate
		iSlateType = 1;
		cSlateColour = 32;
	}
	else if (i < 250) { // Berserk Slate
		iSlateType = 2;
		cSlateColour = 3;
	}
	else if (i < 750) { // Experience Slate
		iSlateType = 4;
		cSlateColour = 7;
	}
	else if (i < 950) { // Mana slate
		iSlateType = 3;
		cSlateColour = 37;
	}
	else if (i <  1001) { // Health Slate
		iSlateType = 1;
		cSlateColour = 32;
	}

	// Notify client
	SendNotifyMsg(NULL, iClientH, NOTIFY_SLATE_CREATESUCCESS, iSlateType, NULL, NULL, NULL);

	ZeroMemory(cData,sizeof(cData));

	// Create slates
	if (_bInitItemAttr(pItem, ITEM_ANCIENTTABLET) == FALSE) {
		delete pItem;
		return;
	}
	else{
		pItem->m_sTouchEffectType   = ITET_ID;
		pItem->m_sTouchEffectValue1 = dice(1,100000);
		pItem->m_sTouchEffectValue2 = dice(1,100000);
		pItem->m_sTouchEffectValue3 = (short)timeGetTime();

		_bItemLog(ITEMLOG_GET, iClientH, -1, pItem);

		pItem->m_sItemSpecEffectValue2 = iSlateType;
		pItem->m_cItemColor = cSlateColour;
		if(_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE){
			SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);

			if (iEraseReq == 1) delete pItem;
		}
		else{
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem->m_sSprite, pItem->m_sSpriteFrame,
				pItem->m_cItemColor);
			SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
		}
	}
}

void CGame::SetSlateFlag(int iClientH, short sType, bool bFlag)
{
	if (m_pClientList[iClientH] == NULL) return;

	if (sType == NOTIFY_SLATECLEAR) {
		m_pClientList[iClientH]->m_iStatus &= STATUS_ALL - STATUS_REDSLATE;
		m_pClientList[iClientH]->m_iStatus &= STATUS_ALL - STATUS_BLUESLATE;
		m_pClientList[iClientH]->m_iStatus &= STATUS_ALL - STATUS_GREENSLATE;
		return;
	}

	if (bFlag == TRUE) {
		if (sType == 1) { // Invincible slate
			m_pClientList[iClientH]->m_iStatus |= STATUS_REDSLATE;
		}
		else if (sType == 3) { // Mana slate
			m_pClientList[iClientH]->m_iStatus |= STATUS_BLUESLATE;
		}
		else if (sType == 4) { // Exp slate
			m_pClientList[iClientH]->m_iStatus |= STATUS_GREENSLATE;
		}
	}
	else{
		if ((m_pClientList[iClientH]->m_iStatus & STATUS_REDSLATE) != 0) {
			m_pClientList[iClientH]->m_iStatus &= STATUS_ALL - STATUS_REDSLATE;
		}
		else if ((m_pClientList[iClientH]->m_iStatus & STATUS_BLUESLATE) != 0) {
			m_pClientList[iClientH]->m_iStatus &= STATUS_ALL - STATUS_BLUESLATE;
		}
		else if ((m_pClientList[iClientH]->m_iStatus & STATUS_GREENSLATE) != 0) {
			m_pClientList[iClientH]->m_iStatus &= STATUS_ALL - STATUS_GREENSLATE;
		}
	}

	SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTNULLACTION, NULL, NULL, NULL);
}

void CGame::AdminOrder_GoTo(int iClientH, char* pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cPlayerName[11],cMapName[32];
	char *cp;
	WORD *wp;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();

	token = pStrTok->pGet();
	if (token == NULL) {
		return;
	}

	if (strlen(token) > 10) {
		memcpy(cPlayerName,token,10);
	}
	else{
		memcpy(cPlayerName,token,strlen(token));
	}

	for(int i = 1; i < MAXCLIENTS; i++){
		if (m_pClientList[i] != NULL) {
			if (memcmp(cPlayerName,m_pClientList[i]->m_cCharName, 10) == 0) {
					if(m_pClientList[i]->m_sX == -1 && m_pClientList[i]->m_sX == -1){
						wsprintf(cBuff,"GM Order(%s): GoTo MapName(%s)",m_pClientList[iClientH]->m_cCharName,m_pClientList[i]->m_cMapName);
					}
					else{
						wsprintf(cBuff,"GM Order(%s): GoTo MapName(%s)(%d %d)",m_pClientList[iClientH]->m_cCharName,
							m_pClientList[i]->m_cMapName,m_pClientList[i]->m_sX,m_pClientList[i]->m_sY);
					}
					bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH,FALSE,cBuff);
					ZeroMemory(cMapName,sizeof(cMapName));
					strcpy(cMapName, m_pClientList[i]->m_cMapName);
					RequestTeleportHandler(iClientH, 2 , cMapName, m_pClientList[i]->m_sX,m_pClientList[i]->m_sY);

				return;
			}
		}
	}

	ZeroMemory(cBuff,sizeof(cBuff));

	cp = (char *)cBuff;
	*cp = GSM_REQUEST_FINDCHARACTER;
	cp++;

	wp = (WORD *)cp;
	*wp = GSID;
	cp += 2;

	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	memcpy(cp,cPlayerName,10);
	cp += 10;

	memcpy(cp,m_pClientList[iClientH]->m_cCharName,10);
	cp += 10;

	bStockMsgToGateServer(cBuff,25);

}

void CGame::AdminOrder_Pushplayer(int iClientH, char * pData, DWORD dwMsgSize)
{
	//Push Player- By:ACiDx  Monday , September 2004
	//Teleports a Defined Player to Defined Destination
	// /push playername mapname sX dX
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cMapName[256], cName[11], cTargetName[11];
	register int dX, dY;
	register int i;
	BOOL   bFlag;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));

	dX = dY = -1;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();


	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	} else return;

	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dY = atoi(token);
	}

	if (token == NULL) { token = "null"; }
	if (cName != NULL) {
		token = cName;

		if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
				bFlag = FALSE;
				//Asks For Flag on maps
				if (strcmp("2ndmiddle", cMapName) == 0) bFlag = TRUE;
				if (strcmp("abaddon", cMapName) == 0) bFlag = TRUE; 
				if (strcmp("arebrk11", cMapName) == 0) bFlag = TRUE;
				if (strcmp("arebrk12", cMapName) == 0) bFlag = TRUE;
				if (strcmp("arebrk21", cMapName) == 0) bFlag = TRUE;
				if (strcmp("arebrk22", cMapName) == 0) bFlag = TRUE;
				if (strcmp("arefarm", cMapName) == 0) bFlag = TRUE;
				if (strcmp("arejail", cMapName) == 0) bFlag = TRUE;
				if (strcmp("aremidl", cMapName) == 0) bFlag = TRUE;
				if (strcmp("aremidr", cMapName) == 0) bFlag = TRUE;
				if (strcmp(sideMap[ARESDEN], cMapName) == 0) bFlag = TRUE;
				if (strcmp("aresdend1", cMapName) == 0) bFlag = TRUE;
				if (strcmp("areuni", cMapName) == 0) bFlag = TRUE;
				if (strcmp("arewrhus", cMapName) == 0) bFlag = TRUE;
				if (strcmp("bisle", cMapName) == 0)   bFlag = TRUE;
				if (strcmp("bsmith_1", cMapName) == 0) bFlag = TRUE;
				if (strcmp("bsmith_1f", cMapName) == 0) bFlag = TRUE;
				if (strcmp("bsmith_2", cMapName) == 0) bFlag = TRUE;
				if (strcmp("bsmith_2f", cMapName) == 0) bFlag = TRUE;
				if (strcmp("BtField", cMapName) == 0) bFlag = TRUE;
				if (strcmp("cath_1", cMapName) == 0) bFlag = TRUE;
				if (strcmp("cath_2", cMapName) == 0)      bFlag = TRUE;
				if (strcmp("cityhall_1", cMapName) == 0) bFlag = TRUE;
				if (strcmp("cityhall_2", cMapName) == 0) bFlag = TRUE;
				if (strcmp("CmdHall_1", cMapName) == 0) bFlag = TRUE;
				if (strcmp("CmdHall_2", cMapName) == 0) bFlag = TRUE;
				if (strcmp(sideMap[NEUTRAL], cMapName) == 0) bFlag = TRUE;
				if (strcmp("dglv2", cMapName) == 0) bFlag = TRUE;
				if (strcmp("dglv3", cMapName) == 0) bFlag = TRUE;
				if (strcmp("dglv4", cMapName) == 0) bFlag = TRUE;
				if (strcmp("druncncity", cMapName) == 0) bFlag = TRUE; 
				if (strcmp("elvbrk11", cMapName) == 0) bFlag = TRUE;
				if (strcmp("elvbrk12", cMapName) == 0) bFlag = TRUE;
				if (strcmp("elvbrk21", cMapName) == 0) bFlag = TRUE;
				if (strcmp("elvbrk22", cMapName) == 0) bFlag = TRUE;
				if (strcmp("elvfarm", cMapName) == 0) bFlag = TRUE;
				if (strcmp(sideMap[ELVINE], cMapName) == 0)  bFlag = TRUE;
				if (strcmp("elvined1", cMapName) == 0)    bFlag = TRUE;
				if (strcmp("elvjail", cMapName) == 0)    bFlag = TRUE;
				if (strcmp("elvmidl", cMapName) == 0) bFlag = TRUE;
				if (strcmp("elvmidr", cMapName) == 0) bFlag = TRUE;
				if (strcmp("elvuni", cMapName) == 0) bFlag = TRUE;
				if (strcmp("elvwrhus", cMapName) == 0) bFlag = TRUE;
				if (strcmp("fightzone1", cMapName) == 0) bFlag = TRUE;
				if (strcmp("fightzone2", cMapName) == 0) bFlag = TRUE;
				if (strcmp("fightzone3", cMapName) == 0) bFlag = TRUE;
				if (strcmp("fightzone4", cMapName) == 0) bFlag = TRUE;
				if (strcmp("fightzone5", cMapName) == 0) bFlag = TRUE;
				if (strcmp("fightzone6", cMapName) == 0) bFlag = TRUE;
				if (strcmp("fightzone7", cMapName) == 0) bFlag = TRUE;
				if (strcmp("fightzone8", cMapName) == 0) bFlag = TRUE;
				if (strcmp("fightzone9", cMapName) == 0) bFlag = TRUE;
				if (strcmp("fightzone10", cMapName) == 0) bFlag = TRUE;
				if (strcmp("gldhall_1", cMapName) == 0) bFlag = TRUE;
				if (strcmp("gldhall_2", cMapName) == 0)   bFlag = TRUE;
				if (strcmp("GodH", cMapName) == 0)   bFlag = TRUE;
				if (strcmp("gshop_1", cMapName) == 0) bFlag = TRUE;
				if (strcmp("gshop_1f", cMapName) == 0) bFlag = TRUE;
				if (strcmp("gshop_2", cMapName) == 0)     bFlag = TRUE;
				if (strcmp("gshop_2f", cMapName) == 0)     bFlag = TRUE;
				if (strcmp("HRampart", cMapName) == 0)     bFlag = TRUE;
				if (strcmp("huntzone1", cMapName) == 0) bFlag = TRUE;
				if (strcmp("huntzone2", cMapName) == 0) bFlag = TRUE;
				if (strcmp("huntzone3", cMapName) == 0) bFlag = TRUE;
				if (strcmp("huntzone4", cMapName) == 0) bFlag = TRUE;
				if (strcmp("icebound", cMapName) == 0) bFlag = TRUE; 
				if (strcmp("inferniaA", cMapName) == 0) bFlag = TRUE; 
				if (strcmp("inferniaB", cMapName) == 0) bFlag = TRUE; 
				if (strcmp("maze", cMapName) == 0) bFlag = TRUE; 
				if (strcmp("middled1n", cMapName) == 0) bFlag = TRUE;
				if (strcmp("middled1x", cMapName) == 0) bFlag = TRUE;
				if (strcmp("middleland", cMapName) == 0) bFlag = TRUE;
				if (strcmp("penalty", cMapName) == 0) bFlag = TRUE;
				if (strcmp("procella", cMapName) == 0) bFlag = TRUE;
				if (strcmp("resurr1", cMapName) == 0) bFlag = TRUE;
				if (strcmp("resurr2", cMapName) == 0) bFlag = TRUE;
				if (strcmp("toh1", cMapName) == 0) bFlag = TRUE;
				if (strcmp("toh2", cMapName) == 0) bFlag = TRUE;
				if (strcmp("toh3", cMapName) == 0) bFlag = TRUE;
				if (strcmp("wrhus_1", cMapName) == 0) bFlag = TRUE;
				if (strcmp("wrhus_1f", cMapName) == 0) bFlag = TRUE;
				if (strcmp("wrhus_2", cMapName) == 0)     bFlag = TRUE;
				if (strcmp("wrhus_2f", cMapName) == 0)     bFlag = TRUE;
				if (strcmp("wzdtwr_1", cMapName) == 0) bFlag = TRUE;
				if (strcmp("wzdtwr_2", cMapName) == 0) bFlag = TRUE;
				if (strcmp("barracks1", cMapName) == 0) bFlag = TRUE;
				if (strcmp("barracks2", cMapName) == 0) bFlag = TRUE;
				if (strcmp("bsmith", cMapName) == 0) bFlag = TRUE;

				//Defines I as Max clients
				if (bFlag == TRUE)
					//Reqeust the Push/Teleport
					RequestTeleportHandler(i, 2, cMapName, dX, dY);
				wsprintf(g_cTxt,"(%s) GM(%s) sends (%s) Player(%s) to [%s](%d,%d)",m_pClientList[iClientH]->m_cIPaddress, 
					m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cIPaddress, m_pClientList[i]->m_cCharName, cMapName, dX, dY);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, g_cTxt);
				return;
			}
	}
}

void CGame::StateChangeHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
	char * cp, cStateChange1, cStateChange2, cStateChange3;
	char cStr, cVit, cDex, cInt, cMag, cChar;
	int iOldStr, iOldVit, iOldDex, iOldInt, iOldMag, iOldChar;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) return;

	cStr = cVit = cDex = cInt = cMag = cChar = 0;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	cStateChange1 = *cp;
	cp++;

	cStateChange2 = *cp;
	cp++;

	cStateChange3 = *cp;
	cp++;

	iOldStr	= m_pClientList[iClientH]->GetBaseStr();
	iOldVit	= m_pClientList[iClientH]->m_iVit;
	iOldDex = m_pClientList[iClientH]->GetBaseDex();
	iOldInt = m_pClientList[iClientH]->GetBaseInt();
	iOldMag = m_pClientList[iClientH]->GetBaseMag();
	iOldChar = m_pClientList[iClientH]->m_iRange;
	
	
	if(!ChangeState(cStateChange1,&cStr,&cVit,&cDex,&cInt,&cMag,&cChar))
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if(!ChangeState(cStateChange2,&cStr,&cVit,&cDex,&cInt,&cMag,&cChar))
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if(!ChangeState(cStateChange3,&cStr,&cVit,&cDex,&cInt,&cMag,&cChar))
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if(m_pClientList[iClientH]->m_iGuildRank == 0 )
	{
		if(m_pClientList[iClientH]->m_iRange - cChar < 20)
		{
			SendNotifyMsg(NULL, iClientH, NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
			return;
		}
	}

	if(iOldStr +iOldVit	+iOldDex +iOldInt +iOldMag +iOldChar != (179*3 + 70))
		return;


	if(cStr < 0 || cVit < 0 || cDex < 0 || cInt < 0 || cMag < 0 || cChar < 0
		|| cStr + cVit + cDex + cInt + cMag + cChar != 3)
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->GetBaseStr() - cStr > m_sCharStatLimit) 
		 || (m_pClientList[iClientH]->GetBaseStr() - cStr < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->GetBaseDex() - cDex > m_sCharStatLimit) 
		 || (m_pClientList[iClientH]->GetBaseDex() - cDex < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->GetBaseInt() - cInt > m_sCharStatLimit) 
		 || (m_pClientList[iClientH]->GetBaseInt() - cInt < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iVit - cVit > m_sCharStatLimit) 
		 || (m_pClientList[iClientH]->m_iVit - cVit < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->GetBaseMag() - cMag > m_sCharStatLimit) 
		 || (m_pClientList[iClientH]->GetBaseMag() - cMag < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iRange - cChar > m_sCharStatLimit)
		 || (m_pClientList[iClientH]->m_iRange - cChar < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if (m_pClientList[iClientH]->m_iLU_Pool < 3) m_pClientList[iClientH]->m_iLU_Pool = 3;

	//m_pClientList[iClientH]->m_iLU_Pool += 3;
	
	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft--;

	m_pClientList[iClientH]->SetStr( m_pClientList[iClientH]->GetBaseStr() - cStr);
	m_pClientList[iClientH]->m_iVit  -= cVit;
	if(m_pClientList[iClientH]->m_iHP > m_pClientList[iClientH]->GetMaxHP())
		m_pClientList[iClientH]->m_iHP = m_pClientList[iClientH]->GetMaxHP();
		
	m_pClientList[iClientH]->SetDex( m_pClientList[iClientH]->GetBaseDex() - cDex);
	m_pClientList[iClientH]->SetInt( m_pClientList[iClientH]->GetBaseInt() - cInt);
	if(cInt > 0)
		CheckMagicInt(iClientH);
	m_pClientList[iClientH]->SetMag( m_pClientList[iClientH]->GetBaseMag() - cMag);
	m_pClientList[iClientH]->m_iRange -= cChar;

	m_pClientList[iClientH]->ValidateSkills(FALSE);

	SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
	SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
}

BOOL CGame::CheckMagicInt(int iClientH)
{

	for(int i = 0;i < MAXMAGICTYPE ;i++)
	{
		if(m_pMagicConfigList[i] != NULL)
		if(m_pMagicConfigList[i]->m_sIntLimit > m_pClientList[iClientH]->GetInt())
		{
			m_pClientList[iClientH]->m_cMagicMastery[i] = 0;	
		}
	}

	return TRUE;
}

BOOL CGame::ChangeState(char cStateChange, char* cStr, char *cVit,char *cDex,char *cInt,char *cMag,char *cChar)
{
	if(cStateChange == MJSTAT_STR)
	{
		*cStr += 1;
	}
	else if(cStateChange == MJSTAT_VIT)
	{
		*cVit += 1;
//		if(m_pClientList[iClientH]->GetBaseStr() - cVit < 10 || m_pClientList[iClientH]->cVit - cVit < m_sCharStatLimit )
//			return 0;
	}
	else if(cStateChange == MJSTAT_DEX)
	{
		*cDex += 1;
	}
	else if(cStateChange == MJSTAT_INT)
	{
		*cInt += 1;
	}
	else if(cStateChange == MJSTAT_MAG)
	{
		*cMag += 1;
	}
	else if(cStateChange == MJSTAT_CHR)
	{
		*cChar += 1;
	}
	else
	{
		return FALSE;
	}

	return cStateChange;
}

void CGame::RequestResurrectPlayer(int iClientH, bool bResurrect)
{
	short sX, sY;
	char buff[100];

	if (m_pClientList[iClientH] == NULL) return;

	if (bResurrect == FALSE) {
		m_pClientList[iClientH]->m_bIsBeingResurrected = FALSE;
		return;
	}

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	if (m_pClientList[iClientH]->m_bIsBeingResurrected == FALSE) {
		wsprintf(buff, "(!!!) %s(%s) Tried To Use Resurrection Hack", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cIPaddress);
		PutLogList(buff);
		PutLogFileList(buff, HACK_LOGFILE);
		DeleteClient(iClientH, TRUE, TRUE, TRUE, TRUE);
		return;
	}

	m_pClientList[iClientH]->m_bIsKilled = FALSE;
	m_pClientList[iClientH]->m_iHP = m_pClientList[iClientH]->GetMaxHP() / 2; 
	//m_pClientList[iClientH]->m_iMP = ((m_pClientList[iClientH]->m_iMag*2)+(m_pClientList[iClientH]->m_iLevel/2))+m_pClientList[iClientH]->m_iInt/2;
	//m_pClientList[iClientH]->m_iSP = (m_pClientList[iClientH]->m_iStr*2)+(m_pClientList[iClientH]->m_iLevel/2);
	//m_pClientList[iClientH]->m_iHungerStatus = 100;

	m_pClientList[iClientH]->m_bIsBeingResurrected = FALSE;

	RequestTeleportHandler(iClientH, 2, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
}


static const Point ITEMSPREAD_FIXED_COORD [25] =
{
	{ 0,  0},	//1
	{ 1,  0},	//2
	{ 1,  1},	//3
	{ 0,  1},	//4
	{-1,  1},	//5
	{-1,  0},	//6
	{-1, -1},	//7
	{ 0, -1},	//8
	{ 1, -1},	//9
	{ 2, -1},	//10
	{ 2,  0},	//11
	{ 2,  1},	//12
	{ 2,  2},	//13
	{ 1,  2},	//14
	{ 0,  2},	//15
	{-1,  2},	//16
	{-2,  2},	//17
	{-2,  1},	//18
	{-2,  0},	//19
	{-2, -1},	//20
	{-2, -2},	//21
	{-1, -2},	//22
	{ 0, -2},	//23
	{ 1, -2},	//24
	{ 2, -2},	//25
};

uint32 CGame::RollMultiple(CNpc * npc, int iItemSpreadType, int iSpreadRange, int *iItemIDs, Point *BasePos)
{
	ItemID iItemID;
	uint32 num = 0;
	
	for(int i=0; i < m_drops.GetSecDropNum(npc->m_sType); i++ )
	{
		iItemID = m_drops.Roll(npc, ONNPCDELETE);

		if(iItemID != ITEM_NONE)
		{
			iItemIDs[num] = iItemID;

			// item position
			switch(iItemSpreadType)
			{
			case ITEMSPREAD_RANDOM:
				BasePos[num].x = npc->m_sX + iSpreadRange - dice(1, iSpreadRange * 2 );
				BasePos[num].y = npc->m_sY + iSpreadRange - dice(1, iSpreadRange * 2 );
				break;

			case ITEMSPREAD_FIXED:
				BasePos[num].x = npc->m_sX + ITEMSPREAD_FIXED_COORD[num%25].x;
				BasePos[num].y = npc->m_sY + ITEMSPREAD_FIXED_COORD[num%25].y;
				if(!m_pMapList[npc->m_cMapIndex]->bGetIsMoveAllowedTile(BasePos[num]))
				{
					BasePos[num].x = npc->m_sX + ITEMSPREAD_FIXED_COORD[0].x;
					BasePos[num].y = npc->m_sY + ITEMSPREAD_FIXED_COORD[0].y;
				}
				break;
			}
			num++;
		}

	}

	return num;
}

BOOL CGame::_bDecodeCraftingConfigFileContents(char *pData, DWORD dwMsgSize)
{
	char * pContents, * token;
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	char cTxt[120];
	int iCraftingConfigListIndex = 0;
	

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);
	StrTok pStrTok(new CStrTok(pContents, seps));

	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			 case 1:
				 switch (cReadModeB) {
				 case 1: //
					 if (_bGetIsStringIsNumber(token) == FALSE)
					 { PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format(1).");
					 delete[] pContents;return FALSE;
					 }
					 if (m_pCraftingConfigList[atoi(token)] != NULL)
					 { PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Duplicate crafting number.");
					 delete[] pContents;return FALSE;
					 }
					 m_pCraftingConfigList[atoi(token)] = new class CCrafting;
					 iCraftingConfigListIndex = atoi(token);
					 cReadModeB = 2;
					 break;

				 case 2:
					 ZeroMemory(m_pCraftingConfigList[iCraftingConfigListIndex]->m_cName, sizeof(m_pCraftingConfigList[iCraftingConfigListIndex]->m_cName));
					 memcpy(m_pCraftingConfigList[iCraftingConfigListIndex]->m_cName, token, strlen(token));
					 cReadModeB = 3;
					 break;

				 default: // m_sArray[0~10]
					 if (_bGetIsStringIsNumber(token) == FALSE)
					 { PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
					 delete[] pContents;return FALSE;
					 }
					 m_pCraftingConfigList[iCraftingConfigListIndex]->m_sArray[cReadModeB - 3] = atoi(token);
					 cReadModeB++;
					 break;

				 case 14: // m_sArray[11]
					 if (_bGetIsStringIsNumber(token) == FALSE)
					 { PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
					 delete[] pContents;return FALSE;
					 }
					 m_pCraftingConfigList[iCraftingConfigListIndex]->m_sArray[11] = atoi(token);
					 cReadModeB = 15;
					 break;

				 case 15: //
					 if (_bGetIsStringIsNumber(token) == FALSE)
					 { PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
					 delete[] pContents;return FALSE;
					 }
					 m_pCraftingConfigList[iCraftingConfigListIndex]->m_iSkillLimit = atoi(token);
					 cReadModeB = 16;
					 break;

				 case 16://
					 if (_bGetIsStringIsNumber(token) == FALSE)
					 { PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
					 delete[] pContents;return FALSE;
					 }
					 m_pCraftingConfigList[iCraftingConfigListIndex]->m_iDifficulty = atoi(token);
					 cReadModeA = 0;
					 cReadModeB = 0;
					 break;

				 }
				 break;

			 default:
				 break;
			}
		}
		else {
			if (memcmp(token, "crafting", 8) == 0)
			{ 
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}

	delete[] pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0))
	{ PutLogList("(ERROR) CRITICAL ERROR! CRAFTING configuration file contents error!");
	return FALSE;
	}
	//wsprintf(cTxt, "(!!) CRAFTING(Total:%d) configuration - success!", iCraftingConfigListIndex);
	//PutLogList(cTxt);

	return TRUE;
}


void CGame::ReqCreateCraftingHandler(int iClientH, char *pData)
{
	char * cp, cI[6], cCraftingName[21];
	int i, j, iEraseReq, iRiskLevel, iDifficulty, iNeededContrib = 0;
	short sTemp;
	short sItemIndex[6], sItemPurity[6], sItemNumber[6], sItemArray[12];
	BOOL bDup, bFlag, bNeedLog;
	class CItem * pItem;
	char G_cTxt[120];
	if (m_pClientList[iClientH] == NULL) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	for (i = 0; i < 6; i++)
	{ 
		cI[i] = -1;
		sItemIndex[i] = -1;
		sItemNumber[i] = 0;
		sItemPurity[i] = -1;
	}
	cp = (char *)(pData + 11);
	cp += 20;
	cI[0] = *cp;
	cp++;
	cI[1] = *cp;
	cp++;
	cI[2] = *cp;
	cp++;
	cI[3] = *cp;
	cp++;
	cI[4] = *cp;
	cp++;
	cI[5] = *cp;
	cp++;

	for (i = 0; i < 6; i++)
	{ 
		if (cI[i] >= MAXITEMS) return;
		if ((cI[i] >= 0) && (m_pClientList[iClientH]->m_pItemList[cI[i]] == NULL)) return;
	}

	for (i = 0; i < 6; i++)
		if (cI[i] >= 0)
		{ 
			bDup = FALSE;
			for (j = 0; j < 6; j++)
				if (sItemIndex[j] == cI[i])
				{ 
					sItemNumber[j]++;
					bDup = TRUE;
				}

			if (bDup == FALSE)
			{ 
				for (j = 0; j < 6; j++)
					if (sItemIndex[j] == -1)
					{ 
						sItemIndex[j] = cI[i];
						sItemNumber[j]++;
						break;
					}
			} 
		}


	for (i = 0; i < 6; i++)
		if (sItemIndex[i] != -1)
		{ 
			if (sItemIndex[i] < 0) return;
			if ((sItemIndex[i] >= 0) && (sItemIndex[i] >= MAXITEMS)) return;
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]] == NULL) return;
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount < sItemNumber[i]) return;

			sItemPurity[i] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sItemSpecEffectValue2;
			if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == ITEMTYPE_NONE)
				&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSprite == 6)
				&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSpriteFrame == 129))
			{ 
				sItemPurity[i] = 100; // Merien stones considered 100% purity.
			}
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == ITEMTYPE_CONSUME)
			{ 
				sItemPurity[i] = -1; // Diamonds / Emeralds.etc.. never have purity
			}
			if (sItemNumber[i] > 1) // No purity for stacked items
			{ 
				sItemPurity[i] = -1;
			}
			// Prevent upgrade of alreaddy merienned Necks
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwAttribute & 0xF0000000) != 0)
			{				
				SendNotifyMsg(NULL, iClientH, NOTIFY_CRAFTING_FAIL, NULL, NULL, NULL, NULL); // "There is not enough material"
				return;
			} 

			if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == ITEMTYPE_EQUIP)
				&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cEquipPos == EQUIPPOS_NECK))
			{ 
				iNeededContrib = 10; // Necks Crafting requires 10 contrib
			} 
		}

	// Bubble Sort
	bFlag = TRUE;
	while (bFlag == TRUE)
	{ 
		bFlag = FALSE;
		for (i = 0; i < 5; i++)
			if ((sItemIndex[i] != -1) && (sItemIndex[i+1] != -1))
			{ 
				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum) < (m_pClientList[iClientH]->m_pItemList[sItemIndex[i+1]]->m_sIDnum))
				{ 
					sTemp = sItemIndex[i+1];
					sItemIndex[i+1] = sItemIndex[i];
					sItemIndex[i] = sTemp;
					sTemp = sItemPurity[i+1];
					sItemPurity[i+1] = sItemPurity[i];
					sItemPurity[i] = sTemp;
					sTemp = sItemNumber[i+1];
					sItemNumber[i+1] = sItemNumber[i];
					sItemNumber[i] = sTemp;
					bFlag = TRUE;
				} 
			}

	}
	j = 0;
	for (i = 0; i < 6; i++)
	{ 
		if (sItemIndex[i] != -1)
			sItemArray[j] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum;
		else sItemArray[j] = sItemIndex[i];
		sItemArray[j+1] = sItemNumber[i];
		j += 2;
	}

	// Search Crafting you wanna build
	ZeroMemory(cCraftingName, sizeof(cCraftingName));
	for (i = 0; i < MAXCRAFTING; i++)
		if (m_pCraftingConfigList[i] != NULL)
		{	
			bFlag = FALSE;
			for (j = 0; j < 12; j++) {
				if (m_pCraftingConfigList[i]->m_sArray[j] != sItemArray[j]) bFlag = TRUE; // one item mismatch
			}
			if (bFlag == FALSE) // good Crafting receipe
			{ 
				ZeroMemory(cCraftingName, sizeof(cCraftingName));
				memcpy(cCraftingName, m_pCraftingConfigList[i]->m_cName, 20);
				iRiskLevel = m_pCraftingConfigList[i]->m_iSkillLimit; // % to loose item if crafting fails
				iDifficulty = m_pCraftingConfigList[i]->m_iDifficulty;
			} 
		}
	// Check if recipe is OK
	if (strlen(cCraftingName) == 0)
	{ 
		SendNotifyMsg(NULL, iClientH, NOTIFY_NOMATCHINGCRAFTING, 1, NULL, NULL, NULL); // "There is not enough material"
		return;
	}
	// Check for Contribution
	if (m_pClientList[iClientH]->m_iContribution < iNeededContrib)
	{ 
		SendNotifyMsg(NULL, iClientH, NOTIFY_NO_CRAFT_CONTRIB, 2, NULL, NULL, NULL); // "There is not enough Contribution Point"
		return;
	}

	// Check possible Failure
	if (dice(1,100) > iDifficulty)
	{ 
		SendNotifyMsg(NULL, iClientH, NOTIFY_CRAFTING_FAIL, NULL, NULL, NULL, NULL); // "Crafting failed"
		// Remove parts...
		pItem = NULL;
		pItem = new class CItem;
		if (pItem == NULL) return;
		for (i = 0; i < 6; i++)
			if (sItemIndex[i] != -1)
			{ // Deplete any Merien Stone
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum == ITEM_STONEOFMERIEN)
				{ 
					ItemDepleteHandler(iClientH, sItemIndex[i], FALSE, FALSE);
				}else
					// Risk to deplete any other items (not stackable ones) // ITEMTYPE_CONSUME
					if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == ITEMTYPE_EQUIP)
						|| (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == ITEMTYPE_MATERIAL))
					{ 
						if (dice(1,100) < iRiskLevel)
							ItemDepleteHandler(iClientH, sItemIndex[i], FALSE);
					} 
			}
		return;
	}

	// Purity
	int iPurity, iTot = 0, iCount = 0;
	for (i = 0; i < 6; i++)
	{ 
		if (sItemIndex[i] != -1 && sItemPurity[i] != -1)
		{ 
			iTot += sItemPurity[i];
			iCount ++;
		} 
	}
	if (iCount == 0 )
	{ 
		iPurity = 20 + dice(1,80);
		if (iPurity >=95) bNeedLog = TRUE;
		else bNeedLog = FALSE; 
	}else{	
		iPurity = iTot/iCount;
		iTot = (iPurity*4)/5;
		iCount = iPurity - iTot;
		iPurity = iTot + dice(1,iCount); // Jewel completion depends off Wares purity
		bNeedLog = TRUE;
	}
	if (iNeededContrib != 0)
	{ 
		iPurity = 0; // Necks require contribution but no purity/completion
		bNeedLog = TRUE;
	}

	if(iPurity > 200) iPurity = 200;
	if(iPurity < 0) iPurity = 20;

	if (strlen(cCraftingName) != 0)
	{ 
		pItem = NULL;
		pItem = new class CItem;
		if (pItem == NULL) return;
		for (i = 0; i < 6; i++)
		{ 
			if (sItemIndex[i] != -1) {
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == ITEMTYPE_CONSUME) {
					SetItemCount(iClientH, sItemIndex[i], m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount - sItemNumber[i]);
				}else // So if item is not Type 5 (stackable items), you deplete item
				{ 
					ItemDepleteHandler(iClientH, sItemIndex[i], FALSE, FALSE);
				} 
			} 
		}
		if (iNeededContrib !=0)
		{ 
			m_pClientList[iClientH]->m_iContribution -= iNeededContrib;
			// No known msg to send info to client, so client will compute shown Contrib himself.
		}

		SendNotifyMsg(NULL, iClientH, NOTIFY_CRAFTING_SUCCESS, NULL, NULL, NULL, NULL);

		GetExp(iClientH, dice(2, 100));

		if ((_bInitItemAttr(pItem, cCraftingName) == TRUE))
		{
			if (iPurity != 0)
			{ 
				pItem->m_sItemSpecEffectValue2 = iPurity;
				pItem->m_dwAttribute = 1;
			}
			pItem->m_sTouchEffectType = ITET_ID;
			pItem->m_sTouchEffectValue1 = dice(1,100000);
			pItem->m_sTouchEffectValue2 = dice(1,100000);
			// pItem->m_sTouchEffectValue3 = timeGetTime();
			SYSTEMTIME SysTime;
			char cTemp[256];
			GetLocalTime(&SysTime);
			ZeroMemory(cTemp, sizeof(cTemp));
			wsprintf(cTemp, "%d%2d", (short)SysTime.wMonth, (short)SysTime.wDay);
			pItem->m_sTouchEffectValue3 = atoi(cTemp);

			if (bNeedLog)
			{ 
				wsprintf(G_cTxt, "PC(%s) Crafting (%s) Purity(%d)"
				, m_pClientList[iClientH]->m_cCharName
				, pItem->m_cName
				, pItem->m_sItemSpecEffectValue2);
				PutLogList(G_cTxt);
			}
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE)
			{ 
				SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);
				
				if (iEraseReq == 1) delete pItem;
				
			//if ((pItem->m_wPrice * pItem->m_dwCount) > 1000)
			// SendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, iClientH);
			}else
			{ 
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX,	m_pClientList[iClientH]->m_sY, pItem);
				
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);

				SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
			} 
		}else
		{ 
			delete pItem;
			pItem = NULL;
		} 
	}
} 

int CGame::WriteItemData(char * buffer, CItem * pItem)
{
	DWORD * dwp;
	WORD * wp;
	char * cp;
	short * sp;

	if(buffer == NULL) return 0;
    cp = buffer;

	*cp = 1;
	cp++;

	memcpy(cp, pItem->m_cName, 20);
	cp += 20;

	dwp  = (DWORD *)cp;
	*dwp = pItem->m_dwCount;
	cp += 4;

	*cp = pItem->m_cItemType;
	cp++;

	*cp = pItem->m_cEquipPos;
	cp++;

	*cp = (char)0; 
	cp++;

	sp  = (short *)cp;
	*sp = pItem->m_sLevelLimit;
	cp += 2;

	*cp = pItem->m_cGenderLimit;
	cp++;

	wp = (WORD *)cp;
	*wp = pItem->m_wCurLifeSpan;
	cp += 2;

	wp = (WORD *)cp;
	*wp = pItem->m_wWeight;
	cp += 2;

	sp  = (short *)cp;
	*sp = pItem->m_sSprite;
	cp += 2;

	sp  = (short *)cp;
	*sp = pItem->m_sSpriteFrame;
	cp += 2;

	*cp = pItem->m_cItemColor;
	cp++;

	return 40;

}

void CGame::TileCleaner()
{
	class CItem * pItem[ITEMS_PER_TILE] = {NULL};
	short sNextItemSprite, sNextItemSpriteFrame;
	char  cNextItemColor;
	BOOL bReplaceSprite;
	DWORD dwTime = timeGetTime();

	for(int i = 0; i < MAXGROUNDITEMS; i++)
	{
		if(m_stGroundNpcItem[i].bEmpty || 
			m_stGroundNpcItem[i].dropTime > dwTime)	
			continue;

		m_stGroundNpcItem[i].bEmpty = TRUE;
		bReplaceSprite = TRUE;
		sNextItemSprite = sNextItemSpriteFrame = 0;
		cNextItemColor = 0;

		for(int j = 0; j < ITEMS_PER_TILE; j++)
		{
			pItem[j] = m_pMapList[m_stGroundNpcItem[i].cMapIndex]->pGetItem(m_stGroundNpcItem[i].sx, m_stGroundNpcItem[i].sy, &sNextItemSprite, &sNextItemSpriteFrame, &cNextItemColor);

			if(!pItem[j]) 
				continue;
			else if(pItem[j] == m_stGroundNpcItem[i].item)
			{
				delete pItem[j];
				pItem[j] = NULL;
				continue;
			}
			else if(bReplaceSprite)
				bReplaceSprite = FALSE;
		}

		for(int j=ITEMS_PER_TILE; j; j--)
		{
			if(pItem[j-1])
				m_pMapList[m_stGroundNpcItem[i].cMapIndex]->bSetItem(m_stGroundNpcItem[i].sx, m_stGroundNpcItem[i].sy, pItem[j-1]);
		}

		if(bReplaceSprite)
		{
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_SETITEM, m_stGroundNpcItem[i].cMapIndex,
				m_stGroundNpcItem[i].sx, m_stGroundNpcItem[i].sy,
				sNextItemSprite, sNextItemSpriteFrame, cNextItemColor);
		}
	}
}

void CGame::AddGroundItem(CItem * pItem, short x, short y, char mapIndex, DWORD dwTime)
{
	for(int i = 0; i < MAXGROUNDITEMS; i++)
	{
		if(m_stGroundNpcItem[i].bEmpty)
		{
			m_stGroundNpcItem[i].bEmpty = FALSE;
			m_stGroundNpcItem[i].dropTime = timeGetTime() + dwTime;
			m_stGroundNpcItem[i].item = pItem;
			m_stGroundNpcItem[i].sx = x;
			m_stGroundNpcItem[i].sy = y;
			m_stGroundNpcItem[i].cMapIndex = mapIndex;
			return;
		}
	}
	PutLogList("WARNING: Ground NPC item list is full, item will not be cleared.");
}

void CGame::HandleLegionService(char * data)
{
	WORD clientH = *(WORD *)(data+6);
	WORD cmd = *(WORD *)(data+4);
	CClient * player;

	player = m_pClientList[clientH];

	if (!player || !player->m_bIsInitComplete || 
		memcmp(player->m_cMapName, "cityhall", 8) != 0) return;

	int i=0;
	while(lgnPtsSvcs[i].price && 
		lgnPtsSvcs[i].cmd != cmd) 
	{i++;}

	switch(cmd)
	{
	case CMD_LGNSVC_TOARE:
		if(!ChangeNation(clientH, ARESDEN))
			return;
		break;
	case CMD_LGNSVC_TOELV:
		if(!ChangeNation(clientH, ELVINE))
			return;
		break;
	case CMD_LGNSVC_GOLD10:
		if(!GetLegionGold(clientH, 10000))
			return;
		break;
	case CMD_LGNSVC_GOLD100:
		if(!GetLegionGold(clientH, 100000))
			return;
		break;
	case CMD_LGNSVC_MAGEHAT:
	case CMD_LGNSVC_BMAGEHAT:
	case CMD_LGNSVC_WARRIORHELM:
	case CMD_LGNSVC_BMAGEHELM:
		if(!GetLegionItem(clientH, cmd))
			return;
		break;
	case CMD_LGNSVC_MAJ2:
	case CMD_LGNSVC_MAJ20:
		player->m_iGizonItemUpgradeLeft += 2 * lgnPtsSvcs[cmd].price;
		SendNotifyMsg(NULL, clientH, NOTIFY_GIZONITEMUPGRADELEFT, player->m_iGizonItemUpgradeLeft, 1, NULL, NULL);
		break;
	case CMD_LGNSVC_REP10:
	case CMD_LGNSVC_REP100:
		player->m_reputation += 10 * lgnPtsSvcs[cmd].price;
		break;
	default:
		return;
	}

	bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, clientH);

	SubstractCash(player->m_cAccountName, lgnPtsSvcs[i].cmd);
}

bool CGame::GetLegionGold(int clientH, long count)
{
	int iEraseReq;
	char  cItemName[21];
	class CItem * pItem;

	pItem = new class CItem;
	ZeroMemory(cItemName, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	_bInitItemAttr(pItem, cItemName);
	pItem->m_dwCount = count;


	if (_bAddClientItemList(clientH, pItem, &iEraseReq)) 
	{
		SendItemNotifyMsg(clientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);
		
		if (iEraseReq == 1) delete pItem;

		return true;
	}
	else {
		delete pItem;

		SendItemNotifyMsg(clientH,	NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, false);
		return false;
	}

	return false;
}

bool CGame::ChangeNation(int clientH, Side side)
{
	char cData[20];
	DWORD * dwp; WORD * wp; char * cp;
	CClient * player = m_pClientList[clientH];

	if(player->m_side == side) return false;

	player->m_side = side;
	ZeroMemory(player->m_cLocation, sizeof(player->m_cLocation));
	strcpy(player->m_cLocation, sideMap[side]);
	player->SetSideFlag(side);

	dwp  = (DWORD *)(cData + INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (WORD *)(cData + INDEX2_MSGTYPE);
	*wp  = NOTIFY_RESPONSE_HUNTMODE;

	cp = (char *)(cData + INDEX2_MSGTYPE + 2);
	memcpy(cp, player->m_cLocation, 10);
	cp += 10;

	switch (player->m_pXSock->iSendMsg(cData, 16)) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(clientH, TRUE, TRUE);
		return false;
	}

	SendEventToNearClient_TypeA(clientH, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTNULLACTION, NULL, NULL, NULL);

	if (player->m_iPartyID) 
		RequestDeletePartyHandler(clientH);

	return true;
}

void CGame::SubstractCash(char * account, WORD cmd)
{
	char data[20];
	WORD * wp; char * cp;

	cp = (char *)data;
	memcpy(cp, account, 10);
	cp += 10;

	wp = (WORD*)cp;
	*wp = cmd;

	bSendMsgToLS(MSGID_SUBCASH, NULL, NULL, data);
}

bool CGame::GetLegionItem(int clientH, WORD cmd)
{
	class CItem * pItem;
	int   iEraseReq;
	char  cItemName[21];
	DWORD attr = 0;

	CClient * player = m_pClientList[clientH];

	if (_iGetItemSpaceLeft(clientH) == 0) 
	{
		SendItemNotifyMsg(clientH,	NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, false);
		return false;
	}

	switch (cmd) 
	{
	case CMD_LGNSVC_MAGEHAT:
	case CMD_LGNSVC_BMAGEHAT:
		if (player->m_cSex == MALE) wsprintf(cItemName, "LegionHat(M)");
		else if (player->m_cSex == FEMALE) wsprintf(cItemName, "LegionHat(W)");
		if(cmd == CMD_LGNSVC_MAGEHAT)
			attr = 0x6100; // mp7
		else if(cmd == CMD_LGNSVC_BMAGEHAT)
			attr = 0x4100; // hp7
		break;
	case CMD_LGNSVC_WARRIORHELM:
	case CMD_LGNSVC_BMAGEHELM:
		if (player->m_cSex == MALE) wsprintf(cItemName, "LegionHelm(M)");
		else if (player->m_cSex == FEMALE) wsprintf(cItemName, "LegionHelm(W)");
		if(cmd == CMD_LGNSVC_WARRIORHELM)
			attr = 0x4100; // hp7
		else if(cmd == CMD_LGNSVC_BMAGEHELM)
			attr = 0x6100; // mp7
		break;
	default:
		return false;
	}

	pItem = NULL;
	pItem = new class CItem;
	if (pItem == NULL) return false;

	pItem->m_dwAttribute = attr;

	if ((_bInitItemAttr(pItem, cItemName) == TRUE)) 
	{
		pItem->m_sTouchEffectType = ITET_UNIQUE_OWNER;
		pItem->m_sTouchEffectValue1 = player->m_sCharIDnum1;
		pItem->m_sTouchEffectValue2 = player->m_sCharIDnum2;
		pItem->m_sTouchEffectValue3 = player->m_sCharIDnum3;
		if (_bAddClientItemList(clientH, pItem, &iEraseReq) == TRUE) 
		{
			SendItemNotifyMsg(clientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);
			if (iEraseReq == 1) delete pItem;
			return true;
		}
		else 
		{
			delete pItem;
			SendItemNotifyMsg(clientH,	NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, false);
			return false;
		}
	}
	else 
	{
		delete pItem;
		return false;
	}
	return false;
}

uint32 CGame::FindNPC(const string npcName)
{
	for (uint32 i = 0; i < MAXNPCTYPES; i++) 
	{
		if (g_npcConfigList[i] && 
			npcName == g_npcConfigList[i]->m_cNpcName) 
		{
			return g_npcConfigList[i]->m_sType;
		}
	}
	return NPC_INVALID;
}

uint32 CGame::FindItem(const string itemName)
{
	for (uint32 i = 0; i < MAXITEMTYPES; i++) 
	{
		if (m_pItemConfigList[i] && 
			itemName == m_pItemConfigList[i]->m_cName) 
		{
			return m_pItemConfigList[i]->m_sIDnum;
		}
	}
	return ITEM_INVALID;
}

void CGame::EventStart(EventType eType)
{
	switch(eType)
	{
	case ET_CAPTURE:
	case ET_DESTROY_SHIELD:
		m_astoria.reset();
		m_astoria.reset(new CAstoria(eType));
		break;
	default:
		return;
	}

	int shortCutIndex = 0;
	while(int index = m_iClientShortCut[shortCutIndex++])
	{
		SendNotifyMsg(NULL, index, NOTIFY_EVENTSTART, eType, NULL, NULL, NULL);

		if(m_pClientList[index]->m_cMapIndex == m_iAstoriaMapIndex && !m_pClientList[index]->IsGM())
		{
			SendNotifyMsg(NULL, index, NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
			RequestTeleportHandler(index, 0);
		}
	}
}

void CGame::EventEnd()
{
	Side winner = m_astoria->GetVictoriousSide();
	m_eventWinner[ m_astoria->GetEventType() ] = winner;

	char c[5];
	ZeroMemory(c, sizeof(winner));
	_itoa(winner, c, 10);

	sstream evType;
	evType << (int)m_astoria->GetEventType();
	m_eventsIni->WriteInteger(evType.str().c_str(), winner);

	int shortCutIndex = 0;
	CClient * ipClient;
	while(int index = m_iClientShortCut[shortCutIndex++])
	{
		SendNotifyMsg(NULL, index, NOTIFY_CTRWINNER, winner, NULL, NULL, NULL);
	}

	for (int i = 0; i < MAXNPCS; i++)
	{
		if (m_pNpcList[i] && m_pNpcList[i]->m_cMapIndex == m_iAstoriaMapIndex){
			switch (m_pNpcList[i]->m_sType) 
			{
			case NPC_AGT:
			case NPC_CGT:
			case NPC_DT:
				DeleteNpc(i);
				break;
			}
		}
	}

	m_astoria.reset();
}

void CGame::NotifyEventStats(const Casualties * stats) const
{
	int shortCutIndex = 0;
	CClient * ipClient;
	while(int index = m_iClientShortCut[shortCutIndex++])
	{
		if(m_pClientList[index]->m_cMapIndex == m_iAstoriaMapIndex)
			SendNotifyMsg(NULL, index, NOTIFY_CASUALTIES, 
			stats[ARESDEN].deaths, stats[ELVINE].deaths, stats[ISTRIA].deaths, NULL, 
			stats[ARESDEN].kills, stats[ELVINE].kills, stats[ISTRIA].kills);
	}
}

void CGame::NotifyRelicInAltar(const Side altarSide) const
{
	int shortCutIndex = 0;
	CClient * ipClient;
	while(int index = m_iClientShortCut[shortCutIndex++])
	{
		if(m_pClientList[index]->m_cMapIndex == m_iAstoriaMapIndex)
			SendNotifyMsg(NULL, index, NOTIFY_RELICINALTAR, altarSide, NULL, NULL, NULL);
	}
}

void CGame::NotifyRelicGrabbed(const CClient * picker) const
{
	int shortCutIndex = 0;
	CClient * ipClient;
	while(int index = m_iClientShortCut[shortCutIndex++])
	{
		if(m_pClientList[index]->m_cMapIndex == m_iAstoriaMapIndex)
			SendNotifyMsg(NULL, index, NOTIFY_RELICGRABBED, NULL, NULL, NULL, picker->m_cCharName);
	}
}

void CGame::ShuffleAstoriaBasePos()
{
	Side sides[MAXALTARS] = {ARESDEN, ELVINE/*, ISTRIA*/};

	for(int i=0; i < MAXALTARS; i++)
	{
		int pos = rand()%(MAXALTARS-i);
		m_astoriaBasePos[i] = sides[pos];
		if(pos != MAXALTARS-i)
			sides[pos] = sides[MAXALTARS-i-1];
	}
}

void CGame::CreateAstoriaFlags()
{
	uint32 dynObj;

	for(int i=0; i < MAXALTARS; i++)
	{
		switch(m_astoriaBasePos[i])
		{
		case ARESDEN:
			dynObj = DYNAMICOBJECT_ARESDENFLAG;
			break;
		case ELVINE:
			dynObj = DYNAMICOBJECT_ELVINEFLAG;
			break;
		}

		int j=0;
		while(astoriaFlagsPos[i][j].x != -1)
		{
			iAddDynamicObjectList(NULL, NULL, dynObj, m_iAstoriaMapIndex, 
				astoriaFlagsPos[i][j].x, astoriaFlagsPos[i][j].y, NULL);
			j++;
		}
	}
}

void CGame::UpdateWebsiteStats()
{
	if(strlen(m_websiteScriptAddr) != 0 && strlen(m_websiteAddr) != 0 && m_websitePort != 0){
		m_webSocket = new XSocket(m_hWnd, SERVERSOCKETBLOCKLIMIT);
		m_webSocket->bConnect(m_websiteAddr, m_websitePort, WM_ONWEBSOCKETEVENT, true);
		m_webSocket->bInitBufferSize(MSGBUFFERSIZE);
	}
}

void CGame::OnWebSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
	int iRet;
	char data[50], datalen[5], postInfo[400];
		
	if (m_webSocket == NULL) return;

	iRet = m_webSocket->iOnSocketEvent(wParam, lParam);

	if (iRet == XSOCKEVENT_CONNECTIONESTABLISH){
		ZeroMemory(postInfo, sizeof(postInfo));

		wsprintf(data, "code=L58sk2hK29dks&online=%d", m_iTotalGameServerClients + m_onlineCntAdd);
		wsprintf(datalen, "%d", strlen(data));

		wsprintf(postInfo, "POST %s HTTP/1.1\r\nHost: %s\r\n", m_websiteScriptAddr, m_websiteAddr); 
		strcat(postInfo, "Connection: close\r\n");
		strcat(postInfo, "Content-type: application/x-www-form-urlencoded\r\n");
		strcat(postInfo, "Content-length: ");
		strcat(postInfo, datalen);
		strcat(postInfo, "\r\n\r\n");
		strcat(postInfo, data);

		m_webSocket->sendRawMsg(postInfo, strlen(postInfo));
	}

	delete m_webSocket;
	m_webSocket = NULL;
}

void CGame::UpdateRelicPos(int iClientH)
{
	int shortCutIndex = 0;
	Point relicPos;
	CClient * ipClient;

	if (m_astoria.get()) {
		if((ipClient = m_astoria->GetRelicHolder()) != NULL){
			relicPos.x = ipClient->m_sX;
			relicPos.y = ipClient->m_sY;
		} 
		else {
			relicPos = m_astoria->GetRelicPos();
		}

		if(iClientH){
			SendNotifyMsg(NULL, iClientH, NOTIFY_RELICPOSITION, relicPos.x, relicPos.y, NULL, NULL);
		}else {
			while(int index = m_iClientShortCut[shortCutIndex++])
			{
				if(m_pClientList[index]->m_cMapIndex == m_iAstoriaMapIndex)
					SendNotifyMsg(NULL, index, NOTIFY_RELICPOSITION, relicPos.x, relicPos.y, NULL, NULL);
			}
		}
	}
}

void CGame::RequestSetRecallPoint(int iClientH, char * pData, DWORD dwMsgSize)
{
	int recallPoint;

	if (dwMsgSize <= 0) return;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	recallPoint = *((char *)(pData + INDEX2_MSGTYPE + 2));

	if (recallPoint < 1 && recallPoint > 5) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pInitialPoint[recallPoint].x == -1 || 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pInitialPoint[recallPoint].y == -1) return;

	m_pClientList[iClientH]->m_nextRecallPoint = recallPoint;
}

bool CGame::WriteTileData(char * buffer, int & sizeWritten, int iClientH, CTile * srcTile, int ix, int iy)
{
	unsigned char ucHeader;
	WORD  * wp;
	short * sp;
	char * cp = buffer;
	int *ip;
	bool dataWritten = false;

	CTile * pTile = (class CTile *)(srcTile + ix + iy*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

	if ( (pTile->m_sOwner != NULL) || (pTile->m_sDeadOwner != NULL) || 
		(pTile->m_pItem[0] != NULL) || (pTile->m_sDynamicObjectType != NULL) ) {
			dataWritten = true;
			sp = (short *)cp;
			*sp = (short)ix;
			cp += 2;
			sp = (short *)cp;
			*sp = (short)iy;
			cp += 2;
			sizeWritten += 4;

			ucHeader = 0;
			if (pTile->m_sOwner != NULL) {

				if (pTile->m_cOwnerClass == OWNERTYPE_PLAYER) {
					if (m_pClientList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
					else {
						// ###debugcode
						wsprintf(g_cTxt, "Empty player handle: %d", pTile->m_sOwner);
						//PutLogFileList(g_cTxt);
						//
						pTile->m_sOwner = NULL;
					}
				}

				if (pTile->m_cOwnerClass == OWNERTYPE_NPC) {
					if (m_pNpcList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = NULL;
				}
			}
			if (pTile->m_sDeadOwner != NULL) {
				if (pTile->m_cDeadOwnerClass == OWNERTYPE_PLAYER) {
					if (m_pClientList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = NULL;
				}
				if (pTile->m_cDeadOwnerClass == OWNERTYPE_NPC) {
					if (m_pNpcList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = NULL;
				}
			}
			if (pTile->m_pItem[0] != NULL)				ucHeader = ucHeader | 0x04;
			if (pTile->m_sDynamicObjectType != NULL)    ucHeader = ucHeader | 0x08;
			//
			*cp = ucHeader;
			cp++;
			sizeWritten++;

			if ((ucHeader & 0x01) != 0) {

				switch (pTile->m_cOwnerClass) {
					case OWNERTYPE_PLAYER:
						// Object ID number(Player) : 1~10000
						sp  = (short *)cp;
						*sp	= pTile->m_sOwner;
						cp += 2;
						sizeWritten += 2;
						// object type
						sp  = (short *)cp;
						*sp	= m_pClientList[pTile->m_sOwner]->m_sType;
						cp += 2;
						sizeWritten += 2;
						// dir
						*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
						cp++;
						sizeWritten++;
						// Appearance1
						sp  = (short *)cp;
						*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr1;
						cp += 2;
						sizeWritten += 2;
						// Appearance2
						sp  = (short *)cp;
						*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr2;
						cp += 2;
						sizeWritten += 2;
						// Appearance3
						sp  = (short *)cp;
						*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr3;
						cp += 2;
						sizeWritten += 2;
						// Appearance4
						sp  = (short *)cp;
						*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr4;
						cp += 2;
						sizeWritten += 2;

						ip = (int *)cp;
						*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor;
						cp += 4;
						sizeWritten += 4;

						// Status
						ip  = (int *)cp;

						if(_bGetIsPlayerHostile(iClientH,pTile->m_sOwner) && pTile->m_sOwner != iClientH && m_pClientList[iClientH]->m_iAdminUserLevel == 0)
							*ip = STATUS_ENEMYFLAGS & m_pClientList[pTile->m_sOwner]->m_iStatus;
						else 
							*ip = m_pClientList[pTile->m_sOwner]->m_iStatus;

						cp += 4;
						sizeWritten += 4;
						// Name
						memcpy(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, 10);
						cp    += 10;
						sizeWritten += 10;
						break;

					case OWNERTYPE_NPC:
						// Object ID number(NPC) : 10000	~
						sp  = (short *)cp;
						*sp	= pTile->m_sOwner + 10000;
						cp += 2;
						sizeWritten += 2;
						// object type
						sp  = (short *)cp;
						*sp	= m_pNpcList[pTile->m_sOwner]->m_sType;
						cp += 2;
						sizeWritten += 2;
						// dir
						*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
						cp++;
						sizeWritten++;
						// Appearance2
						sp  = (short *)cp;
						*sp	= m_pNpcList[pTile->m_sOwner]->m_sAppr2;
						cp += 2;
						sizeWritten += 2;
						// Status
						ip  = (int *)cp;

						*ip = m_pNpcList[pTile->m_sOwner]->m_iStatus;
						cp += 4;
						sizeWritten += 4;
						// Name
						memcpy(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);
						cp    += 5;
						sizeWritten += 5;
						break;
				}
			}

			if ((ucHeader & 0x02) != 0) {

				switch (pTile->m_cDeadOwnerClass) 
				{
				case OWNERTYPE_PLAYER:
					// Object ID number(Player) : 1~10000
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner;
					cp += 2;
					sizeWritten += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					sizeWritten += 2;
					// dir
					*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					sizeWritten++;
					// Appearance1
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr1;
					cp += 2;
					sizeWritten += 2;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					sizeWritten += 2;
					// Appearance3
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr3;
					cp += 2;
					sizeWritten += 2;
					// Appearance4
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr4;
					cp += 2;
					sizeWritten += 2;

					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor;
					cp += 4;
					sizeWritten += 4;

					// Status
					ip  = (int *)cp;
					*ip = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
					cp += 4;
					sizeWritten += 4;

					// Name
					memcpy(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, 10);
					cp    += 10;
					sizeWritten += 10;
					break;

				case OWNERTYPE_NPC:
					// Object ID number : 10000	~
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner + 10000;
					cp += 2;
					sizeWritten += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					sizeWritten += 2;
					// dir
					*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					sizeWritten++;
					// Appr2
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					sizeWritten += 2;
					// Status
					ip  = (int *)cp;

					*ip = m_pNpcList[pTile->m_sDeadOwner]->m_iStatus;
					cp += 4;
					sizeWritten += 4;
					// Name
					memcpy(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
					cp    += 5;
					sizeWritten += 5;
					break;
				}
			}

			if (pTile->m_pItem[0] != NULL) {

				sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSprite;
				cp += 2;
				sizeWritten += 2;
				sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSpriteFrame;
				cp += 2;
				sizeWritten += 2;
				*cp = pTile->m_pItem[0]->m_cItemColor;
				cp++;
				sizeWritten++;
			}

			if (pTile->m_sDynamicObjectType != NULL) {
				wp  = (WORD *)cp;
				*wp = pTile->m_wDynamicObjectID;
				cp += 2;
				sizeWritten += 2;

				sp  = (short *)cp;
				*sp	= pTile->m_sDynamicObjectType;
				cp += 2;
				sizeWritten += 2;
			}
	}

	return dataWritten;
}


void CGame::LocalStartApocalypse()
{ 
	int i;
	char cTxt[120];
	if (m_bIsApocalypseMode) return;
	DWORD dwTime = timeGetTime();
	m_bIsApocalypseMode = TRUE;
	m_bIsApocalypseGateOpen	= TRUE;
	for (i = 1; i < MAXCLIENTS; i++) 
	{	if (m_pClientList[i] != NULL) 
		{	SendNotifyMsg(NULL, i, NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL);	
	}	}
	for (i = 0; i < MAXMAPS; i++)
	{	if (m_pMapList[i] != NULL) 
		{	if (m_pMapList[i]->m_iApocalypseMobGenType != 0) 
			//1 for no respawn, 2 for Boss spawn when map empty
			{	m_pMapList[i]->m_iMaximumObject = 0;	
	}	}	}
	for (int i = 1; i < MAXCLIENTS; i++) 
	{	if (m_pClientList[i] != NULL)
		{	Notify_ApocalypseGateState(i);
			
		}	
	}
	wsprintf(cTxt,"(_)Apocalypse Mode ON.");
	PutLogList(cTxt);				
}


void CGame::Notify_ApocalypseGateState(int iClientH)
{	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (!m_bIsApocalypseMode) return;
	int iMapIndex = m_pClientList[iClientH]->m_cMapIndex;
	
	int gX = (m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 + m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2)/2;
	int gY = (m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 + m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2)/2;
			
	switch (m_pMapList[iMapIndex]->m_cDynamicGateType){
	case 0:	// No gate on current map		
		if(m_bIsApocalypseGateOpen == TRUE) 
		{	SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATEOPEN, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
			SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL);
		}else
		{	SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATECLOSE, 0, 0, NULL, m_pClientList[iClientH]->m_cMapName);
			SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATEENDMSG, NULL, NULL, NULL, NULL);
		}
		break;
	case 1:	// Initial Dynamic gates (toh, IB, D4...)
		if(m_bIsApocalypseGateOpen == TRUE) 
		{	SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATEOPEN, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
			SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL);
		}else
		{	SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATECLOSE, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
			SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATEENDMSG, NULL, NULL, NULL, NULL);
		}
		break;
	case 2: // Empty maps Dynamic gates (inferniaA, inferniaB, procella...)
		if (m_pMapList[iMapIndex]->m_iTotalActiveObject == 0)
		{	SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATEOPEN, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
			SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL);
		}else
		{	SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATECLOSE, gX, gY , NULL, m_pClientList[iClientH]->m_cMapName);
		}
		break;
	case 3: 
		SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATECLOSE, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
		break;	
	case 4: // Show the gate on abaddon map..when Abaddon spawning.
		SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATEOPEN, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
		SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL);
		break;
	case 5:	// GM command Dynamic gates (even not in apocalypse mode)
		gX = m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 + 1;
		gY = m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 + 1;
		SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATEOPEN, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
		break;
	}
}


void CGame::Use_ApocalypseGate(int iClientH)
{	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (!m_bIsApocalypseMode) return;
	int iMapIndex = m_pClientList[iClientH]->m_cMapIndex;
	switch(m_pMapList[iMapIndex]->m_cDynamicGateType) {
	case 0: // No Dynamic Gate on this map
		return; break;
	case 1: // Apocalypse normal gate
		if (m_bIsApocalypseGateOpen == FALSE)	return; 
		break;
	case 2: // Apocalypse gate opened when map empty
		if (m_pMapList[iMapIndex]->m_iTotalActiveObject != 0) return; 
		break;
	case 3: // Apocalypse gate still closed
		break;
	case 4: // Apocalypse gate opened when Abaddon spawned.
		break;
	case 5: // Admin created gate
		break;
	}
	if (   (m_pClientList[iClientH]->m_sX >= m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1)
		&& (m_pClientList[iClientH]->m_sX <= m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2)
		&& (m_pClientList[iClientH]->m_sY >= m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1)
		&& (m_pClientList[iClientH]->m_sY <= m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2))
	{	RequestTeleportHandler(iClientH, 2, m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap
								, m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtX
								, m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtY);	

	}
}

void CGame::GlobalStartApocalypseMode(int iClientH)
{	char * cp, cData[120], cString[200], cTxt[120];
	ZeroMemory(cString, sizeof(cString));
	if ((iClientH != 0) && (m_pClientList[iClientH]->m_iAdminUserLevel < 3)) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	if (m_bIsApocalypseMode) return;
	if (m_bIsCrusadeMode) return;	

	if (iClientH !=0)
		{	wsprintf(cTxt, "Admin Order(%s): /beginapocalypse \tAdminIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_cIPaddress);
			wsprintf(cString, "Apocalypse starting in progress.");
		}else
		{	wsprintf(cTxt, "Local command: beginapocalypse");
		}	
		_bCrusadeLog(CRUSADELOG_APOCALYPSE, NULL, 0, "Begin Apocalypse.");	
		PutLogList(cTxt);	
	if (iClientH !=0)
	{	SendNotifyMsg(NULL, iClientH, NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cString);
	}
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_BEGINAPOCALYPSE;
	cp++;
	bStockMsgToGateServer(cData, 5);
	LocalStartApocalypse();
}





void CGame::GlobalEndApocalypseMode(int iClientH)
{	char * cp, cData[120], cString[200], cTxt[120];
	if (!m_bIsApocalypseMode) return;
	if (iClientH > 0)	
	{	wsprintf(cTxt, "Admin Order(%s): /endapocalypse \tAdminIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		ZeroMemory(cString, sizeof(cString));
		wsprintf(cString, "Apocalypse ending in progress.");
		SendNotifyMsg(NULL, iClientH, NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cString);
	}else
	{	wsprintf(cTxt, "Automated: endapocalypse");
	}
	_bCrusadeLog(CRUSADELOG_APOCALYPSE, NULL, 0, "End Apocalypse.");	
	PutLogList(cTxt);	
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_ENDAPOCALYPSE;
	cp++;	
	bStockMsgToGateServer(cData, 5);
	LocalEndApocalypse();
}

void CGame::LocalEndApocalypse()
{	char cTxt[120];
	if (!m_bIsApocalypseMode) return;
	m_bIsApocalypseMode = FALSE;
	m_bIsApocalypseGateOpen	= FALSE; 


	for (int i = 1; i < MAXCLIENTS; i++) 
	{	if (m_pClientList[i] != NULL)
		{	SendNotifyMsg(NULL, i, NOTIFY_APOCGATEENDMSG, NULL, NULL, NULL, NULL);
			if ((m_pClientList[i]->m_iAdminUserLevel == 0) && (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsApocalypseMap == TRUE)) 
			{	SendNotifyMsg(NULL, i, NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
				RequestTeleportHandler(i, 0);
	}	}	}	
	// restore normal spawn on apoc maps
	for (int i = 0; i < MAXMAPS; i++)
	{	if (m_pMapList[i] != NULL) 
		{	if (m_pMapList[i]->m_iApocalypseMobGenType != 0) 
			//1 for not respawn, 2 for Boss spawn.
			{	m_pMapList[i]->m_iMaximumObject = m_pMapList[i]->m_iMaximumObject;
			}
			if (m_pMapList[i]->m_cDynamicGateType == 4 )
			{	m_pMapList[i]->m_cDynamicGateType = 3;
			}
			if (m_pMapList[i]->m_cDynamicGateType == 2)
			{	GenerateSlime(i);	// to force the gate to close		
			}
				for (int i = 1; i < MAXCLIENTS; i++) 
				{	if (m_pClientList[i] == NULL) return;
					Notify_ApocalypseGateState(i);		
				} 
	}	}
	wsprintf(cTxt,"(_) Apocalypse Mode OFF.");
	PutLogList(cTxt);
}
void CGame::GenerateApocalypseBoss(int MapIndex)
{	if (m_pMapList[MapIndex]->m_iTotalActiveObject != 0) return;
	if (!m_bIsApocalypseMode) return;
	char cName[21], cNpcName[21], cNpcWaypoint[11], cTxt[120];
	int x, i5;
	int iNamingValue;
	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

	iNamingValue = m_pMapList[MapIndex]->iGetEmptyNamingValue();
	if (iNamingValue == -1) 
	{}else 
	{	ZeroMemory(cNpcName, sizeof(cNpcName));
		switch (m_pMapList[MapIndex]->m_iApocalypseBossMobNpcID) {
		case 0: return; break;
		case 49: strcpy(cNpcName, "Hellclaw");break;
		case 50: strcpy(cNpcName, "Tigerworm");break;	
		case 66: strcpy(cNpcName, "Wyvern");break;	
		case 73: strcpy(cNpcName, "Fire-Wyvern");break;	
		case 81: strcpy(cNpcName, "Abaddon");break;	
		default: strcpy(cNpcName, "Demon");break;	
		}
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = MapIndex+65;	
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[MapIndex]->m_cName, 0
			, MOVETYPE_RANDOMAREA, NULL, NULL, cNpcWaypoint, &m_pMapList[MapIndex]->m_sApocalypseBossMobRect, NULL, -1, FALSE, FALSE, FALSE, TRUE) == FALSE) 
		{	m_pMapList[MapIndex]->SetNamingValueEmpty(iNamingValue);
		}else 
		{	wsprintf(cTxt, "%s has spawned in %s"
				, cNpcName
				, m_pMapList[MapIndex]->m_cName);
			PutLogList(cTxt);	
			PutLogList(cTxt);	
						
			_bCrusadeLog(CRUSADELOG_APOCALYPSE, NULL, 0, cTxt);	
		}
		for (i5 = 1; i5 < MAXNPCS; i5++)
		{	if ((m_pNpcList[i5] != NULL) && (memcmp(m_pNpcList[i5]->m_cName, cName, 5) == 0) ) 
			{	break;
		}	}
		// Show Spawns on minimap, and tell everybody on Apocalypse server.					
		DWORD wX = m_pNpcList[i5]->m_sX;
		DWORD wY = m_pNpcList[i5]->m_sX;
		for (x = 1; x < MAXCLIENTS; x++)
		if (   (m_pClientList[x] != NULL) 
			&& (m_pClientList[x]->m_bIsInitComplete == TRUE))
		{	if(memcmp(m_pMapList[MapIndex]->m_cName, m_pMapList[m_pClientList[x]->m_cMapIndex]->m_cName, strlen(m_pMapList[MapIndex]->m_cName)) == 0)
			{	SendNotifyMsg(NULL, x, NOTIFY_MONSTEREVENT_POSITION, wX, wY, m_pMapList[MapIndex]->m_iApocalypseBossMobNpcID, NULL);
			}
			// Tell everybody on this server if Abaddon has appeared
			if (m_pMapList[MapIndex]->m_iApocalypseBossMobNpcID == 81) 
			{	char cInfoString[100];
				ZeroMemory(cInfoString,  sizeof(cInfoString));
				wsprintf(cInfoString, "Abbadon has appeared ...");
				SendNotifyMsg(NULL, x, NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
		}	}
		if (m_pMapList[MapIndex]->m_iApocalypseBossMobNpcID == 81)
		{	// Abaddon should die by himself		
			DWORD dwTime = timeGetTime();
			dwTime += 1000*60*5; // 5 minute
			RegisterDelayEvent(DELAYEVENTTYPE_KILL_ABADDON, 0, dwTime, i5
						, OWNERTYPE_NPC, MapIndex, 0, 0, 0, 0, 0);
			dwTime = timeGetTime();
			dwTime += 1000*60*15; // 15 minutes
			RegisterDelayEvent(DELAYEVENTTYPE_END_APOCALYPSE, 0, dwTime, 0
						, 0, MapIndex, 0, 0, 0, 0, 0);
		}
		// Finally open the Exit Gate if type 3 & not 2
		// NB: if m_iApocalypseMobGenType 2 with GateType 2, need to Kill the boss to open the gate.
		if (m_pMapList[MapIndex]->m_cDynamicGateType == 3 )
		{	m_pMapList[MapIndex]->m_cDynamicGateType = 4;
				for (int i = 1; i < MAXCLIENTS; i++) 
				{	if (m_pClientList[i] == NULL) return;
					Notify_ApocalypseGateState(i);		
				} 
	}	}
}

void CGame::GenerateSlime(int MapIndex)
{	if (m_pMapList[MapIndex]->m_iTotalActiveObject != 0) return;
	if (!m_bIsApocalypseMode) return;
	char cName[21], cNpcName[21], cNpcWaypoint[11];	
	int iNamingValue;
	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

	iNamingValue = m_pMapList[MapIndex]->iGetEmptyNamingValue();
	if (iNamingValue == -1) 
	{}else 
	{	strcpy(cNpcName, "Slime");
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = MapIndex+65;							
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[MapIndex]->m_cName, 0
			, MOVETYPE_RANDOMAREA, NULL, NULL, cNpcWaypoint, &m_pMapList[MapIndex]->m_sApocalypseBossMobRect, NULL, NULL, FALSE, FALSE, FALSE, TRUE) == FALSE) 
		{	m_pMapList[MapIndex]->SetNamingValueEmpty(iNamingValue);
	}	}
}

void CGame::SendThunder(int iClient, short sX, short sY, short sV3, short sV4)
{	char  * cp, cData[100];
	DWORD * dwp;
	WORD * wp;
	short * sp;
	int iRet;
	ZeroMemory(cData, sizeof(cData));	
	dwp  = (DWORD *)(cData + INDEX4_MSGID);
	*dwp = MSGID_EVENT_COMMON;
	wp   = (WORD *)(cData + INDEX2_MSGTYPE);
	*wp  = COMMONTYPE_MAGIC;	
	cp = (char *)(cData + INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	*sp = sX;
	cp += 2;
	sp  = (short *)cp;
	*sp = sY;
	cp += 2;
	sp  = (short *)cp;
	*sp = sX;
	cp += 2;
	sp  = (short *)cp;
	*sp = sY;
	cp += 2;
	sp  = (short *)cp;
	*sp = sV3;
	cp += 2;
	sp  = (short *)cp;
	*sp = sV4;
	cp += 2;
	iRet = m_pClientList[iClient]->m_pXSock->iSendMsg(cData, 18);
}
void CGame::DoAbaddonThunderDamageHandler(char cMapIndex)
{	int iResult;
	int i;
	if (!m_bIsApocalypseMode) return;
	if (dice(1, 15) != 13) return;
	DWORD dwTime = timeGetTime();
	for (i = 0; i < MAXCLIENTS; i++) 
	{	if (m_pClientList[i] != NULL) 
		{	//if (m_pClientList[i]->m_iAdminUserLevel > 0) return;
			if ((memcmp(m_pClientList[i]->m_cMapName, "abaddon", 7) == 0) 
				|| (m_pClientList[i]->m_cMapIndex == cMapIndex))
			{	switch (dice(1,4)) {
				case 1:
					SendThunder(i, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 203, m_pClientList[i]->m_sType);
					SendThunder(i, m_pClientList[i]->m_sX-dice(1,7), m_pClientList[i]->m_sY+dice(1,5), 161, m_pClientList[i]->m_sType);
					break;
				case 2:
					SendThunder(i, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 202, m_pClientList[i]->m_sType);
					SendThunder(i, m_pClientList[i]->m_sX+dice(1,7), m_pClientList[i]->m_sY-dice(1,5), 161, m_pClientList[i]->m_sType);
					break;
				case 3:
					SendThunder(i, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 201, m_pClientList[i]->m_sType);
					SendThunder(i, m_pClientList[i]->m_sX+dice(1,7), m_pClientList[i]->m_sY+5-dice(1,9), 161, m_pClientList[i]->m_sType);
					break;
				case 4:
					SendThunder(i, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 200, m_pClientList[i]->m_sType);
					SendThunder(i, m_pClientList[i]->m_sX+5-dice(1,9), m_pClientList[i]->m_sY+7-dice(1,4), 161, m_pClientList[i]->m_sType);
					break;
				}				
				if (m_pClientList[i]->m_iAdminUserLevel > 0) return;	
				iResult = dice(1,20) + 100;
				 if (  (m_pClientList[i]->m_cMagicEffectStatus[MAGICTYPE_PROTECT] == 2)
					|| (m_pClientList[i]->m_cMagicEffectStatus[MAGICTYPE_PROTECT] == 5)) 
				{   iResult /= 2;
				}
				// Not for v3.51: SendNotifyMsg(NULL, i, NOTIFY_0BE5, NULL, NULL, NULL, NULL);
				m_pClientList[i]->m_iHP -= iResult;
				if (m_pClientList[i]->m_iHP <= 0) 
				{	m_pClientList[i]->KilledHandler(i, NULL, iResult);
				}else if (iResult > 0) 
				{	SendNotifyMsg(NULL, i, NOTIFY_HP, NULL, NULL, NULL, NULL);
					SendEventToNearClient_TypeA(i, OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, OBJECTDAMAGE, iResult, NULL, NULL);
					if (m_pClientList[i]->m_bSkillUsingStatus[19] != TRUE) 
					{	m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(i, OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
						m_pMapList[m_pClientList[i]->m_cMapIndex]->SetOwner(i, OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					}
					if (m_pClientList[i]->m_cMagicEffectStatus[MAGICTYPE_HOLDOBJECT] == 20)			// Medusa kiss
					{   SendNotifyMsg(NULL, i, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_HOLDOBJECT, 20, NULL, NULL);
						RemoveFromDelayEventList(i, OWNERTYPE_PLAYER, MAGICTYPE_HOLDOBJECT);						
						m_pClientList[i]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
					}else if (m_pClientList[i]->m_cMagicEffectStatus[MAGICTYPE_HOLDOBJECT] == 1)	// Hold person
					{   SendNotifyMsg(NULL, i, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_HOLDOBJECT, 1, NULL, NULL);
						RemoveFromDelayEventList(i, OWNERTYPE_PLAYER, MAGICTYPE_HOLDOBJECT);						
						m_pClientList[i]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
					}else if (m_pClientList[i]->m_cMagicEffectStatus[MAGICTYPE_HOLDOBJECT] != 0)	// Para entangle
					{   SendNotifyMsg(NULL, i, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_HOLDOBJECT, 2, NULL, NULL);
						RemoveFromDelayEventList(i, OWNERTYPE_PLAYER, MAGICTYPE_HOLDOBJECT);						
						m_pClientList[i]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
	}	}	}	}	}
}






void CGame::_CreateHeldenianGUID(DWORD m_dwHeldenianGUID, int m_iHeldenianType1Winner, int m_iHeldenianType2Winner, int m_iHeldenianType) const
{	
	char * cp, cTxt[120], cFn[256], cTemp[1024];
	FILE * pFile;

	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));

	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"HeldenianGUID.Txt");

	pFile = fopen(cFn, "wt");
	if (pFile == NULL) 
	{
		wsprintf(cTxt, "(ERROR) Cannot create Heldenian-GUID(%d) file", m_dwHeldenianGUID);
		PutLogList(cTxt);
	} else {
		ZeroMemory(cTemp, sizeof(cTemp));
		ZeroMemory(cTxt, sizeof(cTxt));
		/*wsprintf(cTxt, "Heldenian-GUID = %d\n", m_dwHeldenianGUID);
		strcat(cTemp, cTxt);
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "Heldenian-Type1-Winner = %d\n", m_iHeldenianType1Winner);
		strcat(cTemp, cTxt);
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "Heldenian-Type2-Winner = %d\n", m_iHeldenianType2Winner);
		strcat(cTemp, cTxt);
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "Heldenian-LastType = %d\n", m_iHeldenianType);
		strcat(cTemp, cTxt);*/
		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);
		//wsprintf(cTxt, "(O) HeldenianGUID(%d) file created", m_dwHeldenianGUID);
		//PutLogList(cTxt);
	}
	if (pFile != NULL) fclose(pFile);

	/*switch (m_iHeldenianType1Winner) 
	{
	case 1:	PutLogList("(!!) Aresden Owned Heldenian Type 1.");
		break;
	case 2: PutLogList("(!!) Elvine Owned Heldenian Type 1.");
		break;		
	default: PutLogList("(!!) Nobody Owned Heldenian Type 1.");
		break;
	} 

	switch (m_iHeldenianType2Winner) 
	{
	case 1:	PutLogList("(!!) Aresden Owned Heldenian Type 2.");
		break;
	case 2: PutLogList("(!!) Elvine Owned Heldenian Type 2.");
		break;		
	default: PutLogList("(!!) Nobody Owned Heldenian Type 2.");
		break;
	} 

	switch (m_iHeldenianType) 
	{
	case 1:	PutLogList("(!!) Heldenian Type 1.");
		break;
	case 2: PutLogList("(!!) Heldenian Type 2.");
		break;	
	} */
}

bool CGame::bReadHeldenianGUIDFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, * token, cReadMode, cTxt[120];
	char seps[] = "= \t\n";
	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) 
	{
		PutLogList("(ERROR) Cannot open Heldenian-GUID file.");
		return FALSE;
	} else {
		//PutLogList("(*) Reading Heldenian-GUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		StrTok pStrTok(new CStrTok(cp, seps));
		token = pStrTok->pGet();
		while( token != NULL )   
		{
			if (cReadMode != 0) 
			{
				switch (cReadMode) 
				{
				case 1:
					m_dwHeldenianGUID = atoi(token);
					//wsprintf(cTxt, "Heldenian-GUID = %d", m_dwHeldenianGUID);
					//PutLogList(cTxt);
					cReadMode = 0;
					break;
				case 2:
					m_iHeldenianType1Winner = atoi(token);
					//wsprintf(cTxt, "Heldenian-Type1-Winner = %d", m_iHeldenianType1Winner);
					//PutLogList(cTxt);
					cReadMode = 0;
					break;
				case 3:
					m_iHeldenianType2Winner = atoi(token);
					//wsprintf(cTxt, "Heldenian-Type2-Winner = %d", m_iHeldenianType2Winner);
					//PutLogList(cTxt);
					cReadMode = 0;
					break;
				case 4:
					m_iLastHeldenianType = atoi(token);
					//wsprintf(cTxt, "Heldenian-LastType = %d", m_iLastHeldenianType);
					//PutLogList(cTxt);
					cReadMode = 0;
					break;
				}
			} else {
				if (memcmp(token, "Heldenian-GUID", 14) == 0) cReadMode = 1;
				if (memcmp(token, "Heldenian-Type1-Winner", 22) == 0) cReadMode = 2;
				if (memcmp(token, "Heldenian-Type2-Winner", 22) == 0) cReadMode = 3;
				if (memcmp(token, "Heldenian-LastType", 16) == 0) cReadMode = 4;
			}
			token = pStrTok->pGet();
		}
		delete[] cp;
	}
	if (pFile != NULL) fclose(pFile);
	/*switch (m_iHeldenianType1Winner) 
	{
	case 1:	PutLogList("(!!) Aresden Owned Heldenian In Last Type (1).");
		break;
	case 2: PutLogList("(!!) Elvine Owned Heldenian In Last Type (1).");
		break;		
	default: PutLogList("(!!) Nobody Owned Heldenian In Last Type (1).");
		break;
	} 
	switch (m_iHeldenianType2Winner) 
	{
	case 1:	PutLogList("(!!) Aresden Owned Heldenian In Last Type (2).");
		break;
	case 2: PutLogList("(!!) Elvine Owned Heldenian In Last Type (2).");
		break;		
	default:PutLogList("(!!) Nobody Owned Heldenian In Last Type (2).");
		break;
	} 
	switch (m_iLastHeldenianType) 
	{
	case 1:	PutLogList("(!!) Last Heldenian Type (1).");
		break;
	case 2: PutLogList("(!!) Last Heldenian Type (2).");
		break;	
	default: PutLogList("(!!) Last Heldenian Type (No Last Type).");
		break;
	}*/
	return TRUE;
}
void CGame::StartHeldenianMode(int iClientH)
{
	char cData[120], * cp, cBuff[256], * token, seps[] = "= \t\n", cTxt[120], cString[120];
	DWORD *dwp;
	WORD * wp;
	class CStrTok * pStrTok;
	int i, x, n, iNamingValue;
	char cName[11], cTmp[21], cNpcWaypointIndex[10], cSide, cOwnerType;
	short sOwnerH;
	BOOL bRet;
	int dX, dY;
	int tempwin;

	if (m_bHeldenianMode) return;
	if (m_bIsApocalypseMode) return;
	if (m_bIsCrusadeMode) return;
	bReadHeldenianGUIDFile("GameData\\HeldenianGUID.txt");	
	m_iHeldenianType = (m_iLastHeldenianType % 2) +1;

	if (iClientH != -1) 
	{
		CClient * player = m_pClientList[iClientH];
		wsprintf(cTxt, "Admin Order(%s): /beginheld \tAdminIP(%s)", player->m_cCharName, player->m_cIPaddress);
		wsprintf(cString, "Heldenian starting in progress.");
	} else { 
		wsprintf(cTxt, "Local command: beginHeldenian");
	}	
	PutLogList(cTxt);	
	if (iClientH != -1) 
	{	
		SendNotifyMsg(NULL, iClientH, NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cString);
	}
	for (i = 0; i < MAXCLIENTS; i++) 
	{	
		CClient * player = m_pClientList[i];
		if ((player != NULL) && (player->m_bIsInitComplete == TRUE))
		{	
			player->m_iSpecialEventID = 1;
			SendNotifyMsg(NULL, i, NOTIFY_HELDENIANSTART,  NULL , NULL, NULL, NULL); // You can now, fight on the battle field
			SendNotifyMsg(NULL, i, NOTIFY_HELDENIANTELEPORT,  NULL , NULL, NULL, NULL); // You can now, go to the battle field
			player->m_iWarContribution   = 0;
			player->m_iConstructionPoint = 10000 + (player->m_iRange * 100);
			if (player->m_iConstructionPoint > MAXHELDENIANSUMMONPOINT) player->m_iConstructionPoint = MAXHELDENIANSUMMONPOINT;
			SendNotifyMsg(NULL, i, NOTIFY_CONSTRUCTIONPOINT, player->m_iConstructionPoint, player->m_iWarContribution, 0, NULL); //0: Tell player of acquired points
		}	
	}

	CMap * map;
	for (x = 0; x < MAXMAPS; x++) 
	{	
		map = m_pMapList[x];
		if (!map) break;
		if (map->m_bIsHeldenianMap) 
		{	
			DeleteOccupyFlags(x);
			for (i = 0; i < MAXCLIENTS; i++) 
			{	
				CClient * player = m_pClientList[i];
				if (player && player->m_bIsInitComplete && player->m_cMapIndex == x && player->m_iAdminUserLevel == 0)
				{	
					RequestTeleportHandler(i, 1, NULL, -1, -1);
				} 
			} 
			for (n = 0; n < MAXNPCS; n++) 
			{	
				if ( (m_pNpcList[n] != NULL) && (m_pNpcList[n]->m_bIsKilled == FALSE) && (m_pNpcList[n]->m_cMapIndex == x))
				{	
					NpcKilledHandler(NULL, NULL, n, NULL);
				}	
			}	
			if (m_iHeldenianType == 1) 
			{
				if (strcmp(map->m_cName, "BtField") == 0) {
					for (i = 0; i < MAX_HELDENIANTOWER; i++) 
					{	
						iNamingValue = map->iGetEmptyNamingValue();
						if (map->m_stHeldenianTower[i].sTypeID < 1)  break;
						if (map->m_stHeldenianTower[i].sTypeID > MAXNPCTYPES) break;
						if (iNamingValue != -1) 
						{	
							dX = map->m_stHeldenianTower[i].dX;
							dY = map->m_stHeldenianTower[i].dY;
							cSide = map->m_stHeldenianTower[i].cSide;
							ZeroMemory(cTmp, sizeof(cTmp));
							if ((map->m_stHeldenianTower[i].sTypeID == 87)&&(cSide == 1)) strcpy(cTmp, "CT-Aresden"); 
							if ((map->m_stHeldenianTower[i].sTypeID == 87)&&(cSide == 2)) strcpy(cTmp, "CT-Elvine"); 
							if ((map->m_stHeldenianTower[i].sTypeID == 89)&&(cSide == 1)) strcpy(cTmp, "AGC-Aresden"); 
							if ((map->m_stHeldenianTower[i].sTypeID == 89)&&(cSide == 2)) strcpy(cTmp, "AGC-Elvine"); 
							if ((map->m_stHeldenianTower[i].sTypeID == 36)&&(cSide == 1)) strcpy(cTmp, "AGT-Aresden"); 
							if ((map->m_stHeldenianTower[i].sTypeID == 36)&&(cSide == 2)) strcpy(cTmp, "AGT-Elvine"); 
							if ((map->m_stHeldenianTower[i].sTypeID == 37)&&(cSide == 1)) strcpy(cTmp, "CGT-Aresden"); 
							if ((map->m_stHeldenianTower[i].sTypeID == 37)&&(cSide == 2)) strcpy(cTmp, "CGT-Elvine"); 
							if ((map->m_stHeldenianTower[i].sTypeID == 39)&&(cSide == 1)) strcpy(cTmp, "DT-Aresden"); 
							if ((map->m_stHeldenianTower[i].sTypeID == 39)&&(cSide == 2)) strcpy(cTmp, "DT-Elvine"); 
							ZeroMemory(cName, sizeof(cName));
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = 95;
							cName[1] = i + 65;
							bRet = bCreateNewNpc(cTmp, cName, map->m_cName, 0, MOVETYPE_RANDOM, &dX, &dY, cNpcWaypointIndex, NULL, NULL, cSide, FALSE, FALSE, FALSE, TRUE);

							if (bRet == FALSE) 
							{	
								map->SetNamingValueEmpty(iNamingValue);
							} else {	
								map->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
								if ((m_pNpcList[sOwnerH] != NULL) && (sOwnerH > 0) && (sOwnerH < MAXNPCS)) 
								{	
									m_pNpcList[sOwnerH]->m_iBuildCount = 0;								
									m_pNpcList[sOwnerH]->m_sAppr2 = 0;
									m_pNpcList[sOwnerH]->m_side = cSide;
								}
								if (cSide == 1)	m_iHeldenianAresdenLeftTower += 1;
								if (cSide == 2) m_iHeldenianElvineLeftTower += 1;
							}	
						}	
					}
					wsprintf(cTxt,"Towers Created on (%s) For Event Type %d HeldenianAresdenLeftTower : %d , HeldenianElvineLeftTower : %d", map->m_cName, m_iHeldenianType, m_iHeldenianAresdenLeftTower, m_iHeldenianElvineLeftTower);
					PutLogList(cTxt);
				}
			}
			else if (m_iHeldenianType == 2) 
			{	
				if (strcmp(map->m_cName, "GodH") == 0) 
				{	
					SetHeldenianFlag(x, map->m_sHeldenianWinningZoneX, map->m_sHeldenianWinningZoneY, m_iHeldenianType1Winner, 616, -1, 2); 
				}
				// Possibilty to set towers, detectors etc....
				if (strcmp(map->m_cName, "HRampart") == 0) 
				{	for (i = 0; i < MAX_HELDENIANTOWER; i++) 
				{	if (map->m_stHeldenianTower[i].sTypeID < 1)  break;
				if (map->m_stHeldenianTower[i].sTypeID > MAXNPCTYPES) break;
				iNamingValue = map->iGetEmptyNamingValue();						
				if (iNamingValue != -1) 
				{	
					dX = map->m_stHeldenianTower[i].dX;
					dY = map->m_stHeldenianTower[i].dY;
					cSide = m_iHeldenianType2Winner;
					ZeroMemory(cTmp, sizeof(cTmp));
					if ((map->m_stHeldenianTower[i].sTypeID == 87)&&(cSide == 1)) strcpy(cTmp, "CT-Aresden"); 
					if ((map->m_stHeldenianTower[i].sTypeID == 87)&&(cSide == 2)) strcpy(cTmp, "CT-Elvine"); 
					if ((map->m_stHeldenianTower[i].sTypeID == 89)&&(cSide == 1)) strcpy(cTmp, "AGC-Aresden"); 
					if ((map->m_stHeldenianTower[i].sTypeID == 89)&&(cSide == 2)) strcpy(cTmp, "AGC-Elvine"); 
					if ((map->m_stHeldenianTower[i].sTypeID == 36)&&(cSide == 1)) strcpy(cTmp, "AGT-Aresden"); 
					if ((map->m_stHeldenianTower[i].sTypeID == 36)&&(cSide == 2)) strcpy(cTmp, "AGT-Elvine"); 
					if ((map->m_stHeldenianTower[i].sTypeID == 37)&&(cSide == 1)) strcpy(cTmp, "CGT-Aresden"); 
					if ((map->m_stHeldenianTower[i].sTypeID == 37)&&(cSide == 2)) strcpy(cTmp, "CGT-Elvine"); 
					if ((map->m_stHeldenianTower[i].sTypeID == 39)&&(cSide == 1)) strcpy(cTmp, "DT-Aresden"); 
					if ((map->m_stHeldenianTower[i].sTypeID == 39)&&(cSide == 2)) strcpy(cTmp, "DT-Elvine"); 
					ZeroMemory(cName, sizeof(cName));
					wsprintf(cName, "XX%d", iNamingValue);
					cName[0] = 95;
					cName[1] = i + 65;
					bRet = bCreateNewNpc(cTmp, cName, map->m_cName, 0, MOVETYPE_RANDOM, &dX, &dY, cNpcWaypointIndex, NULL, NULL, cSide, FALSE, FALSE, FALSE, TRUE);
					if (bRet == FALSE) 
					{	
						map->SetNamingValueEmpty(iNamingValue);
					} else {	
						map->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
						if ((m_pNpcList[sOwnerH] != NULL) && (sOwnerH > 0) && (sOwnerH < MAXNPCS)) 
						{	
							m_pNpcList[sOwnerH]->m_iBuildCount = 0;							
							m_pNpcList[sOwnerH]->m_sAppr2 = 0;
							m_pNpcList[sOwnerH]->m_side = cSide;
						}	
					}	
				}	
				}	
				}
				if (strcmp(map->m_cName, "HRampart") == 0) 
				{	
					for (i = 0; i < MAXHELDENIANDOOR; i++) 
					{	
						if (map->m_stHeldenianGateDoor[i].dX < 1)  break;
						iNamingValue = map->iGetEmptyNamingValue();
						if (iNamingValue != -1) 
						{	
							dX = map->m_stHeldenianGateDoor[i].dX;
							dY = map->m_stHeldenianGateDoor[i].dY;
							ZeroMemory(cTmp, sizeof(cTmp));
							if (m_iHeldenianType2Winner == 1) strcpy(cTmp, "gate-a"); 
							else							 strcpy(cTmp, "gate-e"); 
							cSide = m_iHeldenianType2Winner;
							ZeroMemory(cName, sizeof(cName));
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = 95;
							cName[1] = i + 65;
							bRet = bCreateNewNpc(cTmp, cName, map->m_cName, 0, MOVETYPE_RANDOM, &dX, &dY, cNpcWaypointIndex, NULL, NULL, cSide, FALSE, FALSE, FALSE, TRUE);
							if (bRet == FALSE) 
							{	
								map->SetNamingValueEmpty(iNamingValue);
							} else {	
								map->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
								if ((m_pNpcList[sOwnerH] != NULL) && (sOwnerH > 0) && (sOwnerH < MAXNPCS)) 
								{	
									m_pNpcList[sOwnerH]->m_iBuildCount = 0;
									m_pNpcList[sOwnerH]->m_side = cSide;
									m_pNpcList[sOwnerH]->m_cDir = map->m_stHeldenianGateDoor[i].cDir;
									wsprintf(cTxt,"(_) Gate installed at %d,%d", dX, dY);
									PutLogList(cTxt);
								}	
							}	
						}	
					}	
				}	
			}	
		}	
	}
	if (m_iHeldenianType == 1) tempwin = m_iHeldenianType1Winner;
	else tempwin = m_iHeldenianType2Winner;
	m_bHeldenianMode = TRUE;
	UpdateHeldenianStatus();
	wsprintf(cTxt,"(_) Heldenian mode ON. (type %d, last winner:%d)", m_iHeldenianType, tempwin);
	PutLogList(cTxt);
}

void CGame::UpdateHeldenianStatus() const
{	
	int shortCutIndex = 0;
	while(int index = m_iClientShortCut[shortCutIndex++])
	{
		SendNotifyMsg(NULL, index, NOTIFY_HELDENIANCOUNT, 
			m_iHeldenianAresdenLeftTower, m_iHeldenianAresdenFlags, m_iHeldenianAresdenKill, NULL, 
			m_iHeldenianAresdenDead, m_iHeldenianElvineLeftTower, m_iHeldenianElvineFlags, m_iHeldenianElvineKill, m_iHeldenianElvineDead);
	}
}

bool CGame::SetHeldenianFlag(char cMapIndex, int dX, int dY, int iSide, int iEKNum, int iClientH, int code)
{ 
	int ix, iy;
	char cTxt[120];
	int   iDynamicObjectIndex, iIndex;
	class CTile * pTile;
	DWORD dwTime = timeGetTime();

	CClient * player = m_pClientList[iClientH];
	CMap * map = m_pMapList[cMapIndex];

	if (map == NULL)									return FALSE;
	pTile = (class CTile *)(map->m_pTile + dX + dY*map->m_sSizeY);
	if (pTile->m_iOccupyFlagIndex != NULL)								return FALSE;
	if (pTile->m_bIsMoveAllowed == FALSE)								return FALSE;
	if (map->m_iTotalOccupyFlags >= MAXOCCUPYFLAG)	return FALSE;

	if (code == 1) // Flag set by a character
	{	 
		if ((m_bHeldenianMode) && (m_iHeldenianType == 1) && (map->m_bIsHeldenianMap == TRUE) && (player->m_iGuildRank == 0)) 
		{	
			if (player == NULL) return FALSE;
			switch (player->m_side) 
			{
			case ARESDEN:// Aresden:
				iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_ARESDENFLAG, cMapIndex, dX, dY, NULL, NULL);
				m_iHeldenianAresdenFlags++;
				break;
			case ELVINE:// Elvine	
				iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_ELVINEFLAG, cMapIndex, dX, dY, NULL, NULL);	
				m_iHeldenianElvineFlags++;
				break;
			default:// Others
				return FALSE;
				break;
			}
			iIndex = map->iRegisterOccupyFlag(dX, dY, iSide, 615, iDynamicObjectIndex);
			if (iIndex == -1) PutLogList("Error registering MasterOccupyFlag.");	
			for (ix = dX-20; ix <= dX+35; ix++) 
				for (iy = dY-20; iy <= dY+25; iy++) 
				{	
					if ((ix == dX) && (iy == dY)) 
					{ 
					} else {	
						pTile = (class CTile *)(map->m_pTile + ix + iy*map->m_sSizeY);			
						if (pTile->m_iOccupyFlagIndex == NULL) 
						{	
							switch (player->m_side) 
							{
							case ARESDEN:// Aresden 
								break;
							case ELVINE: // Elvine	
								break;
							default:
								break;
							}	
						}	
					}	
				}	
				wsprintf(cTxt, "Player(%s) Placed Flag On (%s) Cords(%d/%d) Type (%d) (Ares Flag ++ %d Elvine Flag ++ %d", player->m_cCharName, player->m_cMapName, dX, dY, m_iHeldenianType, m_iHeldenianAresdenFlags, m_iHeldenianElvineFlags);
				PutLogList(cTxt);
		}
		else if ((m_bHeldenianMode) && (m_iHeldenianType == 2) && (cMapIndex == m_iGodHMapIndex) && (player->m_iGuildRank == 0) && (player->m_side != m_iHeldenianType1Winner)) 
		{
			if (player == NULL) return FALSE;
			if ((abs(map->m_sHeldenianWinningZoneX - dX) > 1) || (abs(map->m_sHeldenianWinningZoneY - dY) > 1)) return FALSE;
			switch (player->m_side) 
			{
			case ARESDEN:	// Aresden:
				iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_ARESDENFLAG, cMapIndex, dX, dY, NULL, NULL);	
				break;
			case ELVINE: // Elvine	
				iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_ELVINEFLAG, cMapIndex, dX, dY, NULL, NULL);	
				break;
			default: // Others
				return FALSE;
				break;
			}
			iIndex = map->iRegisterOccupyFlag(dX, dY, iSide, 615, iDynamicObjectIndex);
			if (iIndex == -1) PutLogList("Error registering MasterOccupyFlag.");	
			for (ix = dX-20; ix <= dX+35; ix++) 
				for (iy = dY-20; iy <= dY+25; iy++) 
				{	
					if ((ix == dX) && (iy == dY)) 
					{
					} else {	
						pTile = (class CTile *)(map->m_pTile + ix + iy*map->m_sSizeY);			
						if (pTile->m_iOccupyFlagIndex == NULL) 
						{	
							switch (player->m_side) 
							{
							case ARESDEN:	// Aresden 
								break;
							case ELVINE: // Elvine	
								break;
							default:
								break;
							}	
						}	
					}	
				}	
				wsprintf(cTxt, "Player(%s) Placed Flag %s Cords(%d/%d)", player->m_cCharName, player->m_cMapName, dX, dY);
				PutLogList(cTxt);	
				HeldenianEndWarNow(m_iHeldenianType, (Side)player->m_side);
				player->m_iConstructionPoint += (1000 * iEKNum);
				player->m_iWarContribution   += (100 * iEKNum);
				if (player->m_iConstructionPoint > MAXHELDENIANSUMMONPOINT) player->m_iConstructionPoint = MAXHELDENIANSUMMONPOINT;
		}
	}	
	else if (code == 2) 
	{  
		if ((m_bHeldenianMode) && (m_iHeldenianType == 2) && (cMapIndex == m_iGodHMapIndex)) 
		{
			switch (m_iHeldenianType1Winner) 
			{
			case ARESDEN:// Aresden:
				iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_ARESDENFLAG, cMapIndex, dX, dY, NULL, NULL);	
				break;
			case ELVINE:// Elvine	
				iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_ELVINEFLAG, cMapIndex, dX, dY, NULL, NULL);	
				break;
			default:// Others
				return FALSE;
				break;
			}
			if (iDynamicObjectIndex == NULL) return FALSE;
			iIndex = map->iRegisterOccupyFlag(dX, dY, iSide, 615, iDynamicObjectIndex);
			if (iIndex == -1) PutLogList("Error registering MasterOccupyFlag.");	
			for (ix = dX-20; ix <= dX+35; ix++) 
				for (iy = dY-20; iy <= dY+25; iy++) 
				{	
					if ((ix == dX) && (iy == dY)) 
					{
					} else {	
						pTile = (class CTile *)(map->m_pTile + ix + iy*map->m_sSizeY);			
						if (pTile->m_iOccupyFlagIndex == NULL) 
						{	
							switch (m_iHeldenianType1Winner) 
							{
							case ARESDEN:	// Aresden 
								break;
							case ELVINE: // Elvine	
								break;
							default:
								break;
							}	
						}	
					}	
				}	
				wsprintf(cTxt, "Server Set Defending Flag On(%s) Cords(%d/%d) Type(%d)", player->m_cMapName, dX, dY, m_iHeldenianType);
				PutLogList(cTxt);	
		}
	}
	UpdateHeldenianStatus();
	return TRUE;
}

void CGame::HeldenianEndWarNow(int m_iHeldenianType, Side side)
{	
	char cTxt[120];
	if (!m_bHeldenianMode) return;
	m_iHeldenianAresdenLeftTower	= 0;
	m_iHeldenianElvineLeftTower		= 0;
	m_iHeldenianAresdenFlags		= 0;
	m_iHeldenianElvineFlags			= 0;
	m_iHeldenianAresdenDead			= 0;
	m_iHeldenianElvineDead			= 0;
	m_iHeldenianAresdenKill			= 0;
	m_iHeldenianElvineKill			= 0;

	if (m_iHeldenianType == 1) 
	{	
		if (m_iBtFieldMapIndex == -1) return;

		if (m_iHeldenianAresdenLeftTower > m_iHeldenianElvineLeftTower) 
			m_iHeldenianType1Winner = 1;
		else if (m_iHeldenianAresdenLeftTower < m_iHeldenianElvineLeftTower) 
			m_iHeldenianType1Winner = 2;

		switch(m_iHeldenianType1Winner) 
		{
		case 1: 
			wsprintf(cTxt, "Heldenian Type 1 Finished. Aresden won.");
			break;
		case 2: 
			wsprintf(cTxt, "Heldenian Type 1 Finished. Elvine won.");
			break;
		default: 
			wsprintf(cTxt, "Heldenian Type 1 Finished. Draw.");
			break;
		}
	}
	if (m_iHeldenianType == 2) 
	{ 
		switch(side) 
		{
		case ARESDEN: 
			wsprintf(cTxt, "Heldenian Type 2 Finished. Aresden won.");
			m_iHeldenianType2Winner = 1;
			break;
		case ELVINE: 
			wsprintf(cTxt, "Heldenian Type 2 Finished. Elvine won.");
			m_iHeldenianType2Winner = 2;
			break;
		default: 
			wsprintf(cTxt, "Heldenian Type 2 Finished. Draw.");
			break;
		}
	}

	CMap * map;
	for (int m = 0; m < MAXMAPS; m++) 
	{	
		map = m_pMapList[m];

		if (!map) break;
		if (map->m_bIsHeldenianMap) 
		{	
			DeleteOccupyFlags(m);
			for (int n = 0; n < MAXNPCS; n++) 
			{	
				if ( (m_pNpcList[n] != NULL) && (m_pNpcList[n]->m_bIsKilled == FALSE) && (m_pNpcList[n]->m_cMapIndex == m))
				{	
					NpcKilledHandler(NULL, NULL, n, NULL);
				}	
			}	
			for (int j = 0; j < MAXCLIENTS; j++)
			{	
				if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == TRUE) && (m_pClientList[j]->m_cMapIndex == m))
				{	
					if (m_iHeldenianType == 1) 
					{
						SendNotifyMsg(NULL, j, NOTIFY_HELDENIANVICTORY,  m_iHeldenianType1Winner, NULL, NULL, NULL); 
					} else {
						SendNotifyMsg(NULL, j, NOTIFY_HELDENIANVICTORY,  m_iHeldenianType2Winner, NULL, NULL, NULL); 
					}
					SendNotifyMsg(NULL, j, NOTIFY_HELDENIANEND, NULL, NULL, NULL, NULL);
					m_pClientList[j]->m_iSpecialEventID = 2;
					if ((m_pClientList[j]->m_side != side) && (m_pClientList[j]->m_iAdminUserLevel == 0))
					{	
						SendNotifyMsg(NULL, j, NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						m_pClientList[j]->m_bIsWarLocation = TRUE;
						m_pClientList[j]->m_iTimeLeft_ForceRecall = 300;
						RequestTeleportHandler(j, 0);
					}	
				}	
			}
		}
	}
	PutLogList(cTxt);
	_CreateHeldenianGUID(m_dwHeldenianGUID, m_iHeldenianType1Winner, m_iHeldenianType2Winner, m_iHeldenianType);
	m_bHeldenianMode		 = FALSE;
	UpdateHeldenianStatus();
	PutLogList("(!!) Heldenian Mode OFF.");

}
void CGame::HeldenianPlayerKill(CClient * killer, CClient * victim)
{	
	if(victim->m_side == 1) 
	{
		m_iHeldenianAresdenDead++;
		m_iHeldenianElvineKill++;
	} else {
		m_iHeldenianElvineDead++;
		m_iHeldenianAresdenKill++;
	}
	UpdateHeldenianStatus();
}
void CGame::CheckHeldenianResultCalculation(int iClientH) const
{	
	char cTxt[120];
	CClient * player = m_pClientList[iClientH];
	if (player == NULL) return;
	if (player->m_iSpecialEventID == 0) return; 
	if ((!m_bHeldenianMode) && (player->m_iSpecialEventID > 0) && (player->m_iWarContribution > 0))
	{	
		if (player->m_iWarContribution > 100*1000) player->m_iWarContribution = 100*1000;		
		SendNotifyMsg(NULL, iClientH, NOTIFY_CONSTRUCTIONPOINT, 0, 0, 1, NULL); 
		if (player->m_iSpecialEventID > 0) 
		{	
			if (m_iHeldenianType == 1) 
			{
				SendNotifyMsg(NULL, iClientH, NOTIFY_HELDENIANVICTORY,  m_iHeldenianType1Winner, NULL, NULL, NULL); 
			} else {
				SendNotifyMsg(NULL, iClientH, NOTIFY_HELDENIANVICTORY,  m_iHeldenianType2Winner, NULL, NULL, NULL); 
			}
			if (player->m_iLevel < 180)
			{	
				player->m_iWarContribution += (200 - player->m_iLevel)*100;
			}else player->m_iWarContribution += 2000; 
			if (m_iHeldenianType == 1) 
			{
				if (m_iHeldenianType1Winner == player->m_side) 
				{	
					player->m_iExpStock += player->m_iWarContribution*50;
					wsprintf(cTxt, "Heldenian Exp:     PC(%s) Got %d xp.", player->m_cCharName, player->m_iWarContribution*50);	
					PutLogList(cTxt);

				}else if (m_iHeldenianType1Winner != player->m_side)
				{	
					player->m_iExpStock += player->m_iWarContribution*25;							
					wsprintf(cTxt, "Heldenian Exp:     PC(%s) Got %d xp.", player->m_cCharName, player->m_iWarContribution*25);	
					PutLogList(cTxt);
				}	
			} else {
				if (m_iHeldenianType2Winner == player->m_side) 
				{	
					player->m_iExpStock += player->m_iWarContribution*50;
					wsprintf(cTxt, "Heldenian Exp:     PC(%s) Got %d xp.", player->m_cCharName, player->m_iWarContribution*50);	
					PutLogList(cTxt);

				}else if (m_iHeldenianType2Winner != player->m_side)
				{	
					player->m_iExpStock += player->m_iWarContribution*25;							
					wsprintf(cTxt, "Heldenian Exp:     PC(%s) Got %d xp.", player->m_cCharName, player->m_iWarContribution*25);	
					PutLogList(cTxt);
				}	
			}
		}		
		player->m_iSpecialEventID    = 0;
		player->m_iWarContribution   = 0;
		player->m_iConstructionPoint = 0;
	}
}

void CGame::RequestHeldenianScroll(int iClientH, char * pData, DWORD dwMsgSize)
{
	char  *cp, cData[256], cTmpName[21];
	int   iItemNbe;
	class CItem * pItem;
	int   iRet, iEraseReq, iNeededPts;
	short * sp;
	WORD  * wp;
	DWORD * dwp;
	char cTxt[120];
	CClient * player = m_pClientList[iClientH];
	if (player == NULL)					 return;
	if (player->m_bIsInitComplete == FALSE) return;
	if (!m_bHeldenianMode)						 return;
	if (player->m_iGuildRank != 0)			 return;

	if (_iGetItemSpaceLeft(iClientH) == 0) 
	{	
		SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
		return;
	}
	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, cp);
	cp += 20;
	wp = (WORD *)cp;
	iItemNbe = (int) *wp; 
	cp += 2;
	wsprintf(cTxt, "PC(%s) obtained a summon scroll (%d).   %s(%d %d)", player->m_cCharName, iItemNbe, player->m_cMapName, player->m_sX, player->m_sY);	
	PutLogList(cTxt);	
	switch (iItemNbe)
	{
	case 875: // Sorceress
		iNeededPts = 2000;
		break;
	case 876: // Ancient Temple Knight
		iNeededPts = 3000;
		break;
	case 877: // Elf Master
		iNeededPts = 1500;
		break;
	case 878: // DarkShadow Knight
		iNeededPts = 3000;
		break;
	case 879: // Heavy Battle Tank
		iNeededPts = 4000;
		break;
	case 880: // Barbarian
		iNeededPts = 3000;
		break;
	default:
		iNeededPts = 999999;
		PutLogList("Gail asked to create a wrong item!");	
		break;
	}
	if (player->m_iConstructionPoint < iNeededPts)
	{	// Unable to get item...
	}else
	{	// Get the scroll
		player->m_iConstructionPoint -= iNeededPts;
		SendNotifyMsg(NULL, iClientH, NOTIFY_CONSTRUCTIONPOINT, player->m_iConstructionPoint, player->m_iWarContribution, 0, NULL); // 0:tell client
	}
	pItem = NULL;
	pItem = new class CItem;
	if (pItem == NULL) return;
	if ((_bInitItemAttr(pItem, iItemNbe) == TRUE)) 
	{	
		pItem->m_sTouchEffectType = ITET_UNIQUE_OWNER;
		pItem->m_sTouchEffectValue1 = player->m_sCharIDnum1;
		pItem->m_sTouchEffectValue2 = player->m_sCharIDnum2;
		pItem->m_sTouchEffectValue3 = player->m_sCharIDnum3;
		memcpy(&pItem->m_sItemSpecEffectValue1, &m_dwHeldenianGUID, 4);
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
		{	
			ZeroMemory(cData, sizeof(cData));
			dwp  = (DWORD *)(cData + INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + INDEX2_MSGTYPE);
			*wp  = NOTIFY_ITEMOBTAINED;				
			cp = (char *)(cData + INDEX2_MSGTYPE + 2);				
			*cp = 1;
			cp++;				
			memcpy(cp, pItem->m_cName, 20);
			cp += 20;				
			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;				
			*cp = pItem->m_cItemType;
			cp++;				
			*cp = pItem->m_cEquipPos;
			cp++;				
			*cp = (char)0; 
			cp++;				
			sp  = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;				
			*cp = pItem->m_cGenderLimit;
			cp++;				
			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;				
			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;				
			sp  = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;				
			sp  = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;
			*cp = pItem->m_cItemColor;
			cp++;
			*cp = (char)pItem->m_sItemSpecEffectValue2; 
			cp++;				
			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;
			if (iEraseReq == 1) delete pItem;				
			iRet = player->m_pXSock->iSendMsg(cData, 53);
			switch (iRet) {
			case XSOCKEVENT_QUENEFULL:
			case XSOCKEVENT_SOCKETERROR:
			case XSOCKEVENT_CRITICALERROR:
			case XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				break;
			}
		} else {	
			m_pMapList[ player->m_cMapIndex ]->bSetItem(player->m_sX, player->m_sY, pItem);			
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, player->m_cMapIndex, player->m_sX, player->m_sY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 		
			dwp  = (DWORD *)(cData + INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + INDEX2_MSGTYPE);
			*wp  = NOTIFY_CANNOTCARRYMOREITEM;				
			iRet = player->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
			case XSOCKEVENT_QUENEFULL:
			case XSOCKEVENT_SOCKETERROR:
			case XSOCKEVENT_CRITICALERROR:
			case XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				break;
			}	
		}
	} else {	
		delete pItem;
		pItem = NULL;
	}
}
void CGame::Apocalypse_MonsterCount(int iClientH)
{
	CClient * player = m_pClientList[iClientH];
	CMap * map = m_pMapList[player->m_cMapIndex];
	if (player == NULL) return;
	SendNotifyMsg(NULL, player->m_handle, NOTIFY_MONSTERCOUNT, map->m_iTotalActiveObject, NULL, NULL, NULL);
}
